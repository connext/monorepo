{
  "address": "0x37B118dFc50981738B59b7E640135F41813a50A9",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_delayBlocks",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "_merkle",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_watcherManager",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_minDisputeBlocks",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_disputeBlocks",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "ProposedOwnable__onlyOwner_notOwner",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ProposedOwnable__onlyProposed_notProposedOwner",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ProposedOwnable__ownershipDelayElapsed_delayNotElapsed",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ProposedOwnable__proposeNewOwner_invalidProposal",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ProposedOwnable__proposeNewOwner_noOwnershipChange",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ProposedOwnable__renounceOwnership_invalidProposal",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ProposedOwnable__renounceOwnership_noProposal",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RootManager__renounceOwnership_prohibited",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RootManager_activateOptimisticMode__OptimisticModeOn",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RootManager_aggregate__OptimisticModeOn",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RootManager_checkDomains__InvalidDomains",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RootManager_constructor__DisputeBlocksLowerThanMin",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RootManager_finalize__InvalidAggregateRoot",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RootManager_finalize__InvalidInputHash",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RootManager_finalize__ProposeInProgress",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RootManager_onlyOptimisticMode__SlowModeOn",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "caller",
          "type": "address"
        }
      ],
      "name": "RootManager_onlyProposer__NotWhitelistedProposer",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RootManager_propagate__AggregateRootIsZero",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "snapshotId",
          "type": "uint256"
        }
      ],
      "name": "RootManager_proposeAggregateRoot__InvalidSnapshotId",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RootManager_proposeAggregateRoot__ProposeInProgress",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RootManager_sendRootToHub__NoMessageSent",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RootManager_setDisputeBlocks__DisputeBlocksLowerThanMin",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RootManager_setDisputeBlocks__SameDisputeBlocksAsBefore",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RootManager_setHubDomain__InvalidDomain",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RootManager_setMinDisputeBlocks__SameMinDisputeBlocksAsBefore",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "aggregateRoot",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "domainsHash",
          "type": "bytes32"
        }
      ],
      "name": "AggregateRootPropagated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "snapshotId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "endOfDispute",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "aggregateRoot",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "baseRoot",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "bytes32[]",
          "name": "snapshotsRoots",
          "type": "bytes32[]"
        },
        {
          "indexed": false,
          "internalType": "uint32[]",
          "name": "domains",
          "type": "uint32[]"
        }
      ],
      "name": "AggregateRootProposed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "aggregateRoot",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "rootTimestamp",
          "type": "uint256"
        }
      ],
      "name": "AggregateRootSavedOptimistic",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "aggregateRoot",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "leafCount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bytes32[]",
          "name": "aggregatedRoots",
          "type": "bytes32[]"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "rootTimestamp",
          "type": "uint256"
        }
      ],
      "name": "AggregateRootSavedSlow",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "domain",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "connector",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint32[]",
          "name": "domains",
          "type": "uint32[]"
        },
        {
          "indexed": false,
          "internalType": "address[]",
          "name": "connectors",
          "type": "address[]"
        }
      ],
      "name": "ConnectorAdded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "domain",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "connector",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint32[]",
          "name": "domains",
          "type": "uint32[]"
        },
        {
          "indexed": false,
          "internalType": "address[]",
          "name": "connectors",
          "type": "address[]"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "caller",
          "type": "address"
        }
      ],
      "name": "ConnectorRemoved",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "previous",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "updated",
          "type": "uint256"
        }
      ],
      "name": "DelayBlocksUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "previous",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "updated",
          "type": "uint256"
        }
      ],
      "name": "DisputeBlocksUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "domain",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "connector",
          "type": "address"
        }
      ],
      "name": "DomainAdded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "domain",
          "type": "uint32"
        }
      ],
      "name": "DomainRemoved",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [],
      "name": "HubDomainCleared",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "domain",
          "type": "uint32"
        }
      ],
      "name": "HubDomainSet",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "previous",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "updated",
          "type": "uint256"
        }
      ],
      "name": "MinDisputeBlocksUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [],
      "name": "OptimisticModeActivated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "proposedOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipProposed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "Paused",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "domain",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "connector",
          "type": "address"
        }
      ],
      "name": "PropagateFailed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "proposer",
          "type": "address"
        }
      ],
      "name": "ProposerAdded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "proposer",
          "type": "address"
        }
      ],
      "name": "ProposerRemoved",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "fraudulentRoot",
          "type": "bytes32"
        }
      ],
      "name": "RootDiscarded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint32",
          "name": "domain",
          "type": "uint32"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "receivedRoot",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "queueIndex",
          "type": "uint256"
        }
      ],
      "name": "RootReceived",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "watcher",
          "type": "address"
        }
      ],
      "name": "SlowModeActivated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "Unpaused",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "watcherManager",
          "type": "address"
        }
      ],
      "name": "WatcherManagerChanged",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "DEQUEUE_MAX",
      "outputs": [
        {
          "internalType": "uint128",
          "name": "",
          "type": "uint128"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "FINALIZED_HASH",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "MAX_DOMAINS",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "MERKLE",
      "outputs": [
        {
          "internalType": "contract MerkleTreeManager",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "acceptProposedOwner",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "activateOptimisticMode",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "activateSlowMode",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "_domain",
          "type": "uint32"
        },
        {
          "internalType": "address",
          "name": "_connector",
          "type": "address"
        }
      ],
      "name": "addConnector",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_proposer",
          "type": "address"
        }
      ],
      "name": "addProposer",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "_domain",
          "type": "uint32"
        },
        {
          "internalType": "bytes32",
          "name": "_inbound",
          "type": "bytes32"
        }
      ],
      "name": "aggregate",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "allowlistedProposers",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "clearHubDomain",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "connectors",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "connectorsHash",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "delay",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "delayBlocks",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "dequeue",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "_root",
          "type": "bytes32"
        }
      ],
      "name": "discardRoot",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "disputeBlocks",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "domains",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "domainsHash",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "_proposedAggregateRoot",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "_endOfDispute",
          "type": "uint256"
        }
      ],
      "name": "finalize",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "_connectors",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "_fees",
          "type": "uint256[]"
        },
        {
          "internalType": "bytes[]",
          "name": "_encodedData",
          "type": "bytes[]"
        },
        {
          "internalType": "bytes32",
          "name": "_proposedAggregateRoot",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "_endOfDispute",
          "type": "uint256"
        }
      ],
      "name": "finalizeAndPropagate",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "_domain",
          "type": "uint32"
        }
      ],
      "name": "getConnectorForDomain",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "_domain",
          "type": "uint32"
        }
      ],
      "name": "getDomainIndex",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getPendingInboundRootsCount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getSnapshotDuration",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "_snapshotDuration",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "hubDomain",
      "outputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "_domain",
          "type": "uint32"
        }
      ],
      "name": "isDomainSupported",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "",
          "type": "uint32"
        }
      ],
      "name": "lastPropagatedRoot",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "lastSavedAggregateRootTimestamp",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "minDisputeBlocks",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "optimisticMode",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "pause",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "paused",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "pendingInboundRoots",
      "outputs": [
        {
          "internalType": "uint128",
          "name": "first",
          "type": "uint128"
        },
        {
          "internalType": "uint128",
          "name": "last",
          "type": "uint128"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "_connectors",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "_fees",
          "type": "uint256[]"
        },
        {
          "internalType": "bytes[]",
          "name": "_encodedData",
          "type": "bytes[]"
        }
      ],
      "name": "propagate",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_snapshotId",
          "type": "uint256"
        },
        {
          "internalType": "bytes32",
          "name": "_aggregateRoot",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32[]",
          "name": "_snapshotsRoots",
          "type": "bytes32[]"
        },
        {
          "internalType": "uint32[]",
          "name": "_domains",
          "type": "uint32[]"
        }
      ],
      "name": "proposeAggregateRoot",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newlyProposed",
          "type": "address"
        }
      ],
      "name": "proposeNewOwner",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "proposed",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "proposedAggregateRootHash",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "proposedTimestamp",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "_domain",
          "type": "uint32"
        }
      ],
      "name": "removeConnector",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_proposer",
          "type": "address"
        }
      ],
      "name": "removeProposer",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounced",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "sendRootToHubSpoke",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_delayBlocks",
          "type": "uint256"
        }
      ],
      "name": "setDelayBlocks",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_disputeBlocks",
          "type": "uint256"
        }
      ],
      "name": "setDisputeBlocks",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "_domain",
          "type": "uint32"
        }
      ],
      "name": "setHubDomain",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_minDisputeBlocks",
          "type": "uint256"
        }
      ],
      "name": "setMinDisputeBlocks",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_watcherManager",
          "type": "address"
        }
      ],
      "name": "setWatcherManager",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "unpause",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "validAggregateRoots",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "_connectors",
          "type": "address[]"
        }
      ],
      "name": "validateConnectors",
      "outputs": [],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32[]",
          "name": "_domains",
          "type": "uint32[]"
        },
        {
          "internalType": "address[]",
          "name": "_connectors",
          "type": "address[]"
        }
      ],
      "name": "validateDomains",
      "outputs": [],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "watcherManager",
      "outputs": [
        {
          "internalType": "contract WatcherManager",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xf5ccd2449d3799a6480bf648bdc831255341286fccdf9bd54c316be6941f034b",
  "receipt": {
    "to": null,
    "from": "0xa2Ee8DCd2A8A3A54Cf37F6590E5108BbE502B006",
    "contractAddress": "0x37B118dFc50981738B59b7E640135F41813a50A9",
    "transactionIndex": 98,
    "gasUsed": "3449445",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001001000000000000001000000000000000000000020000000000000000000800000000000000000000000000000000400000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000020000000000400000000000000000000000000000000000000000000000000000010",
    "blockHash": "0xa77adf0fc088f94aa53755ae8121544b5700585028a92c76d970d7c022acfa8b",
    "transactionHash": "0xf5ccd2449d3799a6480bf648bdc831255341286fccdf9bd54c316be6941f034b",
    "logs": [
      {
        "transactionIndex": 98,
        "blockNumber": 5287633,
        "transactionHash": "0xf5ccd2449d3799a6480bf648bdc831255341286fccdf9bd54c316be6941f034b",
        "address": "0x37B118dFc50981738B59b7E640135F41813a50A9",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x000000000000000000000000a2ee8dcd2a8a3a54cf37f6590e5108bbe502b006"
        ],
        "data": "0x",
        "logIndex": 189,
        "blockHash": "0xa77adf0fc088f94aa53755ae8121544b5700585028a92c76d970d7c022acfa8b"
      }
    ],
    "blockNumber": 5287633,
    "cumulativeGasUsed": "15248981",
    "status": 1,
    "byzantium": true
  },
  "args": [
    120,
    "0x273F5BCDb84a26922Dc0163Fc8E9a99F70D462FF",
    "0xC96C796e90F2eC8686082003E3b0a2928A2F5202",
    60,
    120
  ],
  "numDeployments": 1,
  "solcInputHash": "f27fc0c5a728e8290f4e343b9381d1ad",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_delayBlocks\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_merkle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_watcherManager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minDisputeBlocks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_disputeBlocks\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ProposedOwnable__onlyOwner_notOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProposedOwnable__onlyProposed_notProposedOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProposedOwnable__ownershipDelayElapsed_delayNotElapsed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProposedOwnable__proposeNewOwner_invalidProposal\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProposedOwnable__proposeNewOwner_noOwnershipChange\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProposedOwnable__renounceOwnership_invalidProposal\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProposedOwnable__renounceOwnership_noProposal\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RootManager__renounceOwnership_prohibited\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RootManager_activateOptimisticMode__OptimisticModeOn\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RootManager_aggregate__OptimisticModeOn\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RootManager_checkDomains__InvalidDomains\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RootManager_constructor__DisputeBlocksLowerThanMin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RootManager_finalize__InvalidAggregateRoot\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RootManager_finalize__InvalidInputHash\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RootManager_finalize__ProposeInProgress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RootManager_onlyOptimisticMode__SlowModeOn\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"RootManager_onlyProposer__NotWhitelistedProposer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RootManager_propagate__AggregateRootIsZero\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"snapshotId\",\"type\":\"uint256\"}],\"name\":\"RootManager_proposeAggregateRoot__InvalidSnapshotId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RootManager_proposeAggregateRoot__ProposeInProgress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RootManager_sendRootToHub__NoMessageSent\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RootManager_setDisputeBlocks__DisputeBlocksLowerThanMin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RootManager_setDisputeBlocks__SameDisputeBlocksAsBefore\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RootManager_setHubDomain__InvalidDomain\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RootManager_setMinDisputeBlocks__SameMinDisputeBlocksAsBefore\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"aggregateRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"domainsHash\",\"type\":\"bytes32\"}],\"name\":\"AggregateRootPropagated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"snapshotId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endOfDispute\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"aggregateRoot\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"baseRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32[]\",\"name\":\"snapshotsRoots\",\"type\":\"bytes32[]\"},{\"indexed\":false,\"internalType\":\"uint32[]\",\"name\":\"domains\",\"type\":\"uint32[]\"}],\"name\":\"AggregateRootProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"aggregateRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rootTimestamp\",\"type\":\"uint256\"}],\"name\":\"AggregateRootSavedOptimistic\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"aggregateRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"leafCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32[]\",\"name\":\"aggregatedRoots\",\"type\":\"bytes32[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rootTimestamp\",\"type\":\"uint256\"}],\"name\":\"AggregateRootSavedSlow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"domain\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"connector\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32[]\",\"name\":\"domains\",\"type\":\"uint32[]\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"connectors\",\"type\":\"address[]\"}],\"name\":\"ConnectorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"domain\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"connector\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32[]\",\"name\":\"domains\",\"type\":\"uint32[]\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"connectors\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"ConnectorRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previous\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"updated\",\"type\":\"uint256\"}],\"name\":\"DelayBlocksUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previous\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"updated\",\"type\":\"uint256\"}],\"name\":\"DisputeBlocksUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"domain\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"connector\",\"type\":\"address\"}],\"name\":\"DomainAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"domain\",\"type\":\"uint32\"}],\"name\":\"DomainRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"HubDomainCleared\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"domain\",\"type\":\"uint32\"}],\"name\":\"HubDomainSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previous\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"updated\",\"type\":\"uint256\"}],\"name\":\"MinDisputeBlocksUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"OptimisticModeActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proposedOwner\",\"type\":\"address\"}],\"name\":\"OwnershipProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"domain\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"connector\",\"type\":\"address\"}],\"name\":\"PropagateFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"}],\"name\":\"ProposerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"}],\"name\":\"ProposerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"fraudulentRoot\",\"type\":\"bytes32\"}],\"name\":\"RootDiscarded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"domain\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"receivedRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"queueIndex\",\"type\":\"uint256\"}],\"name\":\"RootReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"watcher\",\"type\":\"address\"}],\"name\":\"SlowModeActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"watcherManager\",\"type\":\"address\"}],\"name\":\"WatcherManagerChanged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEQUEUE_MAX\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FINALIZED_HASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_DOMAINS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MERKLE\",\"outputs\":[{\"internalType\":\"contract MerkleTreeManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptProposedOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"activateOptimisticMode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"activateSlowMode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_domain\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"_connector\",\"type\":\"address\"}],\"name\":\"addConnector\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_proposer\",\"type\":\"address\"}],\"name\":\"addProposer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_domain\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"_inbound\",\"type\":\"bytes32\"}],\"name\":\"aggregate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowlistedProposers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"clearHubDomain\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"connectors\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"connectorsHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"delay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"delayBlocks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dequeue\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_root\",\"type\":\"bytes32\"}],\"name\":\"discardRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disputeBlocks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"domains\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"domainsHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_proposedAggregateRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_endOfDispute\",\"type\":\"uint256\"}],\"name\":\"finalize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_connectors\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_fees\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_encodedData\",\"type\":\"bytes[]\"},{\"internalType\":\"bytes32\",\"name\":\"_proposedAggregateRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_endOfDispute\",\"type\":\"uint256\"}],\"name\":\"finalizeAndPropagate\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_domain\",\"type\":\"uint32\"}],\"name\":\"getConnectorForDomain\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_domain\",\"type\":\"uint32\"}],\"name\":\"getDomainIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPendingInboundRootsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSnapshotDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_snapshotDuration\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hubDomain\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_domain\",\"type\":\"uint32\"}],\"name\":\"isDomainSupported\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"lastPropagatedRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastSavedAggregateRootTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minDisputeBlocks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"optimisticMode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingInboundRoots\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"first\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"last\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_connectors\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_fees\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_encodedData\",\"type\":\"bytes[]\"}],\"name\":\"propagate\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_snapshotId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_aggregateRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"_snapshotsRoots\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint32[]\",\"name\":\"_domains\",\"type\":\"uint32[]\"}],\"name\":\"proposeAggregateRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newlyProposed\",\"type\":\"address\"}],\"name\":\"proposeNewOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposed\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposedAggregateRootHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposedTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_domain\",\"type\":\"uint32\"}],\"name\":\"removeConnector\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_proposer\",\"type\":\"address\"}],\"name\":\"removeProposer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounced\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sendRootToHubSpoke\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_delayBlocks\",\"type\":\"uint256\"}],\"name\":\"setDelayBlocks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_disputeBlocks\",\"type\":\"uint256\"}],\"name\":\"setDisputeBlocks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_domain\",\"type\":\"uint32\"}],\"name\":\"setHubDomain\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minDisputeBlocks\",\"type\":\"uint256\"}],\"name\":\"setMinDisputeBlocks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_watcherManager\",\"type\":\"address\"}],\"name\":\"setWatcherManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"validAggregateRoots\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_connectors\",\"type\":\"address[]\"}],\"name\":\"validateConnectors\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32[]\",\"name\":\"_domains\",\"type\":\"uint32[]\"},{\"internalType\":\"address[]\",\"name\":\"_connectors\",\"type\":\"address[]\"}],\"name\":\"validateDomains\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"watcherManager\",\"outputs\":[{\"internalType\":\"contract WatcherManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"events\":{\"AggregateRootPropagated(bytes32,bytes32)\":{\"details\":\"It doesnt matter if the root was generated optimistically or on-chain.\",\"params\":{\"aggregateRoot\":\"The aggregate root propagated\",\"domainsHash\":\"The current domain hash\"}},\"AggregateRootProposed(uint256,uint256,bytes32,bytes32,bytes32[],uint32[])\":{\"params\":{\"aggregateRoot\":\"The new aggregate root proposed\",\"baseRoot\":\"The root of the tree before the snapshot roots were inserted by proposer\",\"domains\":\"The list of all domains\",\"endOfDispute\":\"The block at which the dispute period is over\",\"snapshotId\":\"The snapshot id\",\"snapshotsRoots\":\"The list of roots added to aggregate tree\"}},\"AggregateRootSavedOptimistic(bytes32,uint256)\":{\"params\":{\"aggregateRoot\":\"The saved aggregate root\",\"rootTimestamp\":\"The timestamp at which the aggregate root was saved.\"}},\"AggregateRootSavedSlow(bytes32,uint256,bytes32[],uint256)\":{\"params\":{\"aggregateRoot\":\"The saved aggregate root\",\"aggregatedRoots\":\"The verified inbound roots inserted in the tree.\",\"leafCount\":\"The new number of leaves in the tree.\",\"rootTimestamp\":\"The timestamp at which the aggregate root was saved.\"}},\"HubDomainSet(uint32)\":{\"params\":{\"domain\":\"The domain set as hub domain.\"}},\"ProposerAdded(address)\":{\"params\":{\"proposer\":\"The address of the proposer\"}},\"ProposerRemoved(address)\":{\"params\":{\"proposer\":\"The address of the proposer\"}},\"SlowModeActivated(address)\":{\"params\":{\"watcher\":\"The address of the watcher who called the function\"}}},\"kind\":\"dev\",\"methods\":{\"activateOptimisticMode()\":{\"details\":\"Elements in the queue will be discarded. To save gas we are not deleting the elements from the queue, but moving the last counter to first - 1 so we can reassign new elements to those positions in the future. Discarded roots will be included on the upcoming optimistic aggregateRoot.\"},\"activateSlowMode()\":{\"details\":\"Sets the proposed aggregate root hash to FINALIZED_HASH, invalidating it.\"},\"addConnector(uint32,address)\":{\"details\":\"Only owner can add a new connector. Address should be the connector on L1.Cannot add address(0) to avoid duplicated domain in array and reduce gas fee while propagating.\",\"params\":{\"_connector\":\"Address of the hub connector.\",\"_domain\":\"The target spoke domain of the given connector.\"}},\"addProposer(address)\":{\"details\":\"Only allowlisted proposers can call `proposeAggregateRoot`.\"},\"aggregate(uint32,bytes32)\":{\"details\":\"The aggregate tree's root, which will include this inbound root, will be propagated to all spoke domains (via `propagate`) on a regular basis assuming the verification period is surpassed without dispute.\",\"params\":{\"_domain\":\"The source domain of the given root.\",\"_inbound\":\"The inbound root coming from the given domain.\"}},\"constructor\":{\"params\":{\"_delayBlocks\":\"The delay for the validation period for incoming messages in blocks.\",\"_merkle\":\"The address of the MerkleTreeManager on this domain.\",\"_watcherManager\":\"The address of the WatcherManager on this domain.\"}},\"dequeue()\":{\"details\":\"Will dequeue a fixed maximum amount of roots to prevent out of gas errors. As such, this method is public and separate from `propagate` so we can curtail an overloaded queue as needed.\",\"returns\":{\"_0\":\"bytes32 The new aggregate root.\",\"_1\":\"uint256 The updated count (number of leaves).\"}},\"discardRoot(bytes32)\":{\"details\":\"The given root does NOT have to currently be in the queue. It isn't removed from the queue directly, but instead is filtered out when dequeuing is done for the sake of aggregation.Can only be called by the owner when the protocol is paused.\",\"params\":{\"_root\":\"The root to be discarded.\"}},\"finalize(bytes32,uint256)\":{\"details\":\"The system has to be in optimistic mode and propose's dispute time over. Finalized root will stop being monitored by off-chain agents.\",\"params\":{\"_endOfDispute\":\"The block in which the dispute period for proposedAggregateRootHash finalizes\",\"_proposedAggregateRoot\":\"The aggregate root currently proposed\"}},\"finalizeAndPropagate(address[],uint256[],bytes[],bytes32,uint256)\":{\"details\":\"Should be called by relayers only when proposed root is ready to be finalized.\",\"params\":{\"_connectors\":\"Array of connectors: should match exactly the array of `connectors` in storage; used here to reduce gas costs, and keep them static regardless of number of supported domains.\",\"_encodedData\":\"Array of encodedData: extra params for each AMB if required\",\"_endOfDispute\":\"The block in which the dispute period for proposedAggregateRootHash finalizes\",\"_fees\":\"Array of fees in native token for an AMB if required\",\"_proposedAggregateRoot\":\"The aggregate root currently proposed\"}},\"getConnectorForDomain(uint32)\":{\"details\":\"Inefficient, should only be used by caller if they have no index reference.\",\"params\":{\"_domain\":\"The domain for which to get the hub connector address.\"}},\"getDomainIndex(uint32)\":{\"details\":\"Reverts if domain is not supported.\",\"params\":{\"_domain\":\"The domain for which to get the index value.\"}},\"getSnapshotDuration()\":{\"returns\":{\"_snapshotDuration\":\"The duration of the snapshot\"}},\"isDomainSupported(uint32)\":{\"params\":{\"_domain\":\"Domain to check.\"}},\"paused()\":{\"details\":\"Returns true if the contract is paused, and false otherwise.\"},\"propagate(address[],uint256[],bytes[])\":{\"details\":\"Should be called by relayers at a regular interval. Workflow is slightly different depending on the mode the system is in.\",\"params\":{\"_connectors\":\"Array of connectors: should match exactly the array of `connectors` in storage; used here to reduce gas costs, and keep them static regardless of number of supported domains.\",\"_encodedData\":\"Array of encodedData: extra params for each AMB if required\",\"_fees\":\"Array of fees in native token for an AMB if required\"}},\"proposeAggregateRoot(uint256,bytes32,bytes32[],uint32[])\":{\"details\":\"snapshotId, snapshotRoots and domains are needed for validation and data availability for off-chain agents. In the case of domains we need to check which are the current valid domains at the time of proposing. This is gonna be used by the off-chain scripts to know which domains to check when validating each proposition. This is to avoid problems if a new domain is added in the middle of an on-going propose. Domains should be in the same order as they are in this contract. Snapshot roots provided should be in order of insertion and should respect the domains order.\",\"params\":{\"_aggregateRoot\":\"The new aggregate root\",\"_domains\":\"Array of all the domains\",\"_snapshotId\":\"The snapshot id used\",\"_snapshotsRoots\":\"Array of snapshot roots inserted\"}},\"removeConnector(uint32)\":{\"details\":\"Only watcher can remove a connector.The proposedAggregateRootHash will be set to the FINALIZED_HASH. TODO: Could add a metatx-able `removeConnectorWithSig` if we want to use relayers?\",\"params\":{\"_domain\":\"The spoke domain of the target connector we want to remove.\"}},\"removeProposer(address)\":{\"details\":\"Only allowlisted proposers can call `proposeAggregateRoot`.\"},\"renounceOwnership()\":{\"details\":\"Renounce ownership should be impossible as long as watchers can freely remove connectors and only the owner can add them back\"},\"sendRootToHubSpoke()\":{\"details\":\"This has no guards as the guards should be in the spoke connector. For example, the spoke connector should      guard against receiving the root through this function if the spoke connector is not in optimistic mode.\"},\"setHubDomain(uint32)\":{\"params\":{\"_domain\":\"The domain to be set as hub domain.\"}},\"validateConnectors(address[])\":{\"details\":\"Reverts if domains or connectors do not match, including ordering.\",\"params\":{\"_connectors\":\"The given connectors array to check.\"}},\"validateDomains(uint32[],address[])\":{\"details\":\"Reverts if domains or connectors do not match, including ordering.\",\"params\":{\"_connectors\":\"The given connectors array to check.\",\"_domains\":\"The given domains array to check.\"}}},\"stateVariables\":{\"lastSavedAggregateRootTimestamp\":{\"details\":\"Used to ensure that the propagate function will send the latest aggregate root available.\"},\"pendingInboundRoots\":{\"details\":\"Watchers should be able to watch this queue for fraudulent messages and pause this contract if fraud is detected.\"},\"proposedAggregateRootHash\":{\"details\":\"Set to 0x1 to prevent someone from calling finalize() the moment the contract is deployed\"},\"validAggregateRoots\":{\"details\":\"Each time a new aggregate root is generated or finalized, it will be added to this mapping using the block.timestamp as key.This is only used as Data-Availability for off-chain agents. Especially for the Watchers that fetch the correct aggregate root from this contract in order to verify the data proposed on the Spoke Connectors.rootTimestamp => aggregateRoot\"}},\"version\":1},\"userdoc\":{\"events\":{\"AggregateRootPropagated(bytes32,bytes32)\":{\"notice\":\"Emitted when a root is propagated\"},\"AggregateRootProposed(uint256,uint256,bytes32,bytes32,bytes32[],uint32[])\":{\"notice\":\"Emitted when a new aggregate root is proposed\"},\"AggregateRootSavedOptimistic(bytes32,uint256)\":{\"notice\":\"Emitted when an aggregate root is added to the validAggregateRoots map during optimistic mode.\"},\"AggregateRootSavedSlow(bytes32,uint256,bytes32[],uint256)\":{\"notice\":\"Emitted when an aggregate root is added to the validAggregateRoots map during slow mode.\"},\"HubDomainCleared()\":{\"notice\":\"Emitted when the previously set hub domain is cleared.\"},\"HubDomainSet(uint32)\":{\"notice\":\"Emitted when a domain is set as the hub domain.\"},\"OptimisticModeActivated()\":{\"notice\":\"Emitted when optimistic mode is activated\"},\"ProposerAdded(address)\":{\"notice\":\"Emitted when a new proposer is added\"},\"ProposerRemoved(address)\":{\"notice\":\"Emitted when a proposer is removed\"},\"SlowModeActivated(address)\":{\"notice\":\"Emitted when slow mode is activated\"},\"WatcherManagerChanged(address)\":{\"notice\":\"Emitted when the manager address changes\"}},\"kind\":\"user\",\"methods\":{\"DEQUEUE_MAX()\":{\"notice\":\"Maximum number of values to dequeue from the queue in one sitting (one call of `propagate` or `dequeue`). Used to cap gas requirements.\"},\"FINALIZED_HASH()\":{\"notice\":\"Root used to keep the slots of proposedAggregateRootHash warm.\"},\"MAX_DOMAINS()\":{\"notice\":\"The absolute maximum number of domains that we should support. Domain and connector arrays are naturally unbounded, but the gas cost of reading these arrays in `updateHashes()` is bounded by the block's gas limit. If we want to set a hard ceiling for gas costs for the `updateHashes()` method at approx. 500K gas, with an average SLOAD cost of 900 gas per domain (1 uint32, 1 address):       500K / 900 = ~555 domains Realistically, the cap on the number of domains will likely exist in other places, but we cap it here as a last resort.\"},\"MERKLE()\":{\"notice\":\"MerkleTreeManager contract instance. Will hold the active tree of aggregated inbound roots. The root of this tree will be distributed crosschain to all spoke domains.\"},\"acceptProposedOwner()\":{\"notice\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"},\"activateOptimisticMode()\":{\"notice\":\"Owner can set the system to optimistic mode.\"},\"activateSlowMode()\":{\"notice\":\"Watcher can set the system in slow mode.\"},\"addConnector(uint32,address)\":{\"notice\":\"Add a new supported domain and corresponding hub connector to the system. This new domain will receive the propagated aggregate root.\"},\"addProposer(address)\":{\"notice\":\"Adds a proposer to the allowlist.\"},\"aggregate(uint32,bytes32)\":{\"notice\":\"Accept an inbound root coming from a given domain's hub connector, enqueuing this incoming root into the current queue as it awaits the verification period.\"},\"allowlistedProposers(address)\":{\"notice\":\"This is used for the `onlyProposers` modifier, which gates who can propose new roots using `proposeAggregateRoot`.\"},\"clearHubDomain()\":{\"notice\":\"Removes the domain associated with the hub domain.\"},\"connectors(uint256)\":{\"notice\":\"Tracks the addresses of the hub connector contracts corresponding to subscribed spoke domains. The index of any given connector in this array should match the index of that connector's target spoke domain in the `domains` array above.\"},\"connectorsHash()\":{\"notice\":\"A \\\"quick reference\\\" hash used in the `propagate` method below to validate that the provided array of connectors matches the one we have in storage.\"},\"constructor\":{\"notice\":\"Creates a new RootManager instance.\"},\"delay()\":{\"notice\":\"Returns the delay period before a new owner can be accepted.\"},\"delayBlocks()\":{\"notice\":\"Number of blocks to delay the processing of a message to allow for watchers to verify the validity and pause if necessary.\"},\"dequeue()\":{\"notice\":\"Dequeue verified inbound roots and insert them into the aggregator tree.\"},\"discardRoot(bytes32)\":{\"notice\":\"Removes (effectively blocklists) a given (fraudulent) root from the queue of pending inbound roots.\"},\"disputeBlocks()\":{\"notice\":\"The number of blocks watchers have to detect and invalidate the proposed root.\"},\"domains(uint256)\":{\"notice\":\"Domains array tracks currently subscribed domains to this hub aggregator. We should distribute the aggregate root to all of these domains in the `propagate` method.\"},\"domainsHash()\":{\"notice\":\"A \\\"quick reference\\\" hash used in the `propagate` method below to validate that the provided array of domains matches the one we have in storage.\"},\"finalize(bytes32,uint256)\":{\"notice\":\"Finalizes the proposed aggregate root. This makes the current proposed root the new validated and ready to propagate root.\"},\"finalizeAndPropagate(address[],uint256[],bytes[],bytes32,uint256)\":{\"notice\":\"Unifies the flow of finalize and propagate.\"},\"getConnectorForDomain(uint32)\":{\"notice\":\"Gets the corresponding hub connector address for a given spoke domain.\"},\"getDomainIndex(uint32)\":{\"notice\":\"Gets the index of a given domain in the domains and connectors arrays.\"},\"getSnapshotDuration()\":{\"notice\":\"Get the duration of the snapshot\"},\"hubDomain()\":{\"notice\":\"Domain id of the current network\"},\"isDomainSupported(uint32)\":{\"notice\":\"Convenience shortcut for supported domains. Used to sanity check adding new domains.\"},\"lastPropagatedRoot(uint32)\":{\"notice\":\"The last aggregate root we propagated to spoke chains (mapping keyed on domain). Used to prevent sending redundant aggregate roots in `propagate`.\"},\"lastSavedAggregateRootTimestamp()\":{\"notice\":\"Timestamp of the last aggregate root saved.\"},\"minDisputeBlocks()\":{\"notice\":\"The minimum number of blocks disputeBlocks can be set to.\"},\"optimisticMode()\":{\"notice\":\"True if the system is working in optimistic mode. Otherwise is working in slow mode\"},\"owner()\":{\"notice\":\"Returns the address of the current owner.\"},\"pause()\":{\"notice\":\"Watchers can pause contracts if fraud is detected\"},\"pendingInboundRoots()\":{\"notice\":\"Queue used for management of verification for inbound roots from spoke chains. Once the verification period elapses, the inbound messages can be aggregated into the merkle tree for propagation to spoke chains.\"},\"propagate(address[],uint256[],bytes[])\":{\"notice\":\"This is called by relayers to take the current aggregate tree root and propagate it to all spoke domains (via their respective hub connectors).\"},\"proposeAggregateRoot(uint256,bytes32,bytes32[],uint32[])\":{\"notice\":\"Propose a new aggregate root\"},\"proposeNewOwner(address)\":{\"notice\":\"Sets the timestamp for an owner to be proposed, and sets the newly proposed owner as step 1 in a 2-step process\"},\"proposed()\":{\"notice\":\"Returns the address of the proposed owner.\"},\"proposedAggregateRootHash()\":{\"notice\":\"The resulting hash of keccaking the proposed aggregate root and the block at which its dispute ends.\"},\"proposedTimestamp()\":{\"notice\":\"Returns the address of the proposed owner.\"},\"removeConnector(uint32)\":{\"notice\":\"Remove support for a connector and respective domain. That connector/domain will no longer receive updates for the latest aggregate root.\"},\"removeProposer(address)\":{\"notice\":\"Removes a proposer from the allowlist.\"},\"renounceOwnership()\":{\"notice\":\"Remove ability to renounce ownership\"},\"renounced()\":{\"notice\":\"Indicates if the ownership has been renounced() by checking if current owner is address(0)\"},\"sendRootToHubSpoke()\":{\"notice\":\"Sends the latest valid aggregate root to the hub domain's spoke connector.\"},\"setDelayBlocks(uint256)\":{\"notice\":\"Set the `delayBlocks`, the period in blocks over which an incoming message is verified.\"},\"setDisputeBlocks(uint256)\":{\"notice\":\"Set the `disputeBlocks`, the duration, in blocks, of the dispute process for a given proposed root\"},\"setHubDomain(uint32)\":{\"notice\":\"Sets domain corresponding to the hub domain.\"},\"setMinDisputeBlocks(uint256)\":{\"notice\":\"Set the `minDisputeBlocks` variable to the provided parameter.\"},\"setWatcherManager(address)\":{\"notice\":\"Owner can enroll a watcher (abilities are defined by inheriting contracts)\"},\"unpause()\":{\"notice\":\"Owner can unpause contracts if fraud is detected by watchers\"},\"validAggregateRoots(uint256)\":{\"notice\":\"The list of valid aggregate roots for a given timestamp.\"},\"validateConnectors(address[])\":{\"notice\":\"Validate given connectors array is correct (i.e. it mirrors what is currently saved in storage).\"},\"validateDomains(uint32[],address[])\":{\"notice\":\"Validate given domains and connectors arrays are correct (i.e. they mirror what is currently saved in storage).\"},\"watcherManager()\":{\"notice\":\"The `WatcherManager` contract governs the watcher allowlist.\"}},\"notice\":\"This contract exists at cluster hubs, and aggregates all transfer roots from messaging spokes into a single merkle tree. Regularly broadcasts the root of the aggregator tree back out to all the messaging spokes.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/messaging/RootManager.sol\":\"RootManager\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized < type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal function that returns the initialized version. Returns `_initialized`\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Internal function that returns the initialized version. Returns `_initializing`\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\",\"keccak256\":\"0xe798cadb41e2da274913e4b3183a80f50fb057a42238fe8467e077268100ec27\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2edcb41c121abc510932e8d83ff8b82cf9cdde35e7c297622f5c29ef0af25183\",\"license\":\"MIT\"},\"@openzeppelin/contracts/security/Pausable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\",\"keccak256\":\"0x0849d93b16c9940beb286a7864ed02724b248b93e0d80ef6355af5ef15c64773\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf96f969e24029d43d0df89e59d365f277021dac62b48e1c1e3ebe0acdd7f1ca1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"contracts/messaging/MerkleTreeManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity 0.8.17;\\n\\nimport {ProposedOwnableUpgradeable} from \\\"../shared/ProposedOwnableUpgradeable.sol\\\";\\nimport {MerkleLib} from \\\"./libraries/MerkleLib.sol\\\";\\n\\n/**\\n * @title MerkleTreeManager\\n * @notice Contains a Merkle tree instance and exposes read/write functions for the tree.\\n * @dev On the hub domain there are two MerkleTreeManager contracts, one for the hub and one for the MainnetSpokeConnector.\\n */\\ncontract MerkleTreeManager is ProposedOwnableUpgradeable {\\n  // ========== Custom Errors ===========\\n\\n  error MerkleTreeManager__renounceOwnership_prohibited();\\n  error MerkleTreeManager__setArborist_zeroAddress();\\n  error MerkleTreeManager__setArborist_alreadyArborist();\\n\\n  // ============ Events ============\\n\\n  event ArboristUpdated(address previous, address updated);\\n\\n  event LeafInserted(bytes32 root, uint256 count, bytes32 leaf);\\n\\n  event LeavesInserted(bytes32 root, uint256 count, bytes32[] leaves);\\n\\n  // ============ Structs ============\\n\\n  // Status of Message:\\n  //   0 - None - message has not been proven or processed\\n  //   1 - Proven - message inclusion proof has been validated\\n  //   2 - Processed - message has been dispatched to recipient\\n  enum LeafStatus {\\n    None,\\n    Proven,\\n    Processed\\n  }\\n\\n  // ============ Libraries ============\\n\\n  using MerkleLib for MerkleLib.Tree;\\n\\n  // ============ Public Storage ============\\n\\n  /**\\n   * @notice Core data structure with which this contract is tasked with keeping custody.\\n   * Writable only by the designated arborist.\\n   */\\n  MerkleLib.Tree public tree;\\n\\n  /**\\n   * @notice The arborist contract that has permission to write to this tree.\\n   * @dev This could be the root manager contract or a spoke connector contract, for example.\\n   */\\n  address public arborist;\\n\\n  /**\\n   * @notice The leaves that are proven already\\n   */\\n  mapping(bytes32 => LeafStatus) public leaves;\\n\\n  /**\\n   * @notice domain => next available nonce for the domain.\\n   */\\n  mapping(uint32 => uint32) public nonces;\\n\\n  // ============ Modifiers ============\\n\\n  modifier onlyArborist() {\\n    require(arborist == msg.sender, \\\"!arborist\\\");\\n    _;\\n  }\\n\\n  // ============ Getters ============\\n\\n  /**\\n   * @notice Returns the current branch.\\n   */\\n  function branch() public view returns (bytes32[32] memory) {\\n    return tree.branch;\\n  }\\n\\n  /**\\n   * @notice Calculates and returns the current root.\\n   */\\n  function root() public view returns (bytes32) {\\n    return tree.root();\\n  }\\n\\n  /**\\n   * @notice Returns the number of inserted leaves in the tree (current index).\\n   */\\n  function count() public view returns (uint256) {\\n    return tree.count;\\n  }\\n\\n  /**\\n   * @notice Convenience getter: returns the root and count.\\n   */\\n  function rootAndCount() public view returns (bytes32, uint256) {\\n    return (tree.root(), tree.count);\\n  }\\n\\n  // ======== Initializer =========\\n\\n  function initialize(address _arborist) public initializer {\\n    __MerkleTreeManager_init(_arborist);\\n    __ProposedOwnable_init();\\n  }\\n\\n  /**\\n   * @dev Initializes MerkleTreeManager instance. Sets the msg.sender as the initial permissioned\\n   */\\n  function __MerkleTreeManager_init(address _arborist) internal onlyInitializing {\\n    __MerkleTreeManager_init_unchained(_arborist);\\n  }\\n\\n  function __MerkleTreeManager_init_unchained(address _arborist) internal onlyInitializing {\\n    arborist = _arborist;\\n  }\\n\\n  // ============ Admin Functions ==============\\n\\n  /**\\n   * @notice Method for the current arborist to assign write permissions to a new arborist.\\n   * @param newArborist The new address to set as the current arborist.\\n   */\\n  function setArborist(address newArborist) external onlyOwner {\\n    if (newArborist == address(0)) revert MerkleTreeManager__setArborist_zeroAddress();\\n    address current = arborist;\\n    if (current == newArborist) revert MerkleTreeManager__setArborist_alreadyArborist();\\n\\n    // Emit updated event\\n    emit ArboristUpdated(current, newArborist);\\n\\n    arborist = newArborist;\\n  }\\n\\n  /**\\n   * @notice Remove ability to renounce ownership\\n   * @dev Renounce ownership should be impossible as long as there is a possibility the\\n   * arborist may change.\\n   */\\n  function renounceOwnership() public virtual override onlyOwner {\\n    revert MerkleTreeManager__renounceOwnership_prohibited();\\n  }\\n\\n  // ========= Public Functions =========\\n\\n  /**\\n   * @notice Used to increment nonce\\n   * @param _domain The domain the nonce will be used for\\n   * @return _nonce The incremented nonce\\n   */\\n  function incrementNonce(uint32 _domain) public onlyArborist returns (uint32 _nonce) {\\n    _nonce = nonces[_domain]++;\\n  }\\n\\n  /**\\n   * @notice Used to track proven leaves\\n   * @param _leaf The leaf to mark as proven\\n   */\\n  function markAsProven(bytes32 _leaf) public onlyArborist {\\n    require(leaves[_leaf] == LeafStatus.None, \\\"!empty\\\");\\n    leaves[_leaf] = LeafStatus.Proven;\\n  }\\n\\n  /**\\n   * @notice Used to track processed leaves\\n   * @param _leaf The leaf to mark as proven\\n   */\\n  function markAsProcessed(bytes32 _leaf) public onlyArborist {\\n    require(leaves[_leaf] == LeafStatus.Proven, \\\"!proven\\\");\\n    leaves[_leaf] = LeafStatus.Processed;\\n  }\\n\\n  /**\\n   * @notice Inserts the given leaves into the tree.\\n   * @param _leaves The leaves to be inserted into the tree.\\n   * @return _root Current root for convenience.\\n   * @return _count Current node count (i.e. number of indices) AFTER the insertion of the new leaf,\\n   * provided for convenience.\\n   */\\n  function insert(bytes32[] memory _leaves) public onlyArborist returns (bytes32 _root, uint256 _count) {\\n    // For > 1 leaf, considerably more efficient to put this tree into memory, conduct operations,\\n    // then re-assign it to storage - *especially* if we have multiple leaves to insert.\\n    MerkleLib.Tree memory _tree = tree;\\n\\n    uint256 leafCount = _leaves.length;\\n    for (uint256 i; i < leafCount; ) {\\n      // Insert the new node (using in-memory method).\\n      _tree = _tree.insert(_leaves[i]);\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n    // Write the newly updated tree to storage.\\n    tree = _tree;\\n\\n    // Get return details for convenience.\\n    _count = _tree.count;\\n    // NOTE: Root calculation method currently reads from storage only.\\n    _root = tree.root();\\n\\n    emit LeavesInserted(_root, _count, _leaves);\\n  }\\n\\n  /**\\n   * @notice Inserts the given leaf into the tree.\\n   * @param leaf The leaf to be inserted into the tree.\\n   * @return _root Current root for convenience.\\n   * @return _count Current node count (i.e. number of indices) AFTER the insertion of the new leaf,\\n   * provided for convenience.\\n   */\\n  function insert(bytes32 leaf) public onlyArborist returns (bytes32 _root, uint256 _count) {\\n    // Insert the new node.\\n    tree = tree.insert(leaf);\\n    _count = tree.count;\\n    _root = tree.root();\\n\\n    emit LeafInserted(_root, _count, leaf);\\n  }\\n\\n  // ============ Upgrade Gap ============\\n  uint256[46] private __GAP; // gap for upgrade safety\\n}\\n\",\"keccak256\":\"0x6c85e8e6df2192fd4d8099efbbb8b3ff40211b777174a99abe5e6d60f9529a3c\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/messaging/RootManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity 0.8.17;\\n\\nimport {Address} from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\nimport {ProposedOwnable} from \\\"../shared/ProposedOwnable.sol\\\";\\n\\nimport {IRootManager} from \\\"./interfaces/IRootManager.sol\\\";\\nimport {IHubConnector} from \\\"./interfaces/IHubConnector.sol\\\";\\nimport {QueueLib} from \\\"./libraries/Queue.sol\\\";\\nimport {DomainIndexer} from \\\"./libraries/DomainIndexer.sol\\\";\\nimport {SnapshotId} from \\\"./libraries/SnapshotId.sol\\\";\\n\\nimport {MerkleTreeManager} from \\\"./MerkleTreeManager.sol\\\";\\nimport {WatcherClient} from \\\"./WatcherClient.sol\\\";\\n\\nimport {IHubSpokeConnector} from \\\"./interfaces/IHubSpokeConnector.sol\\\";\\n\\n/**\\n * @notice This contract exists at cluster hubs, and aggregates all transfer roots from messaging\\n * spokes into a single merkle tree. Regularly broadcasts the root of the aggregator tree back out\\n * to all the messaging spokes.\\n */\\ncontract RootManager is ProposedOwnable, IRootManager, WatcherClient, DomainIndexer {\\n  // ============ Libraries ============\\n\\n  using QueueLib for QueueLib.Queue;\\n\\n  // ============ Events ============\\n\\n  event DelayBlocksUpdated(uint256 previous, uint256 updated);\\n\\n  event DisputeBlocksUpdated(uint256 previous, uint256 updated);\\n\\n  event MinDisputeBlocksUpdated(uint256 previous, uint256 updated);\\n\\n  event RootReceived(uint32 domain, bytes32 receivedRoot, uint256 queueIndex);\\n\\n  event RootDiscarded(bytes32 fraudulentRoot);\\n\\n  /**\\n   * @notice Emitted when a new proposer is added\\n   * @param proposer The address of the proposer\\n   */\\n  event ProposerAdded(address indexed proposer);\\n\\n  /**\\n   * @notice Emitted when a proposer is removed\\n   * @param proposer The address of the proposer\\n   */\\n  event ProposerRemoved(address indexed proposer);\\n\\n  event ConnectorAdded(uint32 domain, address connector, uint32[] domains, address[] connectors);\\n\\n  event ConnectorRemoved(uint32 domain, address connector, uint32[] domains, address[] connectors, address caller);\\n\\n  event PropagateFailed(uint32 domain, address connector);\\n\\n  /**\\n   * @notice Emitted when slow mode is activated\\n   * @param watcher The address of the watcher who called the function\\n   */\\n  event SlowModeActivated(address indexed watcher);\\n\\n  /**\\n   * @notice Emitted when optimistic mode is activated\\n   */\\n  event OptimisticModeActivated();\\n\\n  /**\\n   * @notice Emitted when a root is propagated\\n   * @dev It doesnt matter if the root was generated optimistically or on-chain.\\n   * @param aggregateRoot The aggregate root propagated\\n   * @param domainsHash The current domain hash\\n   */\\n  event AggregateRootPropagated(bytes32 indexed aggregateRoot, bytes32 domainsHash);\\n\\n  /**\\n   * @notice Emitted when a new aggregate root is proposed\\n   * @param snapshotId The snapshot id\\n   * @param endOfDispute The block at which the dispute period is over\\n   * @param aggregateRoot The new aggregate root proposed\\n   * @param baseRoot The root of the tree before the snapshot roots were inserted by proposer\\n   * @param snapshotsRoots The list of roots added to aggregate tree\\n   * @param domains The list of all domains\\n   */\\n  event AggregateRootProposed(\\n    uint256 indexed snapshotId,\\n    uint256 endOfDispute,\\n    bytes32 indexed aggregateRoot,\\n    bytes32 indexed baseRoot,\\n    bytes32[] snapshotsRoots,\\n    uint32[] domains\\n  );\\n\\n  /**\\n   * @notice Emitted when an aggregate root is added to the validAggregateRoots map during optimistic mode.\\n   * @param aggregateRoot The saved aggregate root\\n   * @param rootTimestamp The timestamp at which the aggregate root was saved.\\n   */\\n  event AggregateRootSavedOptimistic(bytes32 indexed aggregateRoot, uint256 rootTimestamp);\\n\\n  /**\\n   * @notice Emitted when an aggregate root is added to the validAggregateRoots map during slow mode.\\n   * @param aggregateRoot   The saved aggregate root\\n   * @param leafCount       The new number of leaves in the tree.\\n   * @param aggregatedRoots The verified inbound roots inserted in the tree.\\n   * @param rootTimestamp   The timestamp at which the aggregate root was saved.\\n   */\\n  event AggregateRootSavedSlow(\\n    bytes32 indexed aggregateRoot,\\n    uint256 leafCount,\\n    bytes32[] aggregatedRoots,\\n    uint256 rootTimestamp\\n  );\\n\\n  /**\\n   * @notice Emitted when a domain is set as the hub domain.\\n   * @param domain The domain set as hub domain.\\n   */\\n  event HubDomainSet(uint32 domain);\\n\\n  /**\\n   * @notice Emitted when the previously set hub domain is cleared.\\n   */\\n  event HubDomainCleared();\\n\\n  // ============ Errors ============\\n\\n  error RootManager_proposeAggregateRoot__InvalidSnapshotId(uint256 snapshotId);\\n\\n  error RootManager_checkDomains__InvalidDomains();\\n\\n  error RootManager_finalize__InvalidAggregateRoot();\\n\\n  error RootManager_onlyOptimisticMode__SlowModeOn();\\n\\n  error RootManager_activateOptimisticMode__OptimisticModeOn();\\n\\n  error RootManager_aggregate__OptimisticModeOn();\\n\\n  error RootManager_proposeAggregateRoot__ProposeInProgress();\\n\\n  error RootManager_finalize__ProposeInProgress();\\n\\n  error RootManager_onlyProposer__NotWhitelistedProposer(address caller);\\n\\n  error RootManager_sendRootToHub__NoMessageSent();\\n\\n  error RootManager_finalize__InvalidInputHash();\\n\\n  error RootManager_setMinDisputeBlocks__SameMinDisputeBlocksAsBefore();\\n\\n  error RootManager_setDisputeBlocks__SameDisputeBlocksAsBefore();\\n\\n  error RootManager_setDisputeBlocks__DisputeBlocksLowerThanMin();\\n\\n  error RootManager_constructor__DisputeBlocksLowerThanMin();\\n\\n  error RootManager__renounceOwnership_prohibited();\\n\\n  error RootManager_propagate__AggregateRootIsZero();\\n\\n  error RootManager_setHubDomain__InvalidDomain();\\n\\n  // ============ Properties ============\\n\\n  /**\\n   * @notice Maximum number of values to dequeue from the queue in one sitting (one call of `propagate`\\n   * or `dequeue`). Used to cap gas requirements.\\n   */\\n  uint128 public constant DEQUEUE_MAX = 100;\\n\\n  /**\\n   * @notice Root used to keep the slots of proposedAggregateRootHash warm.\\n   */\\n  bytes32 public constant FINALIZED_HASH = 0x0000000000000000000000000000000000000000000000000000000000000001;\\n  /**\\n   * @notice Number of blocks to delay the processing of a message to allow for watchers to verify\\n   * the validity and pause if necessary.\\n   */\\n  uint256 public delayBlocks;\\n\\n  /**\\n   * @notice The number of blocks watchers have to detect and invalidate the proposed root.\\n   */\\n  uint256 public disputeBlocks;\\n\\n  /**\\n   * @notice The minimum number of blocks disputeBlocks can be set to.\\n   */\\n  uint256 public minDisputeBlocks;\\n\\n  /**\\n   * @notice True if the system is working in optimistic mode. Otherwise is working in slow mode\\n   */\\n  bool public optimisticMode;\\n\\n  /**\\n   * @notice The last aggregate root we propagated to spoke chains (mapping keyed on domain). Used to prevent sending redundant\\n   * aggregate roots in `propagate`.\\n   */\\n  mapping(uint32 => bytes32) public lastPropagatedRoot;\\n\\n  /**\\n   * @notice Queue used for management of verification for inbound roots from spoke chains. Once\\n   * the verification period elapses, the inbound messages can be aggregated into the merkle tree\\n   * for propagation to spoke chains.\\n   * @dev Watchers should be able to watch this queue for fraudulent messages and pause this contract\\n   * if fraud is detected.\\n   */\\n  QueueLib.Queue public pendingInboundRoots;\\n\\n  /**\\n   * @notice The resulting hash of keccaking the proposed aggregate root and the block at which its dispute ends.\\n   * @dev    Set to 0x1 to prevent someone from calling finalize() the moment the contract is deployed\\n   */\\n  bytes32 public proposedAggregateRootHash = 0x0000000000000000000000000000000000000000000000000000000000000001;\\n\\n  /**\\n   * @notice MerkleTreeManager contract instance. Will hold the active tree of aggregated inbound roots.\\n   * The root of this tree will be distributed crosschain to all spoke domains.\\n   */\\n  MerkleTreeManager public immutable MERKLE;\\n\\n  /**\\n   * @notice This is used for the `onlyProposers` modifier, which gates who\\n   * can propose new roots using `proposeAggregateRoot`.\\n   */\\n  mapping(address => bool) public allowlistedProposers;\\n\\n  /**\\n   * @notice The list of valid aggregate roots for a given timestamp.\\n   * @dev Each time a new aggregate root is generated or\\n   * finalized, it will be added to this mapping using the block.timestamp as key.\\n   * @dev This is only used as Data-Availability for off-chain agents. Especially for the Watchers that fetch the\\n   * correct aggregate root from this contract in order to verify the data proposed on the Spoke Connectors.\\n   * @dev rootTimestamp => aggregateRoot\\n   */\\n  mapping(uint256 => bytes32) public validAggregateRoots;\\n\\n  /**\\n   * @notice Timestamp of the last aggregate root saved.\\n   * @dev Used to ensure that the propagate function will send the latest aggregate root available.\\n   */\\n  uint256 public lastSavedAggregateRootTimestamp;\\n\\n  /**\\n   * @notice Domain id of the current network\\n   */\\n  uint32 public hubDomain;\\n\\n  // ============ Modifiers ============\\n\\n  modifier onlyConnector(uint32 _domain) {\\n    require(getConnectorForDomain(_domain) == msg.sender, \\\"!connector\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @notice Checks if the proposed domains are valid\\n   */\\n  modifier checkDomains(uint32[] calldata _domains) {\\n    if (keccak256(abi.encode(_domains)) != domainsHash) revert RootManager_checkDomains__InvalidDomains();\\n    _;\\n  }\\n\\n  /**\\n   * @notice Checks if root manager is working in optimistic mode\\n   */\\n  modifier onlyOptimisticMode() {\\n    if (!optimisticMode) revert RootManager_onlyOptimisticMode__SlowModeOn();\\n    _;\\n  }\\n\\n  /**\\n   * @notice Checks if the proposer is in the allow list\\n   */\\n  modifier onlyProposer() {\\n    if (!allowlistedProposers[msg.sender]) revert RootManager_onlyProposer__NotWhitelistedProposer(msg.sender);\\n    _;\\n  }\\n\\n  // ============ Constructor ============\\n\\n  /**\\n   * @notice Creates a new RootManager instance.\\n   * @param _delayBlocks The delay for the validation period for incoming messages in blocks.\\n   * @param _merkle The address of the MerkleTreeManager on this domain.\\n   * @param _watcherManager The address of the WatcherManager on this domain.\\n   */\\n  constructor(\\n    uint256 _delayBlocks,\\n    address _merkle,\\n    address _watcherManager,\\n    uint256 _minDisputeBlocks,\\n    uint256 _disputeBlocks\\n  ) ProposedOwnable() WatcherClient(_watcherManager) {\\n    _setOwner(msg.sender);\\n    if (_disputeBlocks < _minDisputeBlocks) revert RootManager_constructor__DisputeBlocksLowerThanMin();\\n    require(_merkle != address(0), \\\"!zero merkle\\\");\\n    MERKLE = MerkleTreeManager(_merkle);\\n\\n    delayBlocks = _delayBlocks;\\n    minDisputeBlocks = _minDisputeBlocks;\\n    disputeBlocks = _disputeBlocks;\\n\\n    // Initialize pending inbound root queue.\\n    pendingInboundRoots.initialize();\\n  }\\n\\n  // ================ Getters ================\\n\\n  function getPendingInboundRootsCount() public view returns (uint256) {\\n    return pendingInboundRoots.length();\\n  }\\n\\n  /**\\n   * @notice Get the duration of the snapshot\\n   *\\n   * @return _snapshotDuration The duration of the snapshot\\n   */\\n  function getSnapshotDuration() external pure returns (uint256 _snapshotDuration) {\\n    _snapshotDuration = SnapshotId.SNAPSHOT_DURATION;\\n  }\\n\\n  // ============ Admin Functions ============\\n\\n  /**\\n   * @notice Adds a proposer to the allowlist.\\n   * @dev Only allowlisted proposers can call `proposeAggregateRoot`.\\n   */\\n  function addProposer(address _proposer) external onlyOwner {\\n    allowlistedProposers[_proposer] = true;\\n    emit ProposerAdded(_proposer);\\n  }\\n\\n  /**\\n   * @notice Removes a proposer from the allowlist.\\n   * @dev Only allowlisted proposers can call `proposeAggregateRoot`.\\n   */\\n  function removeProposer(address _proposer) external onlyOwner {\\n    delete allowlistedProposers[_proposer];\\n    emit ProposerRemoved(_proposer);\\n  }\\n\\n  /**\\n   * @notice Set the `minDisputeBlocks` variable to the provided parameter.\\n   */\\n  function setMinDisputeBlocks(uint256 _minDisputeBlocks) external onlyOwner {\\n    if (_minDisputeBlocks == minDisputeBlocks) revert RootManager_setMinDisputeBlocks__SameMinDisputeBlocksAsBefore();\\n    emit MinDisputeBlocksUpdated(minDisputeBlocks, _minDisputeBlocks);\\n    minDisputeBlocks = _minDisputeBlocks;\\n  }\\n\\n  /**\\n   * @notice Set the `disputeBlocks`, the duration, in blocks, of the dispute process for\\n   * a given proposed root\\n   */\\n  function setDisputeBlocks(uint256 _disputeBlocks) external onlyOwner {\\n    if (_disputeBlocks < minDisputeBlocks) revert RootManager_setDisputeBlocks__DisputeBlocksLowerThanMin();\\n    if (_disputeBlocks == disputeBlocks) revert RootManager_setDisputeBlocks__SameDisputeBlocksAsBefore();\\n    emit DisputeBlocksUpdated(disputeBlocks, _disputeBlocks);\\n    disputeBlocks = _disputeBlocks;\\n  }\\n\\n  /**\\n   * @notice Set the `delayBlocks`, the period in blocks over which an incoming message\\n   * is verified.\\n   */\\n  function setDelayBlocks(uint256 _delayBlocks) external onlyOwner {\\n    require(_delayBlocks != delayBlocks, \\\"!delayBlocks\\\");\\n    emit DelayBlocksUpdated(delayBlocks, _delayBlocks);\\n    delayBlocks = _delayBlocks;\\n  }\\n\\n  /**\\n   * @notice Add a new supported domain and corresponding hub connector to the system. This new domain\\n   * will receive the propagated aggregate root.\\n   * @dev Only owner can add a new connector. Address should be the connector on L1.\\n   * @dev Cannot add address(0) to avoid duplicated domain in array and reduce gas fee while propagating.\\n   *\\n   * @param _domain The target spoke domain of the given connector.\\n   * @param _connector Address of the hub connector.\\n   */\\n  function addConnector(uint32 _domain, address _connector) external onlyOwner {\\n    addDomain(_domain, _connector);\\n    emit ConnectorAdded(_domain, _connector, domains, connectors);\\n  }\\n\\n  /**\\n   * @notice Remove support for a connector and respective domain. That connector/domain will no longer\\n   * receive updates for the latest aggregate root.\\n   * @dev Only watcher can remove a connector.\\n   * @dev The proposedAggregateRootHash will be set to the FINALIZED_HASH.\\n   * TODO: Could add a metatx-able `removeConnectorWithSig` if we want to use relayers?\\n   *\\n   * @param _domain The spoke domain of the target connector we want to remove.\\n   */\\n  function removeConnector(uint32 _domain) external onlyWatcher {\\n    address _connector = removeDomain(_domain);\\n    proposedAggregateRootHash = FINALIZED_HASH;\\n    emit ConnectorRemoved(_domain, _connector, domains, connectors, msg.sender);\\n  }\\n\\n  /**\\n   * @notice Removes (effectively blocklists) a given (fraudulent) root from the queue of pending\\n   * inbound roots.\\n   * @dev The given root does NOT have to currently be in the queue. It isn't removed from the queue\\n   * directly, but instead is filtered out when dequeuing is done for the sake of aggregation.\\n   * @dev Can only be called by the owner when the protocol is paused.\\n   *\\n   * @param _root The root to be discarded.\\n   */\\n  function discardRoot(bytes32 _root) external onlyOwner whenPaused {\\n    pendingInboundRoots.remove(_root);\\n    emit RootDiscarded(_root);\\n  }\\n\\n  /**\\n   * @notice Remove ability to renounce ownership\\n   * @dev Renounce ownership should be impossible as long as watchers can freely remove connectors\\n   * and only the owner can add them back\\n   */\\n  function renounceOwnership() public virtual override(ProposedOwnable, WatcherClient) onlyOwner {\\n    revert RootManager__renounceOwnership_prohibited();\\n  }\\n\\n  /**\\n   * @notice Sets domain corresponding to the hub domain.\\n   *\\n   * @param _domain The domain to be set as hub domain.\\n   */\\n  function setHubDomain(uint32 _domain) external onlyOwner {\\n    if (!isDomainSupported(_domain)) revert RootManager_setHubDomain__InvalidDomain();\\n    hubDomain = _domain;\\n    emit HubDomainSet(_domain);\\n  }\\n\\n  /**\\n   * @notice Removes the domain associated with the hub domain.\\n   */\\n  function clearHubDomain() external onlyOwner {\\n    delete hubDomain;\\n    emit HubDomainCleared();\\n  }\\n\\n  // ============ Public Functions ============\\n\\n  /**\\n   * @notice Propose a new aggregate root\\n   * @dev snapshotId, snapshotRoots and domains are needed for validation and data availability for off-chain agents.\\n   * In the case of domains we need to check which are the current valid domains at the time of proposing.\\n   * This is gonna be used by the off-chain scripts to know which domains to check when validating each proposition.\\n   * This is to avoid problems if a new domain is added in the middle of an on-going propose.\\n   * Domains should be in the same order as they are in this contract.\\n   * Snapshot roots provided should be in order of insertion and should respect the domains order.\\n   *\\n   * @param _snapshotId The snapshot id used\\n   * @param _aggregateRoot The new aggregate root\\n   * @param _snapshotsRoots Array of snapshot roots inserted\\n   * @param _domains Array of all the domains\\n   */\\n  function proposeAggregateRoot(\\n    uint256 _snapshotId,\\n    bytes32 _aggregateRoot,\\n    bytes32[] calldata _snapshotsRoots,\\n    uint32[] calldata _domains\\n  ) external onlyProposer onlyOptimisticMode checkDomains(_domains) whenNotPaused {\\n    if (_snapshotId != SnapshotId.getLastCompletedSnapshotId())\\n      revert RootManager_proposeAggregateRoot__InvalidSnapshotId(_snapshotId);\\n    if (proposedAggregateRootHash != FINALIZED_HASH) revert RootManager_proposeAggregateRoot__ProposeInProgress();\\n\\n    uint256 _endOfDispute = block.number + disputeBlocks;\\n    proposedAggregateRootHash = keccak256(abi.encode(_aggregateRoot, _endOfDispute));\\n\\n    emit AggregateRootProposed(_snapshotId, _endOfDispute, _aggregateRoot, MERKLE.root(), _snapshotsRoots, _domains);\\n  }\\n\\n  /**\\n   * @notice Finalizes the proposed aggregate root. This makes the current proposed root the new validated and\\n   * ready to propagate root.\\n   * @dev The system has to be in optimistic mode and propose's dispute time over.\\n   * Finalized root will stop being monitored by off-chain agents.\\n   *\\n   * @param _proposedAggregateRoot The aggregate root currently proposed\\n   * @param _endOfDispute          The block in which the dispute period for proposedAggregateRootHash finalizes\\n   */\\n  function finalize(bytes32 _proposedAggregateRoot, uint256 _endOfDispute) public onlyOptimisticMode whenNotPaused {\\n    bytes32 _proposedAggregateRootHash = proposedAggregateRootHash;\\n    if (_proposedAggregateRootHash == FINALIZED_HASH) revert RootManager_finalize__InvalidAggregateRoot();\\n    bytes32 _userInputHash = keccak256(abi.encode(_proposedAggregateRoot, _endOfDispute));\\n    if (_userInputHash != _proposedAggregateRootHash) revert RootManager_finalize__InvalidInputHash();\\n    if (_endOfDispute > block.number) revert RootManager_finalize__ProposeInProgress();\\n\\n    // Save data\\n    validAggregateRoots[block.timestamp] = _proposedAggregateRoot;\\n    lastSavedAggregateRootTimestamp = block.timestamp;\\n\\n    // Clear the propose slot\\n    proposedAggregateRootHash = FINALIZED_HASH;\\n\\n    emit AggregateRootSavedOptimistic(_proposedAggregateRoot, block.timestamp);\\n  }\\n\\n  /**\\n   * @notice Unifies the flow of finalize and propagate.\\n   * @dev Should be called by relayers only when proposed root is ready to be finalized.\\n   *\\n   * @param _connectors Array of connectors: should match exactly the array of `connectors` in storage;\\n   * used here to reduce gas costs, and keep them static regardless of number of supported domains.\\n   * @param _fees Array of fees in native token for an AMB if required\\n   * @param _encodedData Array of encodedData: extra params for each AMB if required\\n   * @param _proposedAggregateRoot The aggregate root currently proposed\\n   * @param _endOfDispute          The block in which the dispute period for proposedAggregateRootHash finalizes\\n   */\\n  function finalizeAndPropagate(\\n    address[] calldata _connectors,\\n    uint256[] calldata _fees,\\n    bytes[] memory _encodedData,\\n    bytes32 _proposedAggregateRoot,\\n    uint256 _endOfDispute\\n  ) external payable {\\n    finalize(_proposedAggregateRoot, _endOfDispute);\\n    propagate(_connectors, _fees, _encodedData);\\n  }\\n\\n  /**\\n   * @notice This is called by relayers to take the current aggregate tree root and propagate it to all\\n   * spoke domains (via their respective hub connectors).\\n   * @dev Should be called by relayers at a regular interval.\\n   * Workflow is slightly different depending on the mode the system is in.\\n   *\\n   * @param _connectors Array of connectors: should match exactly the array of `connectors` in storage;\\n   * used here to reduce gas costs, and keep them static regardless of number of supported domains.\\n   * @param _fees Array of fees in native token for an AMB if required\\n   * @param _encodedData Array of encodedData: extra params for each AMB if required\\n   */\\n  function propagate(\\n    address[] calldata _connectors,\\n    uint256[] calldata _fees,\\n    bytes[] memory _encodedData\\n  ) public payable whenNotPaused {\\n    validateConnectors(_connectors);\\n\\n    uint256 _numDomains = _connectors.length;\\n    // Sanity check: fees and encodedData lengths matches connectors length.\\n    require(_fees.length == _numDomains && _encodedData.length == _numDomains, \\\"invalid lengths\\\");\\n\\n    // If in slow mode, we dequeue to ensure that we add the inboundRoots that are ready.\\n    if (!optimisticMode) dequeue();\\n\\n    bytes32 _aggregateRoot = validAggregateRoots[lastSavedAggregateRootTimestamp];\\n\\n    if (_aggregateRoot == 0) revert RootManager_propagate__AggregateRootIsZero();\\n\\n    emit AggregateRootPropagated(_aggregateRoot, domainsHash);\\n\\n    _sendRootToHubs(_aggregateRoot, _connectors, _fees, _encodedData);\\n  }\\n\\n  /**\\n   * @notice Send an aggregate root to every connector.\\n   * @dev CRITICAL: This function does NOT check if _connectors sent to it are correct or not and can always be called internally.\\n   * All the needed checks must be done before calling this function.\\n   *\\n   * @param _aggregateRoot The aggregate root that needs to be sent to every connector.\\n   * @param _connectors Array of connectors: should match exactly the array of `connectors` in storage;\\n   * used here to reduce gas costs, and keep them static regardless of number of supported domains.\\n   * @param _fees Array of fees in native token for an AMB if required\\n   * @param _encodedData Array of encodedData: extra params for each AMB if required\\n   */\\n  function _sendRootToHubs(\\n    bytes32 _aggregateRoot,\\n    address[] calldata _connectors,\\n    uint256[] calldata _fees,\\n    bytes[] memory _encodedData\\n  ) internal {\\n    uint256 refund = msg.value;\\n    bool sent;\\n    for (uint32 i; i < _connectors.length; ) {\\n      // Sanity check: skip propagating a redundant aggregate root.\\n      bytes32 previous = lastPropagatedRoot[domains[i]];\\n      if (previous == _aggregateRoot) {\\n        unchecked {\\n          ++i;\\n        }\\n        continue;\\n      }\\n\\n      // Try to send the message with appropriate encoded data and fees\\n      // Continue on revert, but emit an event\\n      try\\n        IHubConnector(_connectors[i]).sendMessage{value: _fees[i]}(abi.encodePacked(_aggregateRoot), _encodedData[i])\\n      {\\n        // NOTE: This will ensure there is sufficient msg.value for all fees before calling `sendMessage`\\n        // This will revert as soon as there are insufficient fees for call i, even if call n > i has\\n        // sufficient budget, this function will revert\\n        refund -= _fees[i];\\n        // mark that the message was sent\\n        sent = true;\\n        // Set the last propagated root\\n        lastPropagatedRoot[domains[i]] = _aggregateRoot;\\n      } catch {\\n        emit PropagateFailed(domains[i], _connectors[i]);\\n      }\\n\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n\\n    // Ensure *a* message was sent to prevent excess relayer spend\\n    if (!sent) {\\n      revert RootManager_sendRootToHub__NoMessageSent();\\n    }\\n\\n    // Refund caller\\n    if (refund > 0) {\\n      Address.sendValue(payable(msg.sender), refund);\\n    }\\n  }\\n\\n  /**\\n   * @notice Sends the latest valid aggregate root to the hub domain's spoke connector.\\n   * @dev This has no guards as the guards should be in the spoke connector. For example, the spoke connector should\\n   *      guard against receiving the root through this function if the spoke connector is not in optimistic mode.\\n   */\\n  function sendRootToHubSpoke() external whenNotPaused {\\n    bytes32 _aggregateRoot = validAggregateRoots[lastSavedAggregateRootTimestamp];\\n    IHubSpokeConnector(getConnectorForDomain(hubDomain)).saveAggregateRoot(_aggregateRoot);\\n  }\\n\\n  /**\\n   * @notice Accept an inbound root coming from a given domain's hub connector, enqueuing this incoming\\n   * root into the current queue as it awaits the verification period.\\n   * @dev The aggregate tree's root, which will include this inbound root, will be propagated to all spoke\\n   * domains (via `propagate`) on a regular basis assuming the verification period is surpassed without\\n   * dispute.\\n   *\\n   * @param _domain The source domain of the given root.\\n   * @param _inbound The inbound root coming from the given domain.\\n   */\\n  function aggregate(uint32 _domain, bytes32 _inbound) external whenNotPaused onlyConnector(_domain) {\\n    if (optimisticMode) revert RootManager_aggregate__OptimisticModeOn();\\n    uint128 lastIndex = pendingInboundRoots.enqueue(_inbound);\\n    emit RootReceived(_domain, _inbound, lastIndex);\\n  }\\n\\n  /**\\n   * @notice Dequeue verified inbound roots and insert them into the aggregator tree.\\n   * @dev Will dequeue a fixed maximum amount of roots to prevent out of gas errors. As such, this\\n   * method is public and separate from `propagate` so we can curtail an overloaded queue as needed.\\n   *\\n   * @return bytes32 The new aggregate root.\\n   * @return uint256 The updated count (number of leaves).\\n   */\\n  function dequeue() public whenNotPaused returns (bytes32, uint256) {\\n    // Get all of the verified roots from the queue.\\n    bytes32[] memory _verifiedInboundRoots = pendingInboundRoots.dequeueVerified(delayBlocks, DEQUEUE_MAX);\\n\\n    // If there's nothing dequeued, just return the root and count.\\n    if (_verifiedInboundRoots.length == 0) {\\n      return MERKLE.rootAndCount();\\n    }\\n\\n    // Insert the leaves into the aggregator tree (method will also calculate and return the current\\n    // aggregate root and count).\\n    (bytes32 _aggregateRoot, uint256 _count) = MERKLE.insert(_verifiedInboundRoots);\\n\\n    validAggregateRoots[block.timestamp] = _aggregateRoot;\\n    lastSavedAggregateRootTimestamp = block.timestamp;\\n\\n    emit AggregateRootSavedSlow(_aggregateRoot, _count, _verifiedInboundRoots, block.timestamp);\\n\\n    return (_aggregateRoot, _count);\\n  }\\n\\n  /**\\n   * @notice Watcher can set the system in slow mode.\\n   * @dev Sets the proposed aggregate root hash to FINALIZED_HASH, invalidating it.\\n   */\\n  function activateSlowMode() external onlyWatcher onlyOptimisticMode {\\n    optimisticMode = false;\\n\\n    proposedAggregateRootHash = FINALIZED_HASH;\\n    emit SlowModeActivated(msg.sender);\\n  }\\n\\n  /**\\n   * @notice Owner can set the system to optimistic mode.\\n   * @dev Elements in the queue will be discarded.\\n   * To save gas we are not deleting the elements from the queue, but moving the last counter to first - 1\\n   * so we can reassign new elements to those positions in the future.\\n   * Discarded roots will be included on the upcoming optimistic aggregateRoot.\\n   */\\n  function activateOptimisticMode() external onlyOwner {\\n    if (optimisticMode) revert RootManager_activateOptimisticMode__OptimisticModeOn();\\n\\n    pendingInboundRoots.last = pendingInboundRoots.first - 1;\\n\\n    optimisticMode = true;\\n    emit OptimisticModeActivated();\\n  }\\n}\\n\",\"keccak256\":\"0x3d000caf540675efcfac2d3c3701597e5a6731218f9f3b19c58b29cc4811566f\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/messaging/WatcherClient.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity 0.8.17;\\n\\nimport {Pausable} from \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\n\\nimport {ProposedOwnable} from \\\"../shared/ProposedOwnable.sol\\\";\\nimport {WatcherManager} from \\\"./WatcherManager.sol\\\";\\n\\n/**\\n * @notice This contract abstracts the functionality of the watcher manager.\\n * Contracts can inherit this contract to be able to use the watcher manager's shared watcher set.\\n */\\n\\ncontract WatcherClient is ProposedOwnable, Pausable {\\n  // ============ Events ============\\n  /**\\n   * @notice Emitted when the manager address changes\\n   * @param watcherManager The updated manager\\n   */\\n  event WatcherManagerChanged(address watcherManager);\\n\\n  // ============ Properties ============\\n  /**\\n   * @notice The `WatcherManager` contract governs the watcher allowlist.\\n   * @dev Multiple clients can share a watcher set using the same manager\\n   */\\n  WatcherManager public watcherManager;\\n\\n  // ============ Constructor ============\\n  constructor(address _watcherManager) ProposedOwnable() {\\n    watcherManager = WatcherManager(_watcherManager);\\n  }\\n\\n  // ============ Modifiers ============\\n  /**\\n   * @notice Enforces the sender is the watcher\\n   */\\n  modifier onlyWatcher() {\\n    require(watcherManager.isWatcher(msg.sender), \\\"!watcher\\\");\\n    _;\\n  }\\n\\n  // ============ Admin fns ============\\n  /**\\n   * @notice Owner can enroll a watcher (abilities are defined by inheriting contracts)\\n   */\\n  function setWatcherManager(address _watcherManager) external onlyOwner {\\n    require(_watcherManager != address(watcherManager), \\\"already watcher manager\\\");\\n    watcherManager = WatcherManager(_watcherManager);\\n    emit WatcherManagerChanged(_watcherManager);\\n  }\\n\\n  /**\\n   * @notice Owner can unpause contracts if fraud is detected by watchers\\n   */\\n  function unpause() external onlyOwner whenPaused {\\n    _unpause();\\n  }\\n\\n  /**\\n   * @notice Remove ability to renounce ownership\\n   * @dev Renounce ownership should be impossible as long as only the owner\\n   * is able to unpause the contracts. You can still propose `address(0)`,\\n   * but it will never be accepted.\\n   */\\n  function renounceOwnership() public virtual override onlyOwner {\\n    require(false, \\\"prohibited\\\");\\n  }\\n\\n  // ============ Watcher fns ============\\n\\n  /**\\n   * @notice Watchers can pause contracts if fraud is detected\\n   */\\n  function pause() external onlyWatcher whenNotPaused {\\n    _pause();\\n  }\\n}\\n\",\"keccak256\":\"0xe9c9a71695f8c4b93d5d59b719f162c805cd85879aad5f4175b6fa7a3236df95\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/messaging/WatcherManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity 0.8.17;\\n\\nimport {ProposedOwnable} from \\\"../shared/ProposedOwnable.sol\\\";\\n\\n/**\\n * @notice This contract manages a set of watchers. This is meant to be used as a shared resource that contracts can\\n * inherit to make use of the same watcher set.\\n */\\n\\ncontract WatcherManager is ProposedOwnable {\\n  // ============ Events ============\\n  event WatcherAdded(address watcher);\\n\\n  event WatcherRemoved(address watcher);\\n\\n  // ============ Properties ============\\n  mapping(address => bool) public isWatcher;\\n\\n  // ============ Constructor ============\\n  constructor() ProposedOwnable() {\\n    _setOwner(msg.sender);\\n  }\\n\\n  // ============ Modifiers ============\\n\\n  // ============ Admin fns ============\\n  /**\\n   * @dev Owner can enroll a watcher (abilities are defined by inheriting contracts)\\n   */\\n  function addWatcher(address _watcher) external onlyOwner {\\n    require(!isWatcher[_watcher], \\\"already watcher\\\");\\n    isWatcher[_watcher] = true;\\n    emit WatcherAdded(_watcher);\\n  }\\n\\n  /**\\n   * @dev Owner can unenroll a watcher (abilities are defined by inheriting contracts)\\n   */\\n  function removeWatcher(address _watcher) external onlyOwner {\\n    require(isWatcher[_watcher], \\\"!exist\\\");\\n    delete isWatcher[_watcher];\\n    emit WatcherRemoved(_watcher);\\n  }\\n\\n  /**\\n   * @notice Remove ability to renounce ownership\\n   * @dev Renounce ownership should be impossible as long as the watcher griefing\\n   * vector exists. You can still propose `address(0)`, but it will never be accepted.\\n   */\\n  function renounceOwnership() public virtual override onlyOwner {\\n    require(false, \\\"prohibited\\\");\\n  }\\n}\\n\",\"keccak256\":\"0x31457ca4d8f4f3270d6cc85e049f2ebf134bd094c995ad0856892d23dd8cdf84\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/messaging/interfaces/IConnector.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity 0.8.17;\\n\\nimport {IProposedOwnable} from \\\"../../shared/interfaces/IProposedOwnable.sol\\\";\\n\\n/**\\n * @notice This interface is what the Connext contract will send and receive messages through.\\n * The messaging layer should conform to this interface, and should be interchangeable (i.e.\\n * could be Nomad or a generic AMB under the hood).\\n *\\n * @dev This uses the nomad format to ensure nomad can be added in as it comes back online.\\n *\\n * Flow from transfer from polygon to optimism:\\n * 1. User calls `xcall` with destination specified\\n * 2. This will swap in to the bridge assets\\n * 3. The swapped assets will get burned\\n * 4. The Connext contract will call `dispatch` on the messaging contract to add the transfer\\n *    to the root\\n * 5. [At some time interval] Relayers call `send` to send the current root from polygon to\\n *    mainnet. This is done on all \\\"spoke\\\" domains.\\n * 6. [At some time interval] Relayers call `propagate` [better name] on mainnet, this generates a new merkle\\n *    root from all of the AMBs\\n *    - This function must be able to read root data from all AMBs and aggregate them into a single merkle\\n *      tree root\\n *    - Will send the mixed root from all chains back through the respective AMBs to all other chains\\n * 7. AMB will call `update` to update the latest root on the messaging contract on spoke domains\\n * 8. [At any point] Relayers can call `proveAndProcess` to prove inclusion of dispatched message, and call\\n *    process on the `Connext` contract\\n * 9. Takes minted bridge tokens and credits the LP\\n *\\n * AMB requirements:\\n * - Access `msg.sender` both from mainnet -> spoke and vice versa\\n * - Ability to read *our root* from the AMB\\n *\\n * AMBs:\\n * - PoS bridge from polygon\\n * - arbitrum bridge\\n * - optimism bridge\\n * - gnosis chain\\n * - bsc (use multichain for messaging)\\n */\\ninterface IConnector is IProposedOwnable {\\n  // ============ Events ============\\n  /**\\n   * @notice Emitted whenever a message is successfully sent over an AMB\\n   * @param data The contents of the message\\n   * @param encodedData Data used to send the message; specific to connector\\n   * @param caller Who called the function (sent the message)\\n   */\\n  event MessageSent(bytes data, bytes encodedData, address caller);\\n\\n  /**\\n   * @notice Emitted whenever a message is successfully received over an AMB\\n   * @param data The contents of the message\\n   * @param caller Who called the function\\n   */\\n  event MessageProcessed(bytes data, address caller);\\n\\n  // ============ Public fns ============\\n\\n  function processMessage(bytes memory _data) external;\\n\\n  function verifySender(address _expected) external returns (bool);\\n}\\n\",\"keccak256\":\"0xfba166354b442fa72b05be07aed38400b47f68498e8dfdd94fc43df00c401ed1\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/messaging/interfaces/IHubConnector.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity 0.8.17;\\n\\nimport {IConnector} from \\\"./IConnector.sol\\\";\\n\\ninterface IHubConnector is IConnector {\\n  function sendMessage(bytes memory _data, bytes memory _encodedData) external payable;\\n}\\n\",\"keccak256\":\"0x9c3b0b9f1ab326d6283e404818b8c2c55c4fc1ee9919830a1d04ebc3f4a022cd\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/messaging/interfaces/IHubSpokeConnector.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity 0.8.17;\\n\\ninterface IHubSpokeConnector {\\n  function saveAggregateRoot(bytes32 _aggregateRoot) external;\\n}\\n\",\"keccak256\":\"0x69e0679df0f54055b9f18a4b4eea042101628648a4acd269fe732cc289697869\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/messaging/interfaces/IRootManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity 0.8.17;\\n\\ninterface IRootManager {\\n  /**\\n   * @notice This is called by relayers to generate + send the mixed root from mainnet via AMB to\\n   * spoke domains.\\n   * @dev This must read information for the root from the registered AMBs.\\n   */\\n  function propagate(\\n    address[] calldata _connectors,\\n    uint256[] calldata _fees,\\n    bytes[] memory _encodedData\\n  ) external payable;\\n\\n  /**\\n   * @notice Called by the connectors for various domains on the hub to aggregate their latest\\n   * inbound root.\\n   * @dev This must read information for the root from the registered AMBs\\n   */\\n  function aggregate(uint32 _domain, bytes32 _outbound) external;\\n}\\n\",\"keccak256\":\"0xa895dfaa4baad37a636e7e7e7da72a0a4badfd2d3d8256f975e5101cd5a98236\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/messaging/libraries/DomainIndexer.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity 0.8.17;\\n\\n/**\\n * @notice This abstract contract was written to ensure domain and connector mutex is scalable for the\\n * purposes of messaging layer operations. In particular, it aims to reduce gas costs to be relatively\\n * static regardless of the number of domains kept in storage by enabling callers of `RootManager.propagate`\\n * to supply the `domains` and `connectors` arrays as params, and check the hashes of those params against\\n * those we keep in storage.\\n */\\nabstract contract DomainIndexer {\\n  // ============ Events ============\\n\\n  event DomainAdded(uint32 domain, address connector);\\n  event DomainRemoved(uint32 domain);\\n\\n  // ============ Properties ============\\n\\n  /**\\n   * @notice The absolute maximum number of domains that we should support. Domain and connector arrays\\n   * are naturally unbounded, but the gas cost of reading these arrays in `updateHashes()` is bounded by\\n   * the block's gas limit.\\n   *\\n   * If we want to set a hard ceiling for gas costs for the `updateHashes()` method at approx. 500K gas,\\n   * with an average SLOAD cost of 900 gas per domain (1 uint32, 1 address):\\n   *       500K / 900 = ~555 domains\\n   *\\n   * Realistically, the cap on the number of domains will likely exist in other places, but we cap it\\n   * here as a last resort.\\n   */\\n  uint256 public constant MAX_DOMAINS = 500;\\n\\n  /**\\n   * @notice Domains array tracks currently subscribed domains to this hub aggregator.\\n   * We should distribute the aggregate root to all of these domains in the `propagate` method.\\n   * @dev Whenever this domains array is updated, the connectors array should also be updated.\\n   */\\n  uint32[] public domains;\\n\\n  /**\\n   * @notice A \\\"quick reference\\\" hash used in the `propagate` method below to validate that the provided\\n   * array of domains matches the one we have in storage.\\n   * @dev This hash should be re-calculated whenever the domains array is updated.\\n   */\\n  bytes32 public domainsHash;\\n\\n  /**\\n   * @notice Tracks the addresses of the hub connector contracts corresponding to subscribed spoke domains.\\n   * The index of any given connector in this array should match the index of that connector's target spoke\\n   * domain in the `domains` array above.\\n   * @dev This should be updated whenever the domains array is updated.\\n   */\\n  address[] public connectors;\\n\\n  /**\\n   * @notice A \\\"quick reference\\\" hash used in the `propagate` method below to validate that the provided\\n   * array of connectors matches the one we have in storage.\\n   * @dev This hash should be re-calculated whenever the connectors array is updated.\\n   */\\n  bytes32 public connectorsHash;\\n\\n  /**\\n   * @notice Shortcut to reverse lookup the index by domain. We index starting at one so the zero value can\\n   * be considered invalid (see fn: `isDomainSupported`).\\n   * @dev This should be updated whenever the domains array is updated.\\n   */\\n  mapping(uint32 => uint256) private domainToIndexPlusOne;\\n\\n  // ============ Getters ============\\n\\n  /**\\n   * @notice Convenience shortcut for supported domains. Used to sanity check adding new domains.\\n   * @param _domain Domain to check.\\n   */\\n  function isDomainSupported(uint32 _domain) public view returns (bool) {\\n    return domainToIndexPlusOne[_domain] != 0;\\n  }\\n\\n  /**\\n   * @notice Gets the index of a given domain in the domains and connectors arrays.\\n   * @dev Reverts if domain is not supported.\\n   * @param _domain The domain for which to get the index value.\\n   */\\n  function getDomainIndex(uint32 _domain) public view returns (uint256) {\\n    uint256 index = domainToIndexPlusOne[_domain];\\n    require(index != 0, \\\"!supported\\\");\\n    return index - 1;\\n  }\\n\\n  /**\\n   * @notice Gets the corresponding hub connector address for a given spoke domain.\\n   * @dev Inefficient, should only be used by caller if they have no index reference.\\n   * @param _domain The domain for which to get the hub connector address.\\n   */\\n  function getConnectorForDomain(uint32 _domain) public view returns (address) {\\n    return connectors[getDomainIndex(_domain)];\\n  }\\n\\n  /**\\n   * @notice Validate given domains and connectors arrays are correct (i.e. they mirror what is\\n   * currently saved in storage).\\n   * @dev Reverts if domains or connectors do not match, including ordering.\\n   * @param _domains The given domains array to check.\\n   * @param _connectors The given connectors array to check.\\n   */\\n  function validateDomains(uint32[] calldata _domains, address[] calldata _connectors) public view {\\n    // Sanity check: arguments are same length.\\n    require(_domains.length == _connectors.length, \\\"!matching length\\\");\\n    // Validate that given domains match the current array in storage.\\n    require(keccak256(abi.encode(_domains)) == domainsHash, \\\"!domains\\\");\\n    // Validate that given connectors match the current array in storage.\\n    require(keccak256(abi.encode(_connectors)) == connectorsHash, \\\"!connectors\\\");\\n  }\\n\\n  /**\\n   * @notice Validate given connectors array is correct (i.e. it mirrors what is\\n   * currently saved in storage).\\n   * @dev Reverts if domains or connectors do not match, including ordering.\\n   * @param _connectors The given connectors array to check.\\n   */\\n  function validateConnectors(address[] calldata _connectors) public view {\\n    // Validate that given connectors match the current array in storage.\\n    require(keccak256(abi.encode(_connectors)) == connectorsHash, \\\"!connectors\\\");\\n  }\\n\\n  // ============ Helper Functions ============\\n\\n  /**\\n   * @notice Handles all mutex for adding support for a given domain.\\n   * @param _domain Domain for which we are adding support.\\n   * @param _connector Corresponding hub connector address belonging to given domain.\\n   */\\n  function addDomain(uint32 _domain, address _connector) internal {\\n    // Sanity check: domain does not already exist.\\n    require(!isDomainSupported(_domain), \\\"domain exists\\\");\\n    // Sanity check: connector is reasonable.\\n    require(_connector != address(0), \\\"!connector\\\");\\n    // Sanity check: Under maximum.\\n    require(domains.length < MAX_DOMAINS, \\\"DomainIndexer at capacity\\\");\\n\\n    // Push domain and connector to respective arrays.\\n    domains.push(_domain);\\n    connectors.push(_connector);\\n    // Set reverse lookup.\\n    uint256 _indexPlusOne = domains.length;\\n    domainToIndexPlusOne[_domain] = _indexPlusOne;\\n\\n    // Update the hashes for the given arrays.\\n    updateHashes();\\n\\n    emit DomainAdded(_domain, _connector);\\n  }\\n\\n  /**\\n   * @notice Handles all mutex for removing support for a given domain.\\n   * @param _domain Domain we are removing.\\n   * @return address of the hub connector for the domain we removed.\\n   */\\n  function removeDomain(uint32 _domain) internal returns (address) {\\n    uint256 _index = getDomainIndex(_domain);\\n    // Get the connector at the given index.\\n    address _connector = connectors[_index];\\n    // Sanity check: connector exists.\\n    require(_connector != address(0), \\\"connector !exists\\\");\\n\\n    // Shortcut: is the index the last index in the domains/connectors arrays?\\n    // IFF not, we'll need to swap the target with the current last so we can pop().\\n    uint256 _lastIndex = domains.length - 1;\\n    if (_index < _lastIndex) {\\n      // If the target index for removal is not the last index, we copy over the domain at the last\\n      // index to overwrite the target's index so we can conveniently pop the last item.\\n      uint32 copiedDomain = domains[_lastIndex];\\n      domains[_index] = copiedDomain;\\n      connectors[_index] = connectors[_lastIndex];\\n      // Update the domain to index mapping for the copied domain.\\n      domainToIndexPlusOne[copiedDomain] = _index + 1; // NOTE: Naturally adding 1 here; see mapping name.\\n    }\\n\\n    // Pop the last item in the arrays.\\n    domains.pop();\\n    connectors.pop();\\n    // Erase reverse lookup.\\n    delete domainToIndexPlusOne[_domain];\\n\\n    // Update the hashes for the given arrays.\\n    updateHashes();\\n\\n    emit DomainRemoved(_domain);\\n\\n    return _connector;\\n  }\\n\\n  /**\\n   * @notice Calculate the new hashes for the domains and connectors arrays and update storage refs.\\n   * @dev Used for the Connector update functions `addConnector`, `removeConnector`.\\n   */\\n  function updateHashes() internal {\\n    uint32[] memory _domains = domains;\\n    address[] memory _connectors = connectors;\\n    domainsHash = keccak256(abi.encode(_domains));\\n    connectorsHash = keccak256(abi.encode(_connectors));\\n  }\\n}\\n\",\"keccak256\":\"0x2f0f477581793a2d846d3525d6def40067a946dd1a68d700eec55a97febbc2f6\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/messaging/libraries/MerkleLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity 0.8.17;\\n\\n/**\\n * @title MerkleLib\\n * @author Illusory Systems Inc.\\n * @notice An incremental merkle tree modeled on the eth2 deposit contract.\\n **/\\nlibrary MerkleLib {\\n  // ========== Custom Errors ===========\\n\\n  error MerkleLib__insert_treeIsFull();\\n\\n  // ============ Constants =============\\n\\n  uint256 internal constant TREE_DEPTH = 32;\\n  uint256 internal constant MAX_LEAVES = 2**TREE_DEPTH - 1;\\n\\n  /**\\n   * @dev Z_i represent the hash values at different heights for a binary tree with leaf values equal to `0`.\\n   * (e.g. Z_1 is the keccak256 hash of (0x0, 0x0), Z_2 is the keccak256 hash of (Z_1, Z_1), etc...)\\n   * Z_0 is the bottom of the 33-layer tree, Z_32 is the top (i.e. root).\\n   * Used to shortcut calculation in root calculation methods below.\\n   */\\n  bytes32 internal constant Z_0 = hex\\\"0000000000000000000000000000000000000000000000000000000000000000\\\";\\n  bytes32 internal constant Z_1 = hex\\\"ad3228b676f7d3cd4284a5443f17f1962b36e491b30a40b2405849e597ba5fb5\\\";\\n  bytes32 internal constant Z_2 = hex\\\"b4c11951957c6f8f642c4af61cd6b24640fec6dc7fc607ee8206a99e92410d30\\\";\\n  bytes32 internal constant Z_3 = hex\\\"21ddb9a356815c3fac1026b6dec5df3124afbadb485c9ba5a3e3398a04b7ba85\\\";\\n  bytes32 internal constant Z_4 = hex\\\"e58769b32a1beaf1ea27375a44095a0d1fb664ce2dd358e7fcbfb78c26a19344\\\";\\n  bytes32 internal constant Z_5 = hex\\\"0eb01ebfc9ed27500cd4dfc979272d1f0913cc9f66540d7e8005811109e1cf2d\\\";\\n  bytes32 internal constant Z_6 = hex\\\"887c22bd8750d34016ac3c66b5ff102dacdd73f6b014e710b51e8022af9a1968\\\";\\n  bytes32 internal constant Z_7 = hex\\\"ffd70157e48063fc33c97a050f7f640233bf646cc98d9524c6b92bcf3ab56f83\\\";\\n  bytes32 internal constant Z_8 = hex\\\"9867cc5f7f196b93bae1e27e6320742445d290f2263827498b54fec539f756af\\\";\\n  bytes32 internal constant Z_9 = hex\\\"cefad4e508c098b9a7e1d8feb19955fb02ba9675585078710969d3440f5054e0\\\";\\n  bytes32 internal constant Z_10 = hex\\\"f9dc3e7fe016e050eff260334f18a5d4fe391d82092319f5964f2e2eb7c1c3a5\\\";\\n  bytes32 internal constant Z_11 = hex\\\"f8b13a49e282f609c317a833fb8d976d11517c571d1221a265d25af778ecf892\\\";\\n  bytes32 internal constant Z_12 = hex\\\"3490c6ceeb450aecdc82e28293031d10c7d73bf85e57bf041a97360aa2c5d99c\\\";\\n  bytes32 internal constant Z_13 = hex\\\"c1df82d9c4b87413eae2ef048f94b4d3554cea73d92b0f7af96e0271c691e2bb\\\";\\n  bytes32 internal constant Z_14 = hex\\\"5c67add7c6caf302256adedf7ab114da0acfe870d449a3a489f781d659e8becc\\\";\\n  bytes32 internal constant Z_15 = hex\\\"da7bce9f4e8618b6bd2f4132ce798cdc7a60e7e1460a7299e3c6342a579626d2\\\";\\n  bytes32 internal constant Z_16 = hex\\\"2733e50f526ec2fa19a22b31e8ed50f23cd1fdf94c9154ed3a7609a2f1ff981f\\\";\\n  bytes32 internal constant Z_17 = hex\\\"e1d3b5c807b281e4683cc6d6315cf95b9ade8641defcb32372f1c126e398ef7a\\\";\\n  bytes32 internal constant Z_18 = hex\\\"5a2dce0a8a7f68bb74560f8f71837c2c2ebbcbf7fffb42ae1896f13f7c7479a0\\\";\\n  bytes32 internal constant Z_19 = hex\\\"b46a28b6f55540f89444f63de0378e3d121be09e06cc9ded1c20e65876d36aa0\\\";\\n  bytes32 internal constant Z_20 = hex\\\"c65e9645644786b620e2dd2ad648ddfcbf4a7e5b1a3a4ecfe7f64667a3f0b7e2\\\";\\n  bytes32 internal constant Z_21 = hex\\\"f4418588ed35a2458cffeb39b93d26f18d2ab13bdce6aee58e7b99359ec2dfd9\\\";\\n  bytes32 internal constant Z_22 = hex\\\"5a9c16dc00d6ef18b7933a6f8dc65ccb55667138776f7dea101070dc8796e377\\\";\\n  bytes32 internal constant Z_23 = hex\\\"4df84f40ae0c8229d0d6069e5c8f39a7c299677a09d367fc7b05e3bc380ee652\\\";\\n  bytes32 internal constant Z_24 = hex\\\"cdc72595f74c7b1043d0e1ffbab734648c838dfb0527d971b602bc216c9619ef\\\";\\n  bytes32 internal constant Z_25 = hex\\\"0abf5ac974a1ed57f4050aa510dd9c74f508277b39d7973bb2dfccc5eeb0618d\\\";\\n  bytes32 internal constant Z_26 = hex\\\"b8cd74046ff337f0a7bf2c8e03e10f642c1886798d71806ab1e888d9e5ee87d0\\\";\\n  bytes32 internal constant Z_27 = hex\\\"838c5655cb21c6cb83313b5a631175dff4963772cce9108188b34ac87c81c41e\\\";\\n  bytes32 internal constant Z_28 = hex\\\"662ee4dd2dd7b2bc707961b1e646c4047669dcb6584f0d8d770daf5d7e7deb2e\\\";\\n  bytes32 internal constant Z_29 = hex\\\"388ab20e2573d171a88108e79d820e98f26c0b84aa8b2f4aa4968dbb818ea322\\\";\\n  bytes32 internal constant Z_30 = hex\\\"93237c50ba75ee485f4c22adf2f741400bdf8d6a9cc7df7ecae576221665d735\\\";\\n  bytes32 internal constant Z_31 = hex\\\"8448818bb4ae4562849e949e17ac16e0be16688e156b5cf15e098c627c0056a9\\\";\\n  bytes32 internal constant Z_32 = hex\\\"27ae5ba08d7291c96c8cbddcc148bf48a6d68c7974b94356f53754ef6171d757\\\";\\n\\n  // ============= Structs ==============\\n\\n  /**\\n   * @notice Struct representing incremental merkle tree. Contains current\\n   * branch and the number of inserted leaves in the tree.\\n   **/\\n  struct Tree {\\n    bytes32[TREE_DEPTH] branch;\\n    uint256 count;\\n  }\\n\\n  // ========= Write Methods =========\\n\\n  /**\\n   * @notice Inserts a given node (leaf) into merkle tree. Operates on an in-memory tree and\\n   * returns an updated version of that tree.\\n   * @dev Reverts if the tree is already full.\\n   * @param node Element to insert into tree.\\n   * @return Tree Updated tree.\\n   **/\\n  function insert(Tree memory tree, bytes32 node) internal pure returns (Tree memory) {\\n    // Update tree.count to increase the current count by 1 since we'll be including a new node.\\n    uint256 size = ++tree.count;\\n    if (size > MAX_LEAVES) revert MerkleLib__insert_treeIsFull();\\n\\n    // Loop starting at 0, ending when we've finished inserting the node (i.e. hashing it) into\\n    // the active branch. Each loop we cut size in half, hashing the inserted node up the active\\n    // branch along the way.\\n    for (uint256 i; i < TREE_DEPTH; ) {\\n      // Check if the current size is odd; if so, we set this index in the branch to be the node.\\n      if ((size & 1) == 1) {\\n        // If i > 0, then this node will be a hash of the original node with every layer up\\n        // until layer `i`.\\n        tree.branch[i] = node;\\n        return tree;\\n      }\\n      // If the size is not yet odd, we hash the current index in the tree branch with the node.\\n      node = keccak256(abi.encodePacked(tree.branch[i], node));\\n      size >>= 1; // Cut size in half (statement equivalent to: `size /= 2`).\\n\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n    // As the loop should always end prematurely with the `return` statement, this code should\\n    // be unreachable. We revert here just to be safe.\\n    revert MerkleLib__insert_treeIsFull();\\n  }\\n\\n  // ========= Read Methods =========\\n\\n  /**\\n   * @notice Calculates and returns tree's current root.\\n   * @return _current bytes32 root.\\n   **/\\n  function root(Tree storage tree) internal view returns (bytes32 _current) {\\n    uint256 _index = tree.count;\\n\\n    if (_index == 0) {\\n      return Z_32;\\n    }\\n\\n    uint256 i;\\n    assembly {\\n      let TREE_SLOT := tree.slot\\n\\n      for {\\n\\n      } true {\\n\\n      } {\\n        for {\\n\\n        } true {\\n\\n        } {\\n          if and(_index, 1) {\\n            mstore(0, sload(TREE_SLOT))\\n            mstore(0x20, Z_0)\\n            _current := keccak256(0, 0x40)\\n            break\\n          }\\n\\n          if and(_index, shl(1, 1)) {\\n            mstore(0, sload(add(TREE_SLOT, 1)))\\n            mstore(0x20, Z_1)\\n            _current := keccak256(0, 0x40)\\n            i := 1\\n            break\\n          }\\n\\n          if and(_index, shl(2, 1)) {\\n            mstore(0, sload(add(TREE_SLOT, 2)))\\n            mstore(0x20, Z_2)\\n            _current := keccak256(0, 0x40)\\n            i := 2\\n            break\\n          }\\n\\n          if and(_index, shl(3, 1)) {\\n            mstore(0, sload(add(TREE_SLOT, 3)))\\n            mstore(0x20, Z_3)\\n            _current := keccak256(0, 0x40)\\n            i := 3\\n            break\\n          }\\n\\n          if and(_index, shl(4, 1)) {\\n            mstore(0, sload(add(TREE_SLOT, 4)))\\n            mstore(0x20, Z_4)\\n            _current := keccak256(0, 0x40)\\n            i := 4\\n            break\\n          }\\n\\n          if and(_index, shl(5, 1)) {\\n            mstore(0, sload(add(TREE_SLOT, 5)))\\n            mstore(0x20, Z_5)\\n            _current := keccak256(0, 0x40)\\n            i := 5\\n            break\\n          }\\n\\n          if and(_index, shl(6, 1)) {\\n            mstore(0, sload(add(TREE_SLOT, 6)))\\n            mstore(0x20, Z_6)\\n            _current := keccak256(0, 0x40)\\n            i := 6\\n            break\\n          }\\n\\n          if and(_index, shl(7, 1)) {\\n            mstore(0, sload(add(TREE_SLOT, 7)))\\n            mstore(0x20, Z_7)\\n            _current := keccak256(0, 0x40)\\n            i := 7\\n            break\\n          }\\n\\n          if and(_index, shl(8, 1)) {\\n            mstore(0, sload(add(TREE_SLOT, 8)))\\n            mstore(0x20, Z_8)\\n            _current := keccak256(0, 0x40)\\n            i := 8\\n            break\\n          }\\n\\n          if and(_index, shl(9, 1)) {\\n            mstore(0, sload(add(TREE_SLOT, 9)))\\n            mstore(0x20, Z_9)\\n            _current := keccak256(0, 0x40)\\n            i := 9\\n            break\\n          }\\n\\n          if and(_index, shl(10, 1)) {\\n            mstore(0, sload(add(TREE_SLOT, 10)))\\n            mstore(0x20, Z_10)\\n            _current := keccak256(0, 0x40)\\n            i := 10\\n            break\\n          }\\n\\n          if and(_index, shl(11, 1)) {\\n            mstore(0, sload(add(TREE_SLOT, 11)))\\n            mstore(0x20, Z_11)\\n            _current := keccak256(0, 0x40)\\n            i := 11\\n            break\\n          }\\n\\n          if and(_index, shl(12, 1)) {\\n            mstore(0, sload(add(TREE_SLOT, 12)))\\n            mstore(0x20, Z_12)\\n            _current := keccak256(0, 0x40)\\n            i := 12\\n            break\\n          }\\n\\n          if and(_index, shl(13, 1)) {\\n            mstore(0, sload(add(TREE_SLOT, 13)))\\n            mstore(0x20, Z_13)\\n            _current := keccak256(0, 0x40)\\n            i := 13\\n            break\\n          }\\n\\n          if and(_index, shl(14, 1)) {\\n            mstore(0, sload(add(TREE_SLOT, 14)))\\n            mstore(0x20, Z_14)\\n            _current := keccak256(0, 0x40)\\n            i := 14\\n            break\\n          }\\n\\n          if and(_index, shl(15, 1)) {\\n            mstore(0, sload(add(TREE_SLOT, 15)))\\n            mstore(0x20, Z_15)\\n            _current := keccak256(0, 0x40)\\n            i := 15\\n            break\\n          }\\n\\n          if and(_index, shl(16, 1)) {\\n            mstore(0, sload(add(TREE_SLOT, 16)))\\n            mstore(0x20, Z_16)\\n            _current := keccak256(0, 0x40)\\n            i := 16\\n            break\\n          }\\n\\n          if and(_index, shl(17, 1)) {\\n            mstore(0, sload(add(TREE_SLOT, 17)))\\n            mstore(0x20, Z_17)\\n            _current := keccak256(0, 0x40)\\n            i := 17\\n            break\\n          }\\n\\n          if and(_index, shl(18, 1)) {\\n            mstore(0, sload(add(TREE_SLOT, 18)))\\n            mstore(0x20, Z_18)\\n            _current := keccak256(0, 0x40)\\n            i := 18\\n            break\\n          }\\n\\n          if and(_index, shl(19, 1)) {\\n            mstore(0, sload(add(TREE_SLOT, 19)))\\n            mstore(0x20, Z_19)\\n            _current := keccak256(0, 0x40)\\n            i := 19\\n            break\\n          }\\n\\n          if and(_index, shl(20, 1)) {\\n            mstore(0, sload(add(TREE_SLOT, 20)))\\n            mstore(0x20, Z_20)\\n            _current := keccak256(0, 0x40)\\n            i := 20\\n            break\\n          }\\n\\n          if and(_index, shl(21, 1)) {\\n            mstore(0, sload(add(TREE_SLOT, 21)))\\n            mstore(0x20, Z_21)\\n            _current := keccak256(0, 0x40)\\n            i := 21\\n            break\\n          }\\n\\n          if and(_index, shl(22, 1)) {\\n            mstore(0, sload(add(TREE_SLOT, 22)))\\n            mstore(0x20, Z_22)\\n            _current := keccak256(0, 0x40)\\n            i := 22\\n            break\\n          }\\n\\n          if and(_index, shl(23, 1)) {\\n            mstore(0, sload(add(TREE_SLOT, 23)))\\n            mstore(0x20, Z_23)\\n            _current := keccak256(0, 0x40)\\n            i := 23\\n            break\\n          }\\n\\n          if and(_index, shl(24, 1)) {\\n            mstore(0, sload(add(TREE_SLOT, 24)))\\n            mstore(0x20, Z_24)\\n            _current := keccak256(0, 0x40)\\n            i := 24\\n            break\\n          }\\n\\n          if and(_index, shl(25, 1)) {\\n            mstore(0, sload(add(TREE_SLOT, 25)))\\n            mstore(0x20, Z_25)\\n            _current := keccak256(0, 0x40)\\n            i := 25\\n            break\\n          }\\n\\n          if and(_index, shl(26, 1)) {\\n            mstore(0, sload(add(TREE_SLOT, 26)))\\n            mstore(0x20, Z_26)\\n            _current := keccak256(0, 0x40)\\n            i := 26\\n            break\\n          }\\n\\n          if and(_index, shl(27, 1)) {\\n            mstore(0, sload(add(TREE_SLOT, 27)))\\n            mstore(0x20, Z_27)\\n            _current := keccak256(0, 0x40)\\n            i := 27\\n            break\\n          }\\n\\n          if and(_index, shl(28, 1)) {\\n            mstore(0, sload(add(TREE_SLOT, 28)))\\n            mstore(0x20, Z_28)\\n            _current := keccak256(0, 0x40)\\n            i := 28\\n            break\\n          }\\n\\n          if and(_index, shl(29, 1)) {\\n            mstore(0, sload(add(TREE_SLOT, 29)))\\n            mstore(0x20, Z_29)\\n            _current := keccak256(0, 0x40)\\n            i := 29\\n            break\\n          }\\n\\n          if and(_index, shl(30, 1)) {\\n            mstore(0, sload(add(TREE_SLOT, 30)))\\n            mstore(0x20, Z_30)\\n            _current := keccak256(0, 0x40)\\n            i := 30\\n            break\\n          }\\n\\n          if and(_index, shl(31, 1)) {\\n            mstore(0, sload(add(TREE_SLOT, 31)))\\n            mstore(0x20, Z_31)\\n            _current := keccak256(0, 0x40)\\n            i := 31\\n            break\\n          }\\n\\n          _current := Z_32\\n          i := 32\\n          break\\n        }\\n\\n        if gt(i, 30) {\\n          break\\n        }\\n\\n        {\\n          if lt(i, 1) {\\n            switch and(_index, shl(1, 1))\\n            case 0 {\\n              mstore(0, _current)\\n              mstore(0x20, Z_1)\\n            }\\n            default {\\n              mstore(0, sload(add(TREE_SLOT, 1)))\\n              mstore(0x20, _current)\\n            }\\n\\n            _current := keccak256(0, 0x40)\\n          }\\n\\n          if lt(i, 2) {\\n            switch and(_index, shl(2, 1))\\n            case 0 {\\n              mstore(0, _current)\\n              mstore(0x20, Z_2)\\n            }\\n            default {\\n              mstore(0, sload(add(TREE_SLOT, 2)))\\n              mstore(0x20, _current)\\n            }\\n\\n            _current := keccak256(0, 0x40)\\n          }\\n\\n          if lt(i, 3) {\\n            switch and(_index, shl(3, 1))\\n            case 0 {\\n              mstore(0, _current)\\n              mstore(0x20, Z_3)\\n            }\\n            default {\\n              mstore(0, sload(add(TREE_SLOT, 3)))\\n              mstore(0x20, _current)\\n            }\\n\\n            _current := keccak256(0, 0x40)\\n          }\\n\\n          if lt(i, 4) {\\n            switch and(_index, shl(4, 1))\\n            case 0 {\\n              mstore(0, _current)\\n              mstore(0x20, Z_4)\\n            }\\n            default {\\n              mstore(0, sload(add(TREE_SLOT, 4)))\\n              mstore(0x20, _current)\\n            }\\n\\n            _current := keccak256(0, 0x40)\\n          }\\n\\n          if lt(i, 5) {\\n            switch and(_index, shl(5, 1))\\n            case 0 {\\n              mstore(0, _current)\\n              mstore(0x20, Z_5)\\n            }\\n            default {\\n              mstore(0, sload(add(TREE_SLOT, 5)))\\n              mstore(0x20, _current)\\n            }\\n\\n            _current := keccak256(0, 0x40)\\n          }\\n\\n          if lt(i, 6) {\\n            switch and(_index, shl(6, 1))\\n            case 0 {\\n              mstore(0, _current)\\n              mstore(0x20, Z_6)\\n            }\\n            default {\\n              mstore(0, sload(add(TREE_SLOT, 6)))\\n              mstore(0x20, _current)\\n            }\\n\\n            _current := keccak256(0, 0x40)\\n          }\\n\\n          if lt(i, 7) {\\n            switch and(_index, shl(7, 1))\\n            case 0 {\\n              mstore(0, _current)\\n              mstore(0x20, Z_7)\\n            }\\n            default {\\n              mstore(0, sload(add(TREE_SLOT, 7)))\\n              mstore(0x20, _current)\\n            }\\n\\n            _current := keccak256(0, 0x40)\\n          }\\n\\n          if lt(i, 8) {\\n            switch and(_index, shl(8, 1))\\n            case 0 {\\n              mstore(0, _current)\\n              mstore(0x20, Z_8)\\n            }\\n            default {\\n              mstore(0, sload(add(TREE_SLOT, 8)))\\n              mstore(0x20, _current)\\n            }\\n\\n            _current := keccak256(0, 0x40)\\n          }\\n\\n          if lt(i, 9) {\\n            switch and(_index, shl(9, 1))\\n            case 0 {\\n              mstore(0, _current)\\n              mstore(0x20, Z_9)\\n            }\\n            default {\\n              mstore(0, sload(add(TREE_SLOT, 9)))\\n              mstore(0x20, _current)\\n            }\\n\\n            _current := keccak256(0, 0x40)\\n          }\\n\\n          if lt(i, 10) {\\n            switch and(_index, shl(10, 1))\\n            case 0 {\\n              mstore(0, _current)\\n              mstore(0x20, Z_10)\\n            }\\n            default {\\n              mstore(0, sload(add(TREE_SLOT, 10)))\\n              mstore(0x20, _current)\\n            }\\n\\n            _current := keccak256(0, 0x40)\\n          }\\n\\n          if lt(i, 11) {\\n            switch and(_index, shl(11, 1))\\n            case 0 {\\n              mstore(0, _current)\\n              mstore(0x20, Z_11)\\n            }\\n            default {\\n              mstore(0, sload(add(TREE_SLOT, 11)))\\n              mstore(0x20, _current)\\n            }\\n\\n            _current := keccak256(0, 0x40)\\n          }\\n\\n          if lt(i, 12) {\\n            switch and(_index, shl(12, 1))\\n            case 0 {\\n              mstore(0, _current)\\n              mstore(0x20, Z_12)\\n            }\\n            default {\\n              mstore(0, sload(add(TREE_SLOT, 12)))\\n              mstore(0x20, _current)\\n            }\\n\\n            _current := keccak256(0, 0x40)\\n          }\\n\\n          if lt(i, 13) {\\n            switch and(_index, shl(13, 1))\\n            case 0 {\\n              mstore(0, _current)\\n              mstore(0x20, Z_13)\\n            }\\n            default {\\n              mstore(0, sload(add(TREE_SLOT, 13)))\\n              mstore(0x20, _current)\\n            }\\n\\n            _current := keccak256(0, 0x40)\\n          }\\n\\n          if lt(i, 14) {\\n            switch and(_index, shl(14, 1))\\n            case 0 {\\n              mstore(0, _current)\\n              mstore(0x20, Z_14)\\n            }\\n            default {\\n              mstore(0, sload(add(TREE_SLOT, 14)))\\n              mstore(0x20, _current)\\n            }\\n\\n            _current := keccak256(0, 0x40)\\n          }\\n\\n          if lt(i, 15) {\\n            switch and(_index, shl(15, 1))\\n            case 0 {\\n              mstore(0, _current)\\n              mstore(0x20, Z_15)\\n            }\\n            default {\\n              mstore(0, sload(add(TREE_SLOT, 15)))\\n              mstore(0x20, _current)\\n            }\\n\\n            _current := keccak256(0, 0x40)\\n          }\\n\\n          if lt(i, 16) {\\n            switch and(_index, shl(16, 1))\\n            case 0 {\\n              mstore(0, _current)\\n              mstore(0x20, Z_16)\\n            }\\n            default {\\n              mstore(0, sload(add(TREE_SLOT, 16)))\\n              mstore(0x20, _current)\\n            }\\n\\n            _current := keccak256(0, 0x40)\\n          }\\n\\n          if lt(i, 17) {\\n            switch and(_index, shl(17, 1))\\n            case 0 {\\n              mstore(0, _current)\\n              mstore(0x20, Z_17)\\n            }\\n            default {\\n              mstore(0, sload(add(TREE_SLOT, 17)))\\n              mstore(0x20, _current)\\n            }\\n\\n            _current := keccak256(0, 0x40)\\n          }\\n\\n          if lt(i, 18) {\\n            switch and(_index, shl(18, 1))\\n            case 0 {\\n              mstore(0, _current)\\n              mstore(0x20, Z_18)\\n            }\\n            default {\\n              mstore(0, sload(add(TREE_SLOT, 18)))\\n              mstore(0x20, _current)\\n            }\\n\\n            _current := keccak256(0, 0x40)\\n          }\\n\\n          if lt(i, 19) {\\n            switch and(_index, shl(19, 1))\\n            case 0 {\\n              mstore(0, _current)\\n              mstore(0x20, Z_19)\\n            }\\n            default {\\n              mstore(0, sload(add(TREE_SLOT, 19)))\\n              mstore(0x20, _current)\\n            }\\n\\n            _current := keccak256(0, 0x40)\\n          }\\n\\n          if lt(i, 20) {\\n            switch and(_index, shl(20, 1))\\n            case 0 {\\n              mstore(0, _current)\\n              mstore(0x20, Z_20)\\n            }\\n            default {\\n              mstore(0, sload(add(TREE_SLOT, 20)))\\n              mstore(0x20, _current)\\n            }\\n\\n            _current := keccak256(0, 0x40)\\n          }\\n\\n          if lt(i, 21) {\\n            switch and(_index, shl(21, 1))\\n            case 0 {\\n              mstore(0, _current)\\n              mstore(0x20, Z_21)\\n            }\\n            default {\\n              mstore(0, sload(add(TREE_SLOT, 21)))\\n              mstore(0x20, _current)\\n            }\\n\\n            _current := keccak256(0, 0x40)\\n          }\\n\\n          if lt(i, 22) {\\n            switch and(_index, shl(22, 1))\\n            case 0 {\\n              mstore(0, _current)\\n              mstore(0x20, Z_22)\\n            }\\n            default {\\n              mstore(0, sload(add(TREE_SLOT, 22)))\\n              mstore(0x20, _current)\\n            }\\n\\n            _current := keccak256(0, 0x40)\\n          }\\n\\n          if lt(i, 23) {\\n            switch and(_index, shl(23, 1))\\n            case 0 {\\n              mstore(0, _current)\\n              mstore(0x20, Z_23)\\n            }\\n            default {\\n              mstore(0, sload(add(TREE_SLOT, 23)))\\n              mstore(0x20, _current)\\n            }\\n\\n            _current := keccak256(0, 0x40)\\n          }\\n\\n          if lt(i, 24) {\\n            switch and(_index, shl(24, 1))\\n            case 0 {\\n              mstore(0, _current)\\n              mstore(0x20, Z_24)\\n            }\\n            default {\\n              mstore(0, sload(add(TREE_SLOT, 24)))\\n              mstore(0x20, _current)\\n            }\\n\\n            _current := keccak256(0, 0x40)\\n          }\\n\\n          if lt(i, 25) {\\n            switch and(_index, shl(25, 1))\\n            case 0 {\\n              mstore(0, _current)\\n              mstore(0x20, Z_25)\\n            }\\n            default {\\n              mstore(0, sload(add(TREE_SLOT, 25)))\\n              mstore(0x20, _current)\\n            }\\n\\n            _current := keccak256(0, 0x40)\\n          }\\n\\n          if lt(i, 26) {\\n            switch and(_index, shl(26, 1))\\n            case 0 {\\n              mstore(0, _current)\\n              mstore(0x20, Z_26)\\n            }\\n            default {\\n              mstore(0, sload(add(TREE_SLOT, 26)))\\n              mstore(0x20, _current)\\n            }\\n\\n            _current := keccak256(0, 0x40)\\n          }\\n\\n          if lt(i, 27) {\\n            switch and(_index, shl(27, 1))\\n            case 0 {\\n              mstore(0, _current)\\n              mstore(0x20, Z_27)\\n            }\\n            default {\\n              mstore(0, sload(add(TREE_SLOT, 27)))\\n              mstore(0x20, _current)\\n            }\\n\\n            _current := keccak256(0, 0x40)\\n          }\\n\\n          if lt(i, 28) {\\n            switch and(_index, shl(28, 1))\\n            case 0 {\\n              mstore(0, _current)\\n              mstore(0x20, Z_28)\\n            }\\n            default {\\n              mstore(0, sload(add(TREE_SLOT, 28)))\\n              mstore(0x20, _current)\\n            }\\n\\n            _current := keccak256(0, 0x40)\\n          }\\n\\n          if lt(i, 29) {\\n            switch and(_index, shl(29, 1))\\n            case 0 {\\n              mstore(0, _current)\\n              mstore(0x20, Z_29)\\n            }\\n            default {\\n              mstore(0, sload(add(TREE_SLOT, 29)))\\n              mstore(0x20, _current)\\n            }\\n\\n            _current := keccak256(0, 0x40)\\n          }\\n\\n          if lt(i, 30) {\\n            switch and(_index, shl(30, 1))\\n            case 0 {\\n              mstore(0, _current)\\n              mstore(0x20, Z_30)\\n            }\\n            default {\\n              mstore(0, sload(add(TREE_SLOT, 30)))\\n              mstore(0x20, _current)\\n            }\\n\\n            _current := keccak256(0, 0x40)\\n          }\\n\\n          if lt(i, 31) {\\n            switch and(_index, shl(31, 1))\\n            case 0 {\\n              mstore(0, _current)\\n              mstore(0x20, Z_31)\\n            }\\n            default {\\n              mstore(0, sload(add(TREE_SLOT, 31)))\\n              mstore(0x20, _current)\\n            }\\n\\n            _current := keccak256(0, 0x40)\\n          }\\n        }\\n\\n        break\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @notice Calculates and returns the merkle root for the given leaf `_item`,\\n   * a merkle branch, and the index of `_item` in the tree.\\n   * @param _item Merkle leaf\\n   * @param _branch Merkle proof\\n   * @param _index Index of `_item` in tree\\n   * @return _current Calculated merkle root\\n   **/\\n  function branchRoot(\\n    bytes32 _item,\\n    bytes32[TREE_DEPTH] memory _branch,\\n    uint256 _index\\n  ) internal pure returns (bytes32 _current) {\\n    assembly {\\n      _current := _item\\n      let BRANCH_DATA_OFFSET := _branch\\n      let f\\n\\n      f := shl(5, and(_index, 1))\\n      mstore(f, _current)\\n      mstore(sub(0x20, f), mload(BRANCH_DATA_OFFSET))\\n      _current := keccak256(0, 0x40)\\n\\n      f := shl(5, iszero(and(_index, shl(1, 1))))\\n      mstore(sub(0x20, f), _current)\\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 1))))\\n      _current := keccak256(0, 0x40)\\n\\n      f := shl(5, iszero(and(_index, shl(2, 1))))\\n      mstore(sub(0x20, f), _current)\\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 2))))\\n      _current := keccak256(0, 0x40)\\n\\n      f := shl(5, iszero(and(_index, shl(3, 1))))\\n      mstore(sub(0x20, f), _current)\\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 3))))\\n      _current := keccak256(0, 0x40)\\n\\n      f := shl(5, iszero(and(_index, shl(4, 1))))\\n      mstore(sub(0x20, f), _current)\\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 4))))\\n      _current := keccak256(0, 0x40)\\n\\n      f := shl(5, iszero(and(_index, shl(5, 1))))\\n      mstore(sub(0x20, f), _current)\\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 5))))\\n      _current := keccak256(0, 0x40)\\n\\n      f := shl(5, iszero(and(_index, shl(6, 1))))\\n      mstore(sub(0x20, f), _current)\\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 6))))\\n      _current := keccak256(0, 0x40)\\n\\n      f := shl(5, iszero(and(_index, shl(7, 1))))\\n      mstore(sub(0x20, f), _current)\\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 7))))\\n      _current := keccak256(0, 0x40)\\n\\n      f := shl(5, iszero(and(_index, shl(8, 1))))\\n      mstore(sub(0x20, f), _current)\\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 8))))\\n      _current := keccak256(0, 0x40)\\n\\n      f := shl(5, iszero(and(_index, shl(9, 1))))\\n      mstore(sub(0x20, f), _current)\\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 9))))\\n      _current := keccak256(0, 0x40)\\n\\n      f := shl(5, iszero(and(_index, shl(10, 1))))\\n      mstore(sub(0x20, f), _current)\\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 10))))\\n      _current := keccak256(0, 0x40)\\n\\n      f := shl(5, iszero(and(_index, shl(11, 1))))\\n      mstore(sub(0x20, f), _current)\\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 11))))\\n      _current := keccak256(0, 0x40)\\n\\n      f := shl(5, iszero(and(_index, shl(12, 1))))\\n      mstore(sub(0x20, f), _current)\\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 12))))\\n      _current := keccak256(0, 0x40)\\n\\n      f := shl(5, iszero(and(_index, shl(13, 1))))\\n      mstore(sub(0x20, f), _current)\\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 13))))\\n      _current := keccak256(0, 0x40)\\n\\n      f := shl(5, iszero(and(_index, shl(14, 1))))\\n      mstore(sub(0x20, f), _current)\\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 14))))\\n      _current := keccak256(0, 0x40)\\n\\n      f := shl(5, iszero(and(_index, shl(15, 1))))\\n      mstore(sub(0x20, f), _current)\\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 15))))\\n      _current := keccak256(0, 0x40)\\n\\n      f := shl(5, iszero(and(_index, shl(16, 1))))\\n      mstore(sub(0x20, f), _current)\\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 16))))\\n      _current := keccak256(0, 0x40)\\n\\n      f := shl(5, iszero(and(_index, shl(17, 1))))\\n      mstore(sub(0x20, f), _current)\\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 17))))\\n      _current := keccak256(0, 0x40)\\n\\n      f := shl(5, iszero(and(_index, shl(18, 1))))\\n      mstore(sub(0x20, f), _current)\\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 18))))\\n      _current := keccak256(0, 0x40)\\n\\n      f := shl(5, iszero(and(_index, shl(19, 1))))\\n      mstore(sub(0x20, f), _current)\\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 19))))\\n      _current := keccak256(0, 0x40)\\n\\n      f := shl(5, iszero(and(_index, shl(20, 1))))\\n      mstore(sub(0x20, f), _current)\\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 20))))\\n      _current := keccak256(0, 0x40)\\n\\n      f := shl(5, iszero(and(_index, shl(21, 1))))\\n      mstore(sub(0x20, f), _current)\\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 21))))\\n      _current := keccak256(0, 0x40)\\n\\n      f := shl(5, iszero(and(_index, shl(22, 1))))\\n      mstore(sub(0x20, f), _current)\\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 22))))\\n      _current := keccak256(0, 0x40)\\n\\n      f := shl(5, iszero(and(_index, shl(23, 1))))\\n      mstore(sub(0x20, f), _current)\\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 23))))\\n      _current := keccak256(0, 0x40)\\n\\n      f := shl(5, iszero(and(_index, shl(24, 1))))\\n      mstore(sub(0x20, f), _current)\\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 24))))\\n      _current := keccak256(0, 0x40)\\n\\n      f := shl(5, iszero(and(_index, shl(25, 1))))\\n      mstore(sub(0x20, f), _current)\\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 25))))\\n      _current := keccak256(0, 0x40)\\n\\n      f := shl(5, iszero(and(_index, shl(26, 1))))\\n      mstore(sub(0x20, f), _current)\\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 26))))\\n      _current := keccak256(0, 0x40)\\n\\n      f := shl(5, iszero(and(_index, shl(27, 1))))\\n      mstore(sub(0x20, f), _current)\\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 27))))\\n      _current := keccak256(0, 0x40)\\n\\n      f := shl(5, iszero(and(_index, shl(28, 1))))\\n      mstore(sub(0x20, f), _current)\\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 28))))\\n      _current := keccak256(0, 0x40)\\n\\n      f := shl(5, iszero(and(_index, shl(29, 1))))\\n      mstore(sub(0x20, f), _current)\\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 29))))\\n      _current := keccak256(0, 0x40)\\n\\n      f := shl(5, iszero(and(_index, shl(30, 1))))\\n      mstore(sub(0x20, f), _current)\\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 30))))\\n      _current := keccak256(0, 0x40)\\n\\n      f := shl(5, iszero(and(_index, shl(31, 1))))\\n      mstore(sub(0x20, f), _current)\\n      mstore(f, mload(add(BRANCH_DATA_OFFSET, shl(5, 31))))\\n      _current := keccak256(0, 0x40)\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x08c791dbeef6253813d74e2145183501fe7631c13d5ac9d768036f47b66b693e\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/messaging/libraries/Queue.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity 0.8.17;\\n\\n/**\\n * @title QueueLib\\n * @notice Library containing queue struct and operations for queue used by RootManager and SpokeConnector\\n * for handling the verification period. Tracks both message data itself and the block that the message was\\n * committed to the queue.\\n **/\\nlibrary QueueLib {\\n  /**\\n   * @notice Queue struct\\n   * @dev Internally keeps track of the `first` and `last` elements through\\n   * indices and a mapping of indices to enqueued elements.\\n   **/\\n  struct Queue {\\n    uint128 first;\\n    uint128 last;\\n    // Message data (roots) that have been received.\\n    mapping(uint256 => bytes32) data;\\n    // The block that the message data was committed.\\n    mapping(uint256 => uint256) commitBlock;\\n    // A reverse mapping of all entries that have been \\\"removed\\\" by value; behaves like a blocklist.\\n    // NOTE: Removed values can still be pushed to the queue, but will be ignored/skipped when dequeuing.\\n    mapping(bytes32 => bool) removed;\\n  }\\n\\n  /**\\n   * @notice Initializes the queue\\n   * @dev Empty state denoted by queue.first > queue.last. Queue initialized with\\n   * queue.first = 1 and queue.last = 0.\\n   **/\\n  function initialize(Queue storage queue) internal {\\n    queue.first = 1;\\n    delete queue.last;\\n  }\\n\\n  /**\\n   * @notice Enqueues a single new element and records block number that the item was enqueued\\n   * (i.e. current block).\\n   * @param item New element to be enqueued.\\n   * @return last Index of newly enqueued element.\\n   **/\\n  function enqueue(Queue storage queue, bytes32 item) internal returns (uint128 last) {\\n    // Commit block is the block we are committing this item to the queue.\\n    uint256 commitBlock = block.number;\\n    // Increment `last` position.\\n    last = ++queue.last;\\n    // Add the item and record block number.\\n    queue.data[last] = item;\\n    queue.commitBlock[last] = commitBlock;\\n  }\\n\\n  /**\\n   * @notice Dequeues element at front of queue if it exists AND it's surpassed the given\\n   * verification period (i.e. has been sitting in the queue for enough blocks).\\n   * @param queue QueueStorage struct from contract.\\n   * @param delay The required delay that must have been surpassed in order to merit dequeuing\\n   * the element.\\n   * @param max The maximum number of elements we are allowed to dequeue in this call.\\n   * @return item Dequeued element IFF delay period has been surpassed; otherwise, empty bytes32.\\n   **/\\n  function dequeueVerified(\\n    Queue storage queue,\\n    uint256 delay,\\n    uint128 max\\n  ) internal returns (bytes32[] memory) {\\n    uint128 first = queue.first;\\n    uint128 last = queue.last;\\n\\n    // If queue is empty, short-circuit here.\\n    if (last < first) {\\n      return new bytes32[](0);\\n    }\\n\\n    // Input sanity checks.\\n    require(first != 0, \\\"queue !init'd\\\");\\n    require(max > 0, \\\"!acceptable max\\\");\\n\\n    {\\n      // If we would otherwise be searching beyond the maximum amount we are allowed to dequeue in this\\n      // call, reduce `last` to artificially shrink the available queue within the scope of this method.\\n      uint128 highestAllowed = first + max - 1;\\n      if (last > highestAllowed) {\\n        last = highestAllowed;\\n      }\\n    }\\n\\n    // Commit block must be below this block to be considered verified.\\n    // NOTE: It's assumed that block number is a higher value than delay (i.e. delay is reasonable).\\n    uint256 highestAcceptableCommitBlock = block.number - delay;\\n\\n    // To determine the last item index in the queue we want to return, iterate backwards until we\\n    // find a `commitBlock` that has surpassed the delay period.\\n    // TODO: The most efficient way to determine the split index here should be using a binary search.\\n    bool containsVerified;\\n    // NOTE: `first <= last` rephrased here to `!(first > last)` as it's a cheaper condition.\\n    while (!(first > last)) {\\n      uint256 commitBlock = queue.commitBlock[last];\\n      // NOTE: Same as `commitBlock <= highestAcceptableCommitBlock`.\\n      if (!(commitBlock > highestAcceptableCommitBlock)) {\\n        containsVerified = true;\\n        break;\\n      }\\n      unchecked {\\n        --last;\\n      }\\n    }\\n    // IFF no verified items were found, then we can return an empty array.\\n    if (!containsVerified) {\\n      return new bytes32[](0);\\n    }\\n\\n    bytes32[] memory items = new bytes32[](last + 1 - first);\\n    uint256 index; // Cursor for index in the batch of `items`.\\n    bool removedItems; // If any items have been removed, we filter them here.\\n    // NOTE: `first <= last` rephrased here to `!(first > last)` as it's a cheaper condition.\\n    while (!(first > last)) {\\n      bytes32 item = queue.data[first];\\n      // Check to see if the item has been removed before appending it to the array.\\n      if (!queue.removed[item]) {\\n        items[index] = item;\\n        unchecked {\\n          ++index;\\n        }\\n      } else {\\n        // The item was removed. We do NOT increment the index (we will re-use this position).\\n        if (!removedItems) {\\n          removedItems = true;\\n        }\\n      }\\n\\n      // Delete the item and the commitBlock.\\n      // NOTE: We do NOT delete the entry from `queue.removed`, as it's a reverse lookup and we want to\\n      // block that value permanently (e.g. if there's multiple of the same bad value in the queue).\\n      delete queue.data[first];\\n      delete queue.commitBlock[first];\\n\\n      unchecked {\\n        ++first;\\n      }\\n    }\\n\\n    // Update the value for `first` in our queue object since we've dequeued a number of elements.\\n    queue.first = first;\\n\\n    if (!removedItems) {\\n      return items;\\n    } else {\\n      // If some items were removed, there will be a number of trailing 0 values we need to truncate\\n      // from the array. Create a new array with all of the items up until these empty values.\\n      bytes32[] memory amendedItems = new bytes32[](index); // The last `index` is the new length.\\n      for (uint256 i; i < index; ) {\\n        amendedItems[i] = items[i];\\n        unchecked {\\n          ++i;\\n        }\\n      }\\n      return amendedItems;\\n    }\\n  }\\n\\n  /**\\n   * @notice Sets a certain value to be ignored (skipped) when dequeuing.\\n   */\\n  function remove(Queue storage queue, bytes32 item) internal {\\n    require(!queue.removed[item], \\\"already removed\\\");\\n    queue.removed[item] = true;\\n  }\\n\\n  /**\\n   * @notice Check whether the queue is empty.\\n   * @param queue QueueStorage struct from contract.\\n   * @return bool True if queue is empty and false if otherwise.\\n   */\\n  function isEmpty(Queue storage queue) internal view returns (bool) {\\n    return queue.last < queue.first;\\n  }\\n\\n  /**\\n   * @notice Returns number of elements in queue.\\n   * @param queue QueueStorage struct from contract.\\n   */\\n  function length(Queue storage queue) internal view returns (uint256) {\\n    uint128 last = queue.last;\\n    uint128 first = queue.first;\\n    // Cannot underflow unless state is corrupted.\\n    return _length(last, first);\\n  }\\n\\n  /**\\n   * @notice Returns number of elements between `last` and `first` (used internally).\\n   * @param last The last element index.\\n   * @param first The first element index.\\n   */\\n  function _length(uint128 last, uint128 first) internal pure returns (uint256) {\\n    return uint256(last + 1 - first);\\n  }\\n}\\n\",\"keccak256\":\"0x2997d7d6ca0fc2703a720465e3c378699267189af17a7285655ab1ca91fb7230\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/messaging/libraries/SnapshotId.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.17;\\n\\n/**\\n * @title SnapshotId library\\n * @notice A library to be used in spoke connector and root manager to calculates the current snapshot id\\n */\\nlibrary SnapshotId {\\n  /**\\n   * @notice Duration of the snapshot\\n   * @dev Off-chain agents could change the effective snapshot length by skipping snapshots. This is the\\n   * smallest unit of snapshot duration, not just the only option.\\n   */\\n  uint256 constant SNAPSHOT_DURATION = 30 minutes;\\n\\n  /**\\n   * @notice This function calculates the last completed snapshot id\\n   * @return _lastCompletedSnapshotId The last completed snapshot id\\n   */\\n  function getLastCompletedSnapshotId() internal view returns (uint256 _lastCompletedSnapshotId) {\\n    unchecked {\\n      _lastCompletedSnapshotId = block.timestamp / SNAPSHOT_DURATION;\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0xe1b04329fe0140f863f1916daa081ca6faf4956064a48d8afd8febe3baca2d4b\",\"license\":\"UNLICENSED\"},\"contracts/shared/ProposedOwnable.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.17;\\n\\nimport {IProposedOwnable} from \\\"./interfaces/IProposedOwnable.sol\\\";\\n\\n/**\\n * @title ProposedOwnable\\n * @notice Contract module which provides a basic access control mechanism,\\n * where there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed via a two step process:\\n * 1. Call `proposeOwner`\\n * 2. Wait out the delay period\\n * 3. Call `acceptOwner`\\n *\\n * @dev This module is used through inheritance. It will make available the\\n * modifier `onlyOwner`, which can be applied to your functions to restrict\\n * their use to the owner.\\n *\\n * @dev The majority of this code was taken from the openzeppelin Ownable\\n * contract\\n *\\n */\\nabstract contract ProposedOwnable is IProposedOwnable {\\n  // ========== Custom Errors ===========\\n\\n  error ProposedOwnable__onlyOwner_notOwner();\\n  error ProposedOwnable__onlyProposed_notProposedOwner();\\n  error ProposedOwnable__ownershipDelayElapsed_delayNotElapsed();\\n  error ProposedOwnable__proposeNewOwner_invalidProposal();\\n  error ProposedOwnable__proposeNewOwner_noOwnershipChange();\\n  error ProposedOwnable__renounceOwnership_noProposal();\\n  error ProposedOwnable__renounceOwnership_invalidProposal();\\n\\n  // ============ Properties ============\\n\\n  address private _owner;\\n\\n  address private _proposed;\\n  uint256 private _proposedOwnershipTimestamp;\\n\\n  uint256 private constant _delay = 7 days;\\n\\n  // ======== Getters =========\\n\\n  /**\\n   * @notice Returns the address of the current owner.\\n   */\\n  function owner() public view virtual returns (address) {\\n    return _owner;\\n  }\\n\\n  /**\\n   * @notice Returns the address of the proposed owner.\\n   */\\n  function proposed() public view virtual returns (address) {\\n    return _proposed;\\n  }\\n\\n  /**\\n   * @notice Returns the address of the proposed owner.\\n   */\\n  function proposedTimestamp() public view virtual returns (uint256) {\\n    return _proposedOwnershipTimestamp;\\n  }\\n\\n  /**\\n   * @notice Returns the delay period before a new owner can be accepted.\\n   */\\n  function delay() public view virtual returns (uint256) {\\n    return _delay;\\n  }\\n\\n  /**\\n   * @notice Throws if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    if (_owner != msg.sender) revert ProposedOwnable__onlyOwner_notOwner();\\n    _;\\n  }\\n\\n  /**\\n   * @notice Throws if called by any account other than the proposed owner.\\n   */\\n  modifier onlyProposed() {\\n    if (_proposed != msg.sender) revert ProposedOwnable__onlyProposed_notProposedOwner();\\n    _;\\n  }\\n\\n  /**\\n   * @notice Throws if the ownership delay has not elapsed\\n   */\\n  modifier ownershipDelayElapsed() {\\n    // Ensure delay has elapsed\\n    if ((block.timestamp - _proposedOwnershipTimestamp) <= _delay)\\n      revert ProposedOwnable__ownershipDelayElapsed_delayNotElapsed();\\n    _;\\n  }\\n\\n  /**\\n   * @notice Indicates if the ownership has been renounced() by\\n   * checking if current owner is address(0)\\n   */\\n  function renounced() public view returns (bool) {\\n    return _owner == address(0);\\n  }\\n\\n  // ======== External =========\\n\\n  /**\\n   * @notice Sets the timestamp for an owner to be proposed, and sets the\\n   * newly proposed owner as step 1 in a 2-step process\\n   */\\n  function proposeNewOwner(address newlyProposed) public virtual onlyOwner {\\n    // Contract as source of truth\\n    if (_proposed == newlyProposed && _proposedOwnershipTimestamp != 0)\\n      revert ProposedOwnable__proposeNewOwner_invalidProposal();\\n\\n    // Sanity check: reasonable proposal\\n    if (_owner == newlyProposed) revert ProposedOwnable__proposeNewOwner_noOwnershipChange();\\n\\n    _setProposed(newlyProposed);\\n  }\\n\\n  /**\\n   * @notice Renounces ownership of the contract after a delay\\n   */\\n  function renounceOwnership() public virtual onlyOwner ownershipDelayElapsed {\\n    // Ensure there has been a proposal cycle started\\n    if (_proposedOwnershipTimestamp == 0) revert ProposedOwnable__renounceOwnership_noProposal();\\n\\n    // Require proposed is set to 0\\n    if (_proposed != address(0)) revert ProposedOwnable__renounceOwnership_invalidProposal();\\n\\n    // Emit event, set new owner, reset timestamp\\n    _setOwner(address(0));\\n  }\\n\\n  /**\\n   * @notice Transfers ownership of the contract to a new account (`newOwner`).\\n   * Can only be called by the current owner.\\n   */\\n  function acceptProposedOwner() public virtual onlyProposed ownershipDelayElapsed {\\n    // NOTE: no need to check if _owner == _proposed, because the _proposed\\n    // is 0-d out and this check is implicitly enforced by modifier\\n\\n    // NOTE: no need to check if _proposedOwnershipTimestamp > 0 because\\n    // the only time this would happen is if the _proposed was never\\n    // set (will fail from modifier) or if the owner == _proposed (checked\\n    // above)\\n\\n    // Emit event, set new owner, reset timestamp\\n    _setOwner(_proposed);\\n  }\\n\\n  // ======== Internal =========\\n\\n  function _setOwner(address newOwner) internal {\\n    emit OwnershipTransferred(_owner, newOwner);\\n    _owner = newOwner;\\n    delete _proposedOwnershipTimestamp;\\n    delete _proposed;\\n  }\\n\\n  function _setProposed(address newlyProposed) private {\\n    _proposedOwnershipTimestamp = block.timestamp;\\n    _proposed = newlyProposed;\\n    emit OwnershipProposed(newlyProposed);\\n  }\\n}\\n\",\"keccak256\":\"0xa96eff4fdff55ffa29cda5c18285a9af04c3cbaf55f83696085cdd2251a8d6c0\",\"license\":\"UNLICENSED\"},\"contracts/shared/ProposedOwnableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.17;\\n\\nimport {Initializable} from \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\n\\nimport {ProposedOwnable} from \\\"./ProposedOwnable.sol\\\";\\n\\nabstract contract ProposedOwnableUpgradeable is Initializable, ProposedOwnable {\\n  /**\\n   * @dev Initializes the contract setting the deployer as the initial\\n   */\\n  function __ProposedOwnable_init() internal onlyInitializing {\\n    __ProposedOwnable_init_unchained();\\n  }\\n\\n  function __ProposedOwnable_init_unchained() internal onlyInitializing {\\n    _setOwner(msg.sender);\\n  }\\n\\n  /**\\n   * @dev This empty reserved space is put in place to allow future versions to add new\\n   * variables without shifting down storage in the inheritance chain.\\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n   */\\n  uint256[47] private __GAP;\\n}\\n\",\"keccak256\":\"0x2b064b03a25915e93749905ef3aae516ffaac86b8ba9f126b614425b623bf477\",\"license\":\"UNLICENSED\"},\"contracts/shared/interfaces/IProposedOwnable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/**\\n * @title IProposedOwnable\\n * @notice Defines a minimal interface for ownership with a two step proposal and acceptance\\n * process\\n */\\ninterface IProposedOwnable {\\n  /**\\n   * @dev This emits when change in ownership of a contract is proposed.\\n   */\\n  event OwnershipProposed(address indexed proposedOwner);\\n\\n  /**\\n   * @dev This emits when ownership of a contract changes.\\n   */\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n  /**\\n   * @notice Get the address of the owner\\n   * @return owner_ The address of the owner.\\n   */\\n  function owner() external view returns (address owner_);\\n\\n  /**\\n   * @notice Get the address of the proposed owner\\n   * @return proposed_ The address of the proposed.\\n   */\\n  function proposed() external view returns (address proposed_);\\n\\n  /**\\n   * @notice Set the address of the proposed owner of the contract\\n   * @param newlyProposed The proposed new owner of the contract\\n   */\\n  function proposeNewOwner(address newlyProposed) external;\\n\\n  /**\\n   * @notice Set the address of the proposed owner of the contract\\n   */\\n  function acceptProposedOwner() external;\\n}\\n\",\"keccak256\":\"0x4ec1aa589d37d0c1eac9966e26d2d3540d1661b81763e678f14d2c6fa0682323\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60a060405260016012553480156200001657600080fd5b5060405162003c7738038062003c77833981016040819052620000399162000196565b600380546001600160a81b0319166101006001600160a01b0386160217905562000063336200010e565b818110156200008557604051637a61d42360e11b815260040160405180910390fd5b6001600160a01b038416620000cf5760405162461bcd60e51b815260206004820152600c60248201526b217a65726f206d65726b6c6560a01b604482015260640160405180910390fd5b6001600160a01b0384166080526009859055600b829055600a81905562000103600e62000173602090811b62001eda17901c565b5050505050620001ea565b600080546040516001600160a01b03808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a3600080546001600160a01b039092166001600160a01b0319928316178155600255600180549091169055565b60019055565b80516001600160a01b03811681146200019157600080fd5b919050565b600080600080600060a08688031215620001af57600080fd5b85519450620001c16020870162000179565b9350620001d16040870162000179565b6060870151608090970151959894975095949392505050565b608051613a5c6200021b600039600081816107d001528181610be10152818161151d01526115aa0152613a5c6000f3fe6080604052600436106103815760003560e01c80638456cb59116101d1578063c5b350df11610102578063d2a3cc71116100a0578063e6f1208d1161006f578063e6f1208d14610a21578063e9812d7114610a41578063f4b6e41014610a61578063f715589a14610a7757600080fd5b8063d2a3cc71146109b7578063d3c54fe5146109d7578063d3c805b7146109ec578063db0f016914610a0157600080fd5b8063cbfa2021116100dc578063cbfa20211461094f578063ceb3454e14610964578063d1851c921461097a578063d232c2201461099857600080fd5b8063c5b350df146108f7578063c8ef89de1461090c578063c92930561461092257600080fd5b8063a792c29b1161016f578063ad9c0c2e11610149578063ad9c0c2e14610881578063b03cd41814610897578063b1f8100d146108b7578063b904670f146108d757600080fd5b8063a792c29b1461080f578063a941f3f314610834578063aa0d60a31461085457600080fd5b8063909907cb116101ab578063909907cb1461077f578063957908d114610794578063a01892a5146107be578063a226b2cb146107f257600080fd5b80638456cb591461072c5780638da5cb5b146107415780638e7d93fa1461075f57600080fd5b8063412e12db116102b65780635ffe699d11610254578063715018a611610223578063715018a6146106965780637bc24d99146106ab5780637d434e91146106c15780637d534308146106e157600080fd5b80635ffe699d1461061157806360caf7a01461063157806366cf8fab1461064b5780636a42b8f81461068057600080fd5b8063498c2c2e11610290578063498c2c2e1461059e5780634a2db1da146105b45780635c975abb146105e45780635d308761146105fc57600080fd5b8063412e12db14610563578063460508b414610576578063492a96f41461058b57600080fd5b806324825b0d1161032357806327186c6a116102fd57806327186c6a146104f95780633c4baaf8146105195780633cf52ffb146105395780633f4ba83a1461054e57600080fd5b806324825b0d1461047e57806324ec5d0514610494578063263ef354146104d957600080fd5b806313ede1a11161035f57806313ede1a1146103e857806315fa23bc146104255780631eeaabea1461043a57806320f62eda1461045a57600080fd5b8063089200391461038657806309d632d3146103a85780630f8ef4ee146103c8575b600080fd5b34801561039257600080fd5b506103a66103a1366004612f58565b610aa4565b005b3480156103b457600080fd5b506103a66103c3366004612ff7565b610cad565b3480156103d457600080fd5b506103a66103e3366004613012565b610d21565b3480156103f457600080fd5b50610408610403366004613012565b610d96565b6040516001600160a01b0390911681526020015b60405180910390f35b34801561043157600080fd5b506103a6610dc0565b34801561044657600080fd5b506103a6610455366004613012565b610e4e565b34801561046657600080fd5b50610470600a5481565b60405190815260200161041c565b34801561048a57600080fd5b5061047060155481565b3480156104a057600080fd5b506104c96104af36600461303f565b63ffffffff16600090815260086020526040902054151590565b604051901515815260200161041c565b3480156104e557600080fd5b506103a66104f4366004613012565b610efa565b34801561050557600080fd5b506103a661051436600461305a565b610f88565b34801561052557600080fd5b5061047061053436600461303f565b610ff3565b34801561054557600080fd5b50600254610470565b34801561055a57600080fd5b506103a6611057565b6103a66105713660046131d8565b611094565b34801561058257600080fd5b506103a661118f565b6103a661059936600461326c565b6111f2565b3480156105aa57600080fd5b5061047060075481565b3480156105c057600080fd5b506104c96105cf366004612ff7565b60136020526000908152604090205460ff1681565b3480156105f057600080fd5b5060035460ff166104c9565b34801561060857600080fd5b50610470600181565b34801561061d57600080fd5b506103a661062c36600461303f565b611209565b34801561063d57600080fd5b50600c546104c99060ff1681565b34801561065757600080fd5b5061066b610666366004613012565b6112af565b60405163ffffffff909116815260200161041c565b34801561068c57600080fd5b5062093a80610470565b3480156106a257600080fd5b506103a66112e9565b3480156106b757600080fd5b5061047060055481565b3480156106cd57600080fd5b506104086106dc36600461303f565b61132d565b3480156106ed57600080fd5b50600e5461070c906001600160801b0380821691600160801b90041682565b604080516001600160801b0393841681529290911660208301520161041c565b34801561073857600080fd5b506103a6611365565b34801561074d57600080fd5b506000546001600160a01b0316610408565b34801561076b57600080fd5b506103a661077a366004613313565b611401565b34801561078b57600080fd5b506104706114e0565b3480156107a057600080fd5b506107a96114f1565b6040805192835260208301919091520161041c565b3480156107ca57600080fd5b506104087f000000000000000000000000000000000000000000000000000000000000000081565b3480156107fe57600080fd5b5060165461066b9063ffffffff1681565b34801561081b57600080fd5b506003546104089061010090046001600160a01b031681565b34801561084057600080fd5b506103a661084f366004613012565b611699565b34801561086057600080fd5b50610869606481565b6040516001600160801b03909116815260200161041c565b34801561088d57600080fd5b5061047060095481565b3480156108a357600080fd5b506103a66108b2366004612ff7565b61174a565b3480156108c357600080fd5b506103a66108d2366004612ff7565b6117c1565b3480156108e357600080fd5b506103a66108f236600461333d565b611862565b34801561090357600080fd5b506103a66118da565b34801561091857600080fd5b506104706101f481565b34801561092e57600080fd5b5061047061093d366004613012565b60146020526000908152604090205481565b34801561095b57600080fd5b506103a661194a565b34801561097057600080fd5b5061047060125481565b34801561098657600080fd5b506001546001600160a01b0316610408565b3480156109a457600080fd5b506000546001600160a01b0316156104c9565b3480156109c357600080fd5b506103a66109d2366004612ff7565b611a35565b3480156109e357600080fd5b506103a6611b19565b3480156109f857600080fd5b50610708610470565b348015610a0d57600080fd5b506103a6610a1c366004613370565b611bd8565b348015610a2d57600080fd5b506103a6610a3c36600461303f565b611ceb565b348015610a4d57600080fd5b506103a6610a5c3660046133dc565b611dc4565b348015610a6d57600080fd5b50610470600b5481565b348015610a8357600080fd5b50610470610a9236600461303f565b600d6020526000908152604090205481565b3360009081526013602052604090205460ff16610adb57604051636d5595ef60e11b81523360048201526024015b60405180910390fd5b600c5460ff16610afe576040516383a941c560e01b815260040160405180910390fd5b81816005548282604051602001610b16929190613442565b6040516020818303038152906040528051906020012014610b4a5760405163c38e7eb160e01b815260040160405180910390fd5b610b52611ee0565b61070842048814610b795760405163bac5a76560e01b815260048101899052602401610ad2565b601254600114610b9c57604051631d026cf160e01b815260040160405180910390fd5b6000600a5443610bac919061346c565b60408051602081018b9052908101829052909150606001604051602081830303815290604052805190602001206012819055507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663ebf0c7176040518163ffffffff1660e01b8152600401602060405180830381865afa158015610c3d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c61919061347f565b888a7fa3ef5f102c5d4b3958ebddd5fc15de4c4da0bd714d6da2edab94dda2d00e220e848b8b8b8b604051610c9a959493929190613498565b60405180910390a4505050505050505050565b6000546001600160a01b03163314610cd8576040516311a8a1bb60e31b815260040160405180910390fd5b6001600160a01b038116600081815260136020526040808220805460ff19169055517fbab6b194452fd4fa50e0ca09bf0f89976da30a2b92fdf91372ad1a176d81e3289190a250565b6000546001600160a01b03163314610d4c576040516311a8a1bb60e31b815260040160405180910390fd5b610d54611f26565b610d5f600e82611f6f565b6040518181527fd2a17a10ab346c94fae909b2fbfa0fedaf30d08983e74dcc0a92be2c40c437f9906020015b60405180910390a150565b60068181548110610da657600080fd5b6000918252602090912001546001600160a01b0316905081565b610dc8611ee0565b601554600090815260146020526040902054601654610dec9063ffffffff1661132d565b6001600160a01b03166397b45353826040518263ffffffff1660e01b8152600401610e1991815260200190565b600060405180830381600087803b158015610e3357600080fd5b505af1158015610e47573d6000803e3d6000fd5b5050505050565b6000546001600160a01b03163314610e79576040516311a8a1bb60e31b815260040160405180910390fd5b6009548103610eb95760405162461bcd60e51b815260206004820152600c60248201526b2164656c6179426c6f636b7360a01b6044820152606401610ad2565b60095460408051918252602082018390527fef322fd61cb3d8514326f0b28140a92a29cd10996ad80d0671e43d2483464c1d910160405180910390a1600955565b6000546001600160a01b03163314610f25576040516311a8a1bb60e31b815260040160405180910390fd5b600b548103610f4757604051632d1150e160e11b815260040160405180910390fd5b600b5460408051918252602082018390527fdfad87ee418f8b636836b030634c8040055c9a5f641899df5a5d1d3c554fee47910160405180910390a1600b55565b6007548282604051602001610f9e9291906134f2565b6040516020818303038152906040528051906020012014610fef5760405162461bcd60e51b815260206004820152600b60248201526a21636f6e6e6563746f727360a81b6044820152606401610ad2565b5050565b63ffffffff81166000908152600860205260408120548082036110455760405162461bcd60e51b815260206004820152600a602482015269085cdd5c1c1bdc9d195960b21b6044820152606401610ad2565b61105060018261353e565b9392505050565b6000546001600160a01b03163314611082576040516311a8a1bb60e31b815260040160405180910390fd5b61108a611f26565b611092611fe0565b565b61109c611ee0565b6110a68585610f88565b8382811480156110b65750808251145b6110f45760405162461bcd60e51b815260206004820152600f60248201526e696e76616c6964206c656e6774687360881b6044820152606401610ad2565b600c5460ff16611109576111066114f1565b50505b6015546000908152601460205260408120549081900361113c5760405163e89b6b9f60e01b815260040160405180910390fd5b807f1a0dbd47cf73d4c161d809dd2b7955e46b3be4df5d0810afc2fbeeca1125e3e660055460405161117091815260200190565b60405180910390a2611186818888888888612032565b50505050505050565b6000546001600160a01b031633146111ba576040516311a8a1bb60e31b815260040160405180910390fd5b6016805463ffffffff191690556040517fba00effa0806904d44bcf9124dab4b3bb88a16e065682cb0621dc0924aaaef9d90600090a1565b6111fc8282611dc4565b6111868787878787611094565b6000546001600160a01b03163314611234576040516311a8a1bb60e31b815260040160405180910390fd5b63ffffffff811660009081526008602052604090205461126757604051636bc2867760e01b815260040160405180910390fd5b6016805463ffffffff191663ffffffff83169081179091556040519081527f741fa366ad8a97c31e0c702cff3583c3e7f5e9d09a1f295f786fa0762e1d0c8690602001610d8b565b600481815481106112bf57600080fd5b9060005260206000209060089182820401919006600402915054906101000a900463ffffffff1681565b6000546001600160a01b03163314611314576040516311a8a1bb60e31b815260040160405180910390fd5b6040516383c7055f60e01b815260040160405180910390fd5b6000600661133a83610ff3565b8154811061134a5761134a613551565b6000918252602090912001546001600160a01b031692915050565b6003546040516384785ecd60e01b81523360048201526101009091046001600160a01b0316906384785ecd90602401602060405180830381865afa1580156113b1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113d59190613567565b6113f15760405162461bcd60e51b8152600401610ad290613589565b6113f9611ee0565b61109261231c565b611409611ee0565b81336114148261132d565b6001600160a01b0316146114575760405162461bcd60e51b815260206004820152600a60248201526910b1b7b73732b1ba37b960b11b6044820152606401610ad2565b600c5460ff161561147b5760405163515f45f160e11b815260040160405180910390fd5b6000611488600e84612359565b6040805163ffffffff87168152602081018690526001600160801b0383168183015290519192507f1daad24ee1bf0bcc72ab681d29df86ec2794361b223da31f148b9f826cd135a8919081900360600190a150505050565b60006114ec600e6123cb565b905090565b6000806114fc611ee0565b60095460009061151090600e9060646123f5565b905080516000036115a5577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663c9b0a6de6040518163ffffffff1660e01b81526004016040805180830381865afa158015611578573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061159c91906135ab565b92509250509091565b6000807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166334a55ee6846040518263ffffffff1660e01b81526004016115f491906135ff565b60408051808303816000875af1158015611612573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061163691906135ab565b426000818152601460205260409081902084905560158290555192945090925083917f541aefdf3f12e63098ec1c2d20f1417537e559cfc90a3c53960fe09cd475515b916116879185918891613612565b60405180910390a29093509150509091565b6000546001600160a01b031633146116c4576040516311a8a1bb60e31b815260040160405180910390fd5b600b548110156116e75760405163e28adcd160e01b815260040160405180910390fd5b600a548103611709576040516346fee83f60e11b815260040160405180910390fd5b600a5460408051918252602082018390527fff74184d965d306545ebeb3283c4d7a39f453a9c0ea539db6437b33ceb9c5125910160405180910390a1600a55565b6000546001600160a01b03163314611775576040516311a8a1bb60e31b815260040160405180910390fd5b6001600160a01b038116600081815260136020526040808220805460ff19166001179055517f2bf05609716bc4b090ad0e99b47b91881c7517771259c625df05db7e9d8c81819190a250565b6000546001600160a01b031633146117ec576040516311a8a1bb60e31b815260040160405180910390fd5b6001546001600160a01b03828116911614801561180a575060025415155b15611828576040516311bc066560e11b815260040160405180910390fd5b6000546001600160a01b0380831691160361185657604051634a2fb73f60e11b815260040160405180910390fd5b61185f81612776565b50565b6000546001600160a01b0316331461188d576040516311a8a1bb60e31b815260040160405180910390fd5b61189782826127c4565b7f95ef69787290b89c35a092c89db1b283b43724d01263e683cfb560c758cdbe708282600460066040516118ce9493929190613801565b60405180910390a15050565b6001546001600160a01b03163314611905576040516311a7f27160e11b815260040160405180910390fd5b62093a8060025442611917919061353e565b11611935576040516324e0285f60e21b815260040160405180910390fd5b600154611092906001600160a01b03166129b0565b6003546040516384785ecd60e01b81523360048201526101009091046001600160a01b0316906384785ecd90602401602060405180830381865afa158015611996573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119ba9190613567565b6119d65760405162461bcd60e51b8152600401610ad290613589565b600c5460ff166119f9576040516383a941c560e01b815260040160405180910390fd5b600c805460ff19169055600160125560405133907f714b2723706f07835c1a61e679dc639438acf1e1d0bbae60d17e5a246a754d6e90600090a2565b6000546001600160a01b03163314611a60576040516311a8a1bb60e31b815260040160405180910390fd5b6003546001600160a01b03610100909104811690821603611ac35760405162461bcd60e51b815260206004820152601760248201527f616c72656164792077617463686572206d616e616765720000000000000000006044820152606401610ad2565b60038054610100600160a81b0319166101006001600160a01b038416908102919091179091556040519081527fc16d059e43d7f8e29ccb4e001a2f249d3c59e274925d6a6bc3912943441d9f6c90602001610d8b565b6000546001600160a01b03163314611b44576040516311a8a1bb60e31b815260040160405180910390fd5b600c5460ff1615611b6b5760405160016238010d60e21b0319815260040160405180910390fd5b600e54611b83906001906001600160801b031661384e565b600e80546001600160801b03928316600160801b029216919091179055600c805460ff191660011790556040517f46b91c03184b9c3d3422333019c7e56a3e8940f285463e754a526110287bd52190600090a1565b828114611c1a5760405162461bcd60e51b815260206004820152601060248201526f042dac2e8c6d0d2dcce40d8cadccee8d60831b6044820152606401610ad2565b6005548484604051602001611c30929190613442565b6040516020818303038152906040528051906020012014611c7e5760405162461bcd60e51b815260206004820152600860248201526721646f6d61696e7360c01b6044820152606401610ad2565b6007548282604051602001611c949291906134f2565b6040516020818303038152906040528051906020012014611ce55760405162461bcd60e51b815260206004820152600b60248201526a21636f6e6e6563746f727360a81b6044820152606401610ad2565b50505050565b6003546040516384785ecd60e01b81523360048201526101009091046001600160a01b0316906384785ecd90602401602060405180830381865afa158015611d37573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d5b9190613567565b611d775760405162461bcd60e51b8152600401610ad290613589565b6000611d8282612a15565b60016012556040519091507f6a1097f391a37dc63e0860e64ec34442971eeed2fda4d1a90141fa9ce25eb7eb906118ce90849084906004906006903390613875565b600c5460ff16611de7576040516383a941c560e01b815260040160405180910390fd5b611def611ee0565b6012546000198101611e1457604051636fcbb76f60e11b815260040160405180910390fd5b60408051602080820186905281830185905282518083038401815260609092019092528051910120818114611e5c5760405163ae4fc77d60e01b815260040160405180910390fd5b43831115611e7d5760405163bd24f2dd60e01b815260040160405180910390fd5b4260008181526014602052604090819020869055601582905560016012555185917f10979f09c442b2dfe17197e10366eb89a0dde719c4a0c0529b87e086ab3078c391611ecc91815260200190565b60405180910390a250505050565b60019055565b60035460ff16156110925760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b6044820152606401610ad2565b60035460ff166110925760405162461bcd60e51b815260206004820152601460248201527314185d5cd8589b194e881b9bdd081c185d5cd95960621b6044820152606401610ad2565b600081815260038301602052604090205460ff1615611fc25760405162461bcd60e51b815260206004820152600f60248201526e185b1c9958591e481c995b5bdd9959608a1b6044820152606401610ad2565b6000908152600390910160205260409020805460ff19166001179055565b611fe8611f26565b6003805460ff191690557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa335b6040516001600160a01b03909116815260200160405180910390a1565b346000805b63ffffffff81168711156122e3576000600d600060048463ffffffff168154811061206457612064613551565b90600052602060002090600891828204019190066004029054906101000a900463ffffffff1663ffffffff1663ffffffff1681526020019081526020016000205490508981036120b75750600101612037565b88888363ffffffff168181106120cf576120cf613551565b90506020020160208101906120e49190612ff7565b6001600160a01b03166348e6fa2388888563ffffffff1681811061210a5761210a613551565b905060200201358c60405160200161212491815260200190565b604051602081830303815290604052888663ffffffff168151811061214b5761214b613551565b60200260200101516040518463ffffffff1660e01b8152600401612170929190613911565b6000604051808303818588803b15801561218957600080fd5b505af19350505050801561219b575060015b612258577f51f2ef0ced5ef0ec14268d79d48589f9ccff35b2b0baf5059a90166caffea7a760048363ffffffff16815481106121d9576121d9613551565b90600052602060002090600891828204019190066004029054906101000a900463ffffffff168a8a8563ffffffff1681811061221757612217613551565b905060200201602081019061222c9190612ff7565b6040805163ffffffff90931683526001600160a01b0390911660208301520160405180910390a16122da565b86868363ffffffff1681811061227057612270613551565b9050602002013584612282919061353e565b93506001925089600d600060048563ffffffff16815481106122a6576122a6613551565b6000918252602080832060088304015460079092166004026101000a90910463ffffffff1683528201929092526040019020555b50600101612037565b508061230257604051634f05605360e11b815260040160405180910390fd5b8115612312576123123383612c8c565b5050505050505050565b612324611ee0565b6003805460ff191660011790557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a2586120153390565b81546000904390849060109061237e90600160801b90046001600160801b031661393f565b82546001600160801b038083166101009490940a84810291021990911617909255600090815260018601602090815260408083209690965560029096019095529290932092909255919050565b80546000906001600160801b03600160801b8204811691166123ed8282612daa565b949350505050565b82546060906001600160801b0380821691600160801b9004168181101561242e5750506040805160008152602081019091529050611050565b816001600160801b03166000036124775760405162461bcd60e51b815260206004820152600d60248201526c1c5d595d5948085a5b9a5d09d9609a1b6044820152606401610ad2565b6000846001600160801b0316116124c25760405162461bcd60e51b815260206004820152600f60248201526e042c2c6c6cae0e8c2c4d8ca40dac2f608b1b6044820152606401610ad2565b600060016124d08685613965565b6124da919061384e565b9050806001600160801b0316826001600160801b031611156124fa578091505b506000612507864361353e565b905060005b826001600160801b0316846001600160801b03161161255e576001600160801b038316600090815260028901602052604090205482811161255157600191505061255e565b506000199092019161250c565b8061257e5750506040805160008152602081019091529250611050915050565b60008461258c856001613965565b612596919061384e565b6001600160801b031667ffffffffffffffff8111156125b7576125b761309c565b6040519080825280602002602001820160405280156125e0578160200160208202803683370190505b5090506000805b856001600160801b0316876001600160801b03161161269f576001600160801b038716600090815260018c01602090815260408083205480845260038f019092529091205460ff1661265d578084848151811061264657612646613551565b602002602001018181525050826001019250612667565b8161266757600191505b506001600160801b038716600090815260018c81016020908152604080842084905560028f01909152822091909155909601956125e7565b8a546fffffffffffffffffffffffffffffffff19166001600160801b038816178b55806126d55782975050505050505050611050565b60008267ffffffffffffffff8111156126f0576126f061309c565b604051908082528060200260200182016040528015612719578160200160208202803683370190505b50905060005b838110156127665784818151811061273957612739613551565b602002602001015182828151811061275357612753613551565b602090810291909101015260010161271f565b5097506110509650505050505050565b42600255600180546001600160a01b0319166001600160a01b0383169081179091556040517f6ab4d119f23076e8ad491bc65ce85f017fb0591dce08755ba8591059cc51737a90600090a250565b63ffffffff8216600090815260086020526040902054156128175760405162461bcd60e51b815260206004820152600d60248201526c646f6d61696e2065786973747360981b6044820152606401610ad2565b6001600160a01b03811661285a5760405162461bcd60e51b815260206004820152600a60248201526910b1b7b73732b1ba37b960b11b6044820152606401610ad2565b6004546101f4116128ad5760405162461bcd60e51b815260206004820152601960248201527f446f6d61696e496e6465786572206174206361706163697479000000000000006044820152606401610ad2565b600480546001818101835560088083047f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b01805463ffffffff808916600790961687026101000a8681029102199091161790556006805492830190557ff652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d3f90910180546001600160a01b0386166001600160a01b03199091161790559154600091825260209290925260409020819055612964612dd4565b6040805163ffffffff851681526001600160a01b03841660208201527f4fc27362d8ab3086efd93b7880e99ac02e906d0ba9b71ca90239ade53090f703910160405180910390a1505050565b600080546040516001600160a01b03808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a3600080546001600160a01b039092166001600160a01b0319928316178155600255600180549091169055565b600080612a2183610ff3565b9050600060068281548110612a3857612a38613551565b6000918252602090912001546001600160a01b0316905080612a905760405162461bcd60e51b8152602060048201526011602482015270636f6e6e6563746f72202165786973747360781b6044820152606401610ad2565b600454600090612aa29060019061353e565b905080831015612bbb57600060048281548110612ac157612ac1613551565b90600052602060002090600891828204019190066004029054906101000a900463ffffffff1690508060048581548110612afd57612afd613551565b90600052602060002090600891828204019190066004026101000a81548163ffffffff021916908363ffffffff16021790555060068281548110612b4357612b43613551565b600091825260209091200154600680546001600160a01b039092169186908110612b6f57612b6f613551565b600091825260209091200180546001600160a01b0319166001600160a01b0392909216919091179055612ba384600161346c565b63ffffffff9091166000908152600860205260409020555b6004805480612bcc57612bcc613985565b600082815260209020600860001990920191820401805463ffffffff600460078516026101000a021916905590556006805480612c0b57612c0b613985565b60008281526020808220830160001990810180546001600160a01b031916905590920190925563ffffffff87168252600890526040812055612c4b612dd4565b60405163ffffffff861681527f7e560b48a4bba1688eb45afd6712a11fa42b9abbb48a8e14e2f15e467ab420e49060200160405180910390a1509392505050565b80471015612cdc5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a20696e73756666696369656e742062616c616e63650000006044820152606401610ad2565b6000826001600160a01b03168260405160006040518083038185875af1925050503d8060008114612d29576040519150601f19603f3d011682016040523d82523d6000602084013e612d2e565b606091505b5050905080612da55760405162461bcd60e51b815260206004820152603a60248201527f416464726573733a20756e61626c6520746f2073656e642076616c75652c207260448201527f6563697069656e74206d617920686176652072657665727465640000000000006064820152608401610ad2565b505050565b600081612db8846001613965565b612dc2919061384e565b6001600160801b031690505b92915050565b60006004805480602002602001604051908101604052809291908181526020018280548015612e4e57602002820191906000526020600020906000905b82829054906101000a900463ffffffff1663ffffffff1681526020019060040190602082600301049283019260010382029150808411612e115790505b5050505050905060006006805480602002602001604051908101604052809291908181526020018280548015612ead57602002820191906000526020600020905b81546001600160a01b03168152600190910190602001808311612e8f575b5050505050905081604051602001612ec5919061399b565b60408051601f19818403018152908290528051602091820120600555612eed918391016139e5565b60408051601f1981840301815291905280516020909101206007555050565b60008083601f840112612f1e57600080fd5b50813567ffffffffffffffff811115612f3657600080fd5b6020830191508360208260051b8501011115612f5157600080fd5b9250929050565b60008060008060008060808789031215612f7157600080fd5b8635955060208701359450604087013567ffffffffffffffff80821115612f9757600080fd5b612fa38a838b01612f0c565b90965094506060890135915080821115612fbc57600080fd5b50612fc989828a01612f0c565b979a9699509497509295939492505050565b80356001600160a01b0381168114612ff257600080fd5b919050565b60006020828403121561300957600080fd5b61105082612fdb565b60006020828403121561302457600080fd5b5035919050565b803563ffffffff81168114612ff257600080fd5b60006020828403121561305157600080fd5b6110508261302b565b6000806020838503121561306d57600080fd5b823567ffffffffffffffff81111561308457600080fd5b61309085828601612f0c565b90969095509350505050565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f1916810167ffffffffffffffff811182821017156130db576130db61309c565b604052919050565b6000601f83818401126130f557600080fd5b8235602067ffffffffffffffff808311156131125761311261309c565b8260051b6131218382016130b2565b938452868101830193838101908986111561313b57600080fd5b84890192505b858310156131cb578235848111156131595760008081fd5b8901603f81018b1361316b5760008081fd5b858101356040868211156131815761318161309c565b613192828b01601f191689016130b2565b8281528d828486010111156131a75760008081fd5b828285018a8301376000928101890192909252508352509184019190840190613141565b9998505050505050505050565b6000806000806000606086880312156131f057600080fd5b853567ffffffffffffffff8082111561320857600080fd5b61321489838a01612f0c565b9097509550602088013591508082111561322d57600080fd5b61323989838a01612f0c565b9095509350604088013591508082111561325257600080fd5b5061325f888289016130e3565b9150509295509295909350565b600080600080600080600060a0888a03121561328757600080fd5b873567ffffffffffffffff8082111561329f57600080fd5b6132ab8b838c01612f0c565b909950975060208a01359150808211156132c457600080fd5b6132d08b838c01612f0c565b909750955060408a01359150808211156132e957600080fd5b506132f68a828b016130e3565b935050606088013591506080880135905092959891949750929550565b6000806040838503121561332657600080fd5b61332f8361302b565b946020939093013593505050565b6000806040838503121561335057600080fd5b6133598361302b565b915061336760208401612fdb565b90509250929050565b6000806000806040858703121561338657600080fd5b843567ffffffffffffffff8082111561339e57600080fd5b6133aa88838901612f0c565b909650945060208701359150808211156133c357600080fd5b506133d087828801612f0c565b95989497509550505050565b600080604083850312156133ef57600080fd5b50508035926020909101359150565b8183526000602080850194508260005b858110156134375763ffffffff6134248361302b565b168752958201959082019060010161340e565b509495945050505050565b6020815260006123ed6020830184866133fe565b634e487b7160e01b600052601160045260246000fd5b80820180821115612dce57612dce613456565b60006020828403121561349157600080fd5b5051919050565b858152606060208201819052810184905260006001600160fb1b038511156134bf57600080fd5b8460051b808760808501378201828103608090810160408501526134e690820185876133fe565b98975050505050505050565b60208082528181018390526000908460408401835b86811015613533576001600160a01b0361352084612fdb565b1682529183019190830190600101613507565b509695505050505050565b81810381811115612dce57612dce613456565b634e487b7160e01b600052603260045260246000fd5b60006020828403121561357957600080fd5b8151801515811461105057600080fd5b60208082526008908201526710bbb0ba31b432b960c11b604082015260600190565b600080604083850312156135be57600080fd5b505080516020909101519092909150565b600081518084526020808501945080840160005b83811015613437578151875295820195908201906001016135e3565b60208152600061105060208301846135cf565b83815260606020820152600061362b60608301856135cf565b9050826040830152949350505050565b805480835260008281526020808220940193909190825b826007820110156136ca57815463ffffffff8082168852602082811c821690890152604082811c821690890152606082811c821690890152608082811c82169089015260a082811c82169089015260c082811c9091169088015260e090811c9087015261010090950194600190910190600801613652565b905490828110156136e85763ffffffff821686526020909501946001015b8281101561370857602082901c63ffffffff168652602095909501946001015b828110156137275763ffffffff604083901c1686526020909501946001015b828110156137465763ffffffff606083901c1686526020909501946001015b828110156137655763ffffffff608083901c1686526020909501946001015b828110156137845763ffffffff60a083901c1686526020909501946001015b828110156137a35763ffffffff60c083901c1686526020909501946001015b828110156137b95760e082901c86526020860195505b5093949350505050565b6000815480845260208085019450836000528060002060005b838110156134375781546001600160a01b0316875295820195600191820191016137dc565b63ffffffff851681526001600160a01b03841660208201526080604082018190526000906138319083018561363b565b828103606084015261384381856137c3565b979650505050505050565b6001600160801b0382811682821603908082111561386e5761386e613456565b5092915050565b63ffffffff86168152600060018060a01b03808716602084015260a060408401526138a360a084018761363b565b83810360608501526138b581876137c3565b9250508084166080840152509695505050505050565b6000815180845260005b818110156138f1576020818501810151868301820152016138d5565b506000602082860101526020601f19601f83011685010191505092915050565b60408152600061392460408301856138cb565b828103602084015261393681856138cb565b95945050505050565b60006001600160801b0380831681810361395b5761395b613456565b6001019392505050565b6001600160801b0381811683821601908082111561386e5761386e613456565b634e487b7160e01b600052603160045260246000fd5b6020808252825182820181905260009190848201906040850190845b818110156139d957835163ffffffff16835292840192918401916001016139b7565b50909695505050505050565b6020808252825182820181905260009190848201906040850190845b818110156139d95783516001600160a01b031683529284019291840191600101613a0156fea26469706673582212200d5e9c96bcafc43636f113e0b7dcfb7f97a9c11ec78cb79bb5805797364caed964736f6c63430008110033",
  "deployedBytecode": "0x6080604052600436106103815760003560e01c80638456cb59116101d1578063c5b350df11610102578063d2a3cc71116100a0578063e6f1208d1161006f578063e6f1208d14610a21578063e9812d7114610a41578063f4b6e41014610a61578063f715589a14610a7757600080fd5b8063d2a3cc71146109b7578063d3c54fe5146109d7578063d3c805b7146109ec578063db0f016914610a0157600080fd5b8063cbfa2021116100dc578063cbfa20211461094f578063ceb3454e14610964578063d1851c921461097a578063d232c2201461099857600080fd5b8063c5b350df146108f7578063c8ef89de1461090c578063c92930561461092257600080fd5b8063a792c29b1161016f578063ad9c0c2e11610149578063ad9c0c2e14610881578063b03cd41814610897578063b1f8100d146108b7578063b904670f146108d757600080fd5b8063a792c29b1461080f578063a941f3f314610834578063aa0d60a31461085457600080fd5b8063909907cb116101ab578063909907cb1461077f578063957908d114610794578063a01892a5146107be578063a226b2cb146107f257600080fd5b80638456cb591461072c5780638da5cb5b146107415780638e7d93fa1461075f57600080fd5b8063412e12db116102b65780635ffe699d11610254578063715018a611610223578063715018a6146106965780637bc24d99146106ab5780637d434e91146106c15780637d534308146106e157600080fd5b80635ffe699d1461061157806360caf7a01461063157806366cf8fab1461064b5780636a42b8f81461068057600080fd5b8063498c2c2e11610290578063498c2c2e1461059e5780634a2db1da146105b45780635c975abb146105e45780635d308761146105fc57600080fd5b8063412e12db14610563578063460508b414610576578063492a96f41461058b57600080fd5b806324825b0d1161032357806327186c6a116102fd57806327186c6a146104f95780633c4baaf8146105195780633cf52ffb146105395780633f4ba83a1461054e57600080fd5b806324825b0d1461047e57806324ec5d0514610494578063263ef354146104d957600080fd5b806313ede1a11161035f57806313ede1a1146103e857806315fa23bc146104255780631eeaabea1461043a57806320f62eda1461045a57600080fd5b8063089200391461038657806309d632d3146103a85780630f8ef4ee146103c8575b600080fd5b34801561039257600080fd5b506103a66103a1366004612f58565b610aa4565b005b3480156103b457600080fd5b506103a66103c3366004612ff7565b610cad565b3480156103d457600080fd5b506103a66103e3366004613012565b610d21565b3480156103f457600080fd5b50610408610403366004613012565b610d96565b6040516001600160a01b0390911681526020015b60405180910390f35b34801561043157600080fd5b506103a6610dc0565b34801561044657600080fd5b506103a6610455366004613012565b610e4e565b34801561046657600080fd5b50610470600a5481565b60405190815260200161041c565b34801561048a57600080fd5b5061047060155481565b3480156104a057600080fd5b506104c96104af36600461303f565b63ffffffff16600090815260086020526040902054151590565b604051901515815260200161041c565b3480156104e557600080fd5b506103a66104f4366004613012565b610efa565b34801561050557600080fd5b506103a661051436600461305a565b610f88565b34801561052557600080fd5b5061047061053436600461303f565b610ff3565b34801561054557600080fd5b50600254610470565b34801561055a57600080fd5b506103a6611057565b6103a66105713660046131d8565b611094565b34801561058257600080fd5b506103a661118f565b6103a661059936600461326c565b6111f2565b3480156105aa57600080fd5b5061047060075481565b3480156105c057600080fd5b506104c96105cf366004612ff7565b60136020526000908152604090205460ff1681565b3480156105f057600080fd5b5060035460ff166104c9565b34801561060857600080fd5b50610470600181565b34801561061d57600080fd5b506103a661062c36600461303f565b611209565b34801561063d57600080fd5b50600c546104c99060ff1681565b34801561065757600080fd5b5061066b610666366004613012565b6112af565b60405163ffffffff909116815260200161041c565b34801561068c57600080fd5b5062093a80610470565b3480156106a257600080fd5b506103a66112e9565b3480156106b757600080fd5b5061047060055481565b3480156106cd57600080fd5b506104086106dc36600461303f565b61132d565b3480156106ed57600080fd5b50600e5461070c906001600160801b0380821691600160801b90041682565b604080516001600160801b0393841681529290911660208301520161041c565b34801561073857600080fd5b506103a6611365565b34801561074d57600080fd5b506000546001600160a01b0316610408565b34801561076b57600080fd5b506103a661077a366004613313565b611401565b34801561078b57600080fd5b506104706114e0565b3480156107a057600080fd5b506107a96114f1565b6040805192835260208301919091520161041c565b3480156107ca57600080fd5b506104087f000000000000000000000000000000000000000000000000000000000000000081565b3480156107fe57600080fd5b5060165461066b9063ffffffff1681565b34801561081b57600080fd5b506003546104089061010090046001600160a01b031681565b34801561084057600080fd5b506103a661084f366004613012565b611699565b34801561086057600080fd5b50610869606481565b6040516001600160801b03909116815260200161041c565b34801561088d57600080fd5b5061047060095481565b3480156108a357600080fd5b506103a66108b2366004612ff7565b61174a565b3480156108c357600080fd5b506103a66108d2366004612ff7565b6117c1565b3480156108e357600080fd5b506103a66108f236600461333d565b611862565b34801561090357600080fd5b506103a66118da565b34801561091857600080fd5b506104706101f481565b34801561092e57600080fd5b5061047061093d366004613012565b60146020526000908152604090205481565b34801561095b57600080fd5b506103a661194a565b34801561097057600080fd5b5061047060125481565b34801561098657600080fd5b506001546001600160a01b0316610408565b3480156109a457600080fd5b506000546001600160a01b0316156104c9565b3480156109c357600080fd5b506103a66109d2366004612ff7565b611a35565b3480156109e357600080fd5b506103a6611b19565b3480156109f857600080fd5b50610708610470565b348015610a0d57600080fd5b506103a6610a1c366004613370565b611bd8565b348015610a2d57600080fd5b506103a6610a3c36600461303f565b611ceb565b348015610a4d57600080fd5b506103a6610a5c3660046133dc565b611dc4565b348015610a6d57600080fd5b50610470600b5481565b348015610a8357600080fd5b50610470610a9236600461303f565b600d6020526000908152604090205481565b3360009081526013602052604090205460ff16610adb57604051636d5595ef60e11b81523360048201526024015b60405180910390fd5b600c5460ff16610afe576040516383a941c560e01b815260040160405180910390fd5b81816005548282604051602001610b16929190613442565b6040516020818303038152906040528051906020012014610b4a5760405163c38e7eb160e01b815260040160405180910390fd5b610b52611ee0565b61070842048814610b795760405163bac5a76560e01b815260048101899052602401610ad2565b601254600114610b9c57604051631d026cf160e01b815260040160405180910390fd5b6000600a5443610bac919061346c565b60408051602081018b9052908101829052909150606001604051602081830303815290604052805190602001206012819055507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663ebf0c7176040518163ffffffff1660e01b8152600401602060405180830381865afa158015610c3d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c61919061347f565b888a7fa3ef5f102c5d4b3958ebddd5fc15de4c4da0bd714d6da2edab94dda2d00e220e848b8b8b8b604051610c9a959493929190613498565b60405180910390a4505050505050505050565b6000546001600160a01b03163314610cd8576040516311a8a1bb60e31b815260040160405180910390fd5b6001600160a01b038116600081815260136020526040808220805460ff19169055517fbab6b194452fd4fa50e0ca09bf0f89976da30a2b92fdf91372ad1a176d81e3289190a250565b6000546001600160a01b03163314610d4c576040516311a8a1bb60e31b815260040160405180910390fd5b610d54611f26565b610d5f600e82611f6f565b6040518181527fd2a17a10ab346c94fae909b2fbfa0fedaf30d08983e74dcc0a92be2c40c437f9906020015b60405180910390a150565b60068181548110610da657600080fd5b6000918252602090912001546001600160a01b0316905081565b610dc8611ee0565b601554600090815260146020526040902054601654610dec9063ffffffff1661132d565b6001600160a01b03166397b45353826040518263ffffffff1660e01b8152600401610e1991815260200190565b600060405180830381600087803b158015610e3357600080fd5b505af1158015610e47573d6000803e3d6000fd5b5050505050565b6000546001600160a01b03163314610e79576040516311a8a1bb60e31b815260040160405180910390fd5b6009548103610eb95760405162461bcd60e51b815260206004820152600c60248201526b2164656c6179426c6f636b7360a01b6044820152606401610ad2565b60095460408051918252602082018390527fef322fd61cb3d8514326f0b28140a92a29cd10996ad80d0671e43d2483464c1d910160405180910390a1600955565b6000546001600160a01b03163314610f25576040516311a8a1bb60e31b815260040160405180910390fd5b600b548103610f4757604051632d1150e160e11b815260040160405180910390fd5b600b5460408051918252602082018390527fdfad87ee418f8b636836b030634c8040055c9a5f641899df5a5d1d3c554fee47910160405180910390a1600b55565b6007548282604051602001610f9e9291906134f2565b6040516020818303038152906040528051906020012014610fef5760405162461bcd60e51b815260206004820152600b60248201526a21636f6e6e6563746f727360a81b6044820152606401610ad2565b5050565b63ffffffff81166000908152600860205260408120548082036110455760405162461bcd60e51b815260206004820152600a602482015269085cdd5c1c1bdc9d195960b21b6044820152606401610ad2565b61105060018261353e565b9392505050565b6000546001600160a01b03163314611082576040516311a8a1bb60e31b815260040160405180910390fd5b61108a611f26565b611092611fe0565b565b61109c611ee0565b6110a68585610f88565b8382811480156110b65750808251145b6110f45760405162461bcd60e51b815260206004820152600f60248201526e696e76616c6964206c656e6774687360881b6044820152606401610ad2565b600c5460ff16611109576111066114f1565b50505b6015546000908152601460205260408120549081900361113c5760405163e89b6b9f60e01b815260040160405180910390fd5b807f1a0dbd47cf73d4c161d809dd2b7955e46b3be4df5d0810afc2fbeeca1125e3e660055460405161117091815260200190565b60405180910390a2611186818888888888612032565b50505050505050565b6000546001600160a01b031633146111ba576040516311a8a1bb60e31b815260040160405180910390fd5b6016805463ffffffff191690556040517fba00effa0806904d44bcf9124dab4b3bb88a16e065682cb0621dc0924aaaef9d90600090a1565b6111fc8282611dc4565b6111868787878787611094565b6000546001600160a01b03163314611234576040516311a8a1bb60e31b815260040160405180910390fd5b63ffffffff811660009081526008602052604090205461126757604051636bc2867760e01b815260040160405180910390fd5b6016805463ffffffff191663ffffffff83169081179091556040519081527f741fa366ad8a97c31e0c702cff3583c3e7f5e9d09a1f295f786fa0762e1d0c8690602001610d8b565b600481815481106112bf57600080fd5b9060005260206000209060089182820401919006600402915054906101000a900463ffffffff1681565b6000546001600160a01b03163314611314576040516311a8a1bb60e31b815260040160405180910390fd5b6040516383c7055f60e01b815260040160405180910390fd5b6000600661133a83610ff3565b8154811061134a5761134a613551565b6000918252602090912001546001600160a01b031692915050565b6003546040516384785ecd60e01b81523360048201526101009091046001600160a01b0316906384785ecd90602401602060405180830381865afa1580156113b1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113d59190613567565b6113f15760405162461bcd60e51b8152600401610ad290613589565b6113f9611ee0565b61109261231c565b611409611ee0565b81336114148261132d565b6001600160a01b0316146114575760405162461bcd60e51b815260206004820152600a60248201526910b1b7b73732b1ba37b960b11b6044820152606401610ad2565b600c5460ff161561147b5760405163515f45f160e11b815260040160405180910390fd5b6000611488600e84612359565b6040805163ffffffff87168152602081018690526001600160801b0383168183015290519192507f1daad24ee1bf0bcc72ab681d29df86ec2794361b223da31f148b9f826cd135a8919081900360600190a150505050565b60006114ec600e6123cb565b905090565b6000806114fc611ee0565b60095460009061151090600e9060646123f5565b905080516000036115a5577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663c9b0a6de6040518163ffffffff1660e01b81526004016040805180830381865afa158015611578573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061159c91906135ab565b92509250509091565b6000807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166334a55ee6846040518263ffffffff1660e01b81526004016115f491906135ff565b60408051808303816000875af1158015611612573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061163691906135ab565b426000818152601460205260409081902084905560158290555192945090925083917f541aefdf3f12e63098ec1c2d20f1417537e559cfc90a3c53960fe09cd475515b916116879185918891613612565b60405180910390a29093509150509091565b6000546001600160a01b031633146116c4576040516311a8a1bb60e31b815260040160405180910390fd5b600b548110156116e75760405163e28adcd160e01b815260040160405180910390fd5b600a548103611709576040516346fee83f60e11b815260040160405180910390fd5b600a5460408051918252602082018390527fff74184d965d306545ebeb3283c4d7a39f453a9c0ea539db6437b33ceb9c5125910160405180910390a1600a55565b6000546001600160a01b03163314611775576040516311a8a1bb60e31b815260040160405180910390fd5b6001600160a01b038116600081815260136020526040808220805460ff19166001179055517f2bf05609716bc4b090ad0e99b47b91881c7517771259c625df05db7e9d8c81819190a250565b6000546001600160a01b031633146117ec576040516311a8a1bb60e31b815260040160405180910390fd5b6001546001600160a01b03828116911614801561180a575060025415155b15611828576040516311bc066560e11b815260040160405180910390fd5b6000546001600160a01b0380831691160361185657604051634a2fb73f60e11b815260040160405180910390fd5b61185f81612776565b50565b6000546001600160a01b0316331461188d576040516311a8a1bb60e31b815260040160405180910390fd5b61189782826127c4565b7f95ef69787290b89c35a092c89db1b283b43724d01263e683cfb560c758cdbe708282600460066040516118ce9493929190613801565b60405180910390a15050565b6001546001600160a01b03163314611905576040516311a7f27160e11b815260040160405180910390fd5b62093a8060025442611917919061353e565b11611935576040516324e0285f60e21b815260040160405180910390fd5b600154611092906001600160a01b03166129b0565b6003546040516384785ecd60e01b81523360048201526101009091046001600160a01b0316906384785ecd90602401602060405180830381865afa158015611996573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119ba9190613567565b6119d65760405162461bcd60e51b8152600401610ad290613589565b600c5460ff166119f9576040516383a941c560e01b815260040160405180910390fd5b600c805460ff19169055600160125560405133907f714b2723706f07835c1a61e679dc639438acf1e1d0bbae60d17e5a246a754d6e90600090a2565b6000546001600160a01b03163314611a60576040516311a8a1bb60e31b815260040160405180910390fd5b6003546001600160a01b03610100909104811690821603611ac35760405162461bcd60e51b815260206004820152601760248201527f616c72656164792077617463686572206d616e616765720000000000000000006044820152606401610ad2565b60038054610100600160a81b0319166101006001600160a01b038416908102919091179091556040519081527fc16d059e43d7f8e29ccb4e001a2f249d3c59e274925d6a6bc3912943441d9f6c90602001610d8b565b6000546001600160a01b03163314611b44576040516311a8a1bb60e31b815260040160405180910390fd5b600c5460ff1615611b6b5760405160016238010d60e21b0319815260040160405180910390fd5b600e54611b83906001906001600160801b031661384e565b600e80546001600160801b03928316600160801b029216919091179055600c805460ff191660011790556040517f46b91c03184b9c3d3422333019c7e56a3e8940f285463e754a526110287bd52190600090a1565b828114611c1a5760405162461bcd60e51b815260206004820152601060248201526f042dac2e8c6d0d2dcce40d8cadccee8d60831b6044820152606401610ad2565b6005548484604051602001611c30929190613442565b6040516020818303038152906040528051906020012014611c7e5760405162461bcd60e51b815260206004820152600860248201526721646f6d61696e7360c01b6044820152606401610ad2565b6007548282604051602001611c949291906134f2565b6040516020818303038152906040528051906020012014611ce55760405162461bcd60e51b815260206004820152600b60248201526a21636f6e6e6563746f727360a81b6044820152606401610ad2565b50505050565b6003546040516384785ecd60e01b81523360048201526101009091046001600160a01b0316906384785ecd90602401602060405180830381865afa158015611d37573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d5b9190613567565b611d775760405162461bcd60e51b8152600401610ad290613589565b6000611d8282612a15565b60016012556040519091507f6a1097f391a37dc63e0860e64ec34442971eeed2fda4d1a90141fa9ce25eb7eb906118ce90849084906004906006903390613875565b600c5460ff16611de7576040516383a941c560e01b815260040160405180910390fd5b611def611ee0565b6012546000198101611e1457604051636fcbb76f60e11b815260040160405180910390fd5b60408051602080820186905281830185905282518083038401815260609092019092528051910120818114611e5c5760405163ae4fc77d60e01b815260040160405180910390fd5b43831115611e7d5760405163bd24f2dd60e01b815260040160405180910390fd5b4260008181526014602052604090819020869055601582905560016012555185917f10979f09c442b2dfe17197e10366eb89a0dde719c4a0c0529b87e086ab3078c391611ecc91815260200190565b60405180910390a250505050565b60019055565b60035460ff16156110925760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b6044820152606401610ad2565b60035460ff166110925760405162461bcd60e51b815260206004820152601460248201527314185d5cd8589b194e881b9bdd081c185d5cd95960621b6044820152606401610ad2565b600081815260038301602052604090205460ff1615611fc25760405162461bcd60e51b815260206004820152600f60248201526e185b1c9958591e481c995b5bdd9959608a1b6044820152606401610ad2565b6000908152600390910160205260409020805460ff19166001179055565b611fe8611f26565b6003805460ff191690557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa335b6040516001600160a01b03909116815260200160405180910390a1565b346000805b63ffffffff81168711156122e3576000600d600060048463ffffffff168154811061206457612064613551565b90600052602060002090600891828204019190066004029054906101000a900463ffffffff1663ffffffff1663ffffffff1681526020019081526020016000205490508981036120b75750600101612037565b88888363ffffffff168181106120cf576120cf613551565b90506020020160208101906120e49190612ff7565b6001600160a01b03166348e6fa2388888563ffffffff1681811061210a5761210a613551565b905060200201358c60405160200161212491815260200190565b604051602081830303815290604052888663ffffffff168151811061214b5761214b613551565b60200260200101516040518463ffffffff1660e01b8152600401612170929190613911565b6000604051808303818588803b15801561218957600080fd5b505af19350505050801561219b575060015b612258577f51f2ef0ced5ef0ec14268d79d48589f9ccff35b2b0baf5059a90166caffea7a760048363ffffffff16815481106121d9576121d9613551565b90600052602060002090600891828204019190066004029054906101000a900463ffffffff168a8a8563ffffffff1681811061221757612217613551565b905060200201602081019061222c9190612ff7565b6040805163ffffffff90931683526001600160a01b0390911660208301520160405180910390a16122da565b86868363ffffffff1681811061227057612270613551565b9050602002013584612282919061353e565b93506001925089600d600060048563ffffffff16815481106122a6576122a6613551565b6000918252602080832060088304015460079092166004026101000a90910463ffffffff1683528201929092526040019020555b50600101612037565b508061230257604051634f05605360e11b815260040160405180910390fd5b8115612312576123123383612c8c565b5050505050505050565b612324611ee0565b6003805460ff191660011790557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a2586120153390565b81546000904390849060109061237e90600160801b90046001600160801b031661393f565b82546001600160801b038083166101009490940a84810291021990911617909255600090815260018601602090815260408083209690965560029096019095529290932092909255919050565b80546000906001600160801b03600160801b8204811691166123ed8282612daa565b949350505050565b82546060906001600160801b0380821691600160801b9004168181101561242e5750506040805160008152602081019091529050611050565b816001600160801b03166000036124775760405162461bcd60e51b815260206004820152600d60248201526c1c5d595d5948085a5b9a5d09d9609a1b6044820152606401610ad2565b6000846001600160801b0316116124c25760405162461bcd60e51b815260206004820152600f60248201526e042c2c6c6cae0e8c2c4d8ca40dac2f608b1b6044820152606401610ad2565b600060016124d08685613965565b6124da919061384e565b9050806001600160801b0316826001600160801b031611156124fa578091505b506000612507864361353e565b905060005b826001600160801b0316846001600160801b03161161255e576001600160801b038316600090815260028901602052604090205482811161255157600191505061255e565b506000199092019161250c565b8061257e5750506040805160008152602081019091529250611050915050565b60008461258c856001613965565b612596919061384e565b6001600160801b031667ffffffffffffffff8111156125b7576125b761309c565b6040519080825280602002602001820160405280156125e0578160200160208202803683370190505b5090506000805b856001600160801b0316876001600160801b03161161269f576001600160801b038716600090815260018c01602090815260408083205480845260038f019092529091205460ff1661265d578084848151811061264657612646613551565b602002602001018181525050826001019250612667565b8161266757600191505b506001600160801b038716600090815260018c81016020908152604080842084905560028f01909152822091909155909601956125e7565b8a546fffffffffffffffffffffffffffffffff19166001600160801b038816178b55806126d55782975050505050505050611050565b60008267ffffffffffffffff8111156126f0576126f061309c565b604051908082528060200260200182016040528015612719578160200160208202803683370190505b50905060005b838110156127665784818151811061273957612739613551565b602002602001015182828151811061275357612753613551565b602090810291909101015260010161271f565b5097506110509650505050505050565b42600255600180546001600160a01b0319166001600160a01b0383169081179091556040517f6ab4d119f23076e8ad491bc65ce85f017fb0591dce08755ba8591059cc51737a90600090a250565b63ffffffff8216600090815260086020526040902054156128175760405162461bcd60e51b815260206004820152600d60248201526c646f6d61696e2065786973747360981b6044820152606401610ad2565b6001600160a01b03811661285a5760405162461bcd60e51b815260206004820152600a60248201526910b1b7b73732b1ba37b960b11b6044820152606401610ad2565b6004546101f4116128ad5760405162461bcd60e51b815260206004820152601960248201527f446f6d61696e496e6465786572206174206361706163697479000000000000006044820152606401610ad2565b600480546001818101835560088083047f8a35acfbc15ff81a39ae7d344fd709f28e8600b4aa8c65c6b64bfe7fe36bd19b01805463ffffffff808916600790961687026101000a8681029102199091161790556006805492830190557ff652222313e28459528d920b65115c16c04f3efc82aaedc97be59f3f377c0d3f90910180546001600160a01b0386166001600160a01b03199091161790559154600091825260209290925260409020819055612964612dd4565b6040805163ffffffff851681526001600160a01b03841660208201527f4fc27362d8ab3086efd93b7880e99ac02e906d0ba9b71ca90239ade53090f703910160405180910390a1505050565b600080546040516001600160a01b03808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a3600080546001600160a01b039092166001600160a01b0319928316178155600255600180549091169055565b600080612a2183610ff3565b9050600060068281548110612a3857612a38613551565b6000918252602090912001546001600160a01b0316905080612a905760405162461bcd60e51b8152602060048201526011602482015270636f6e6e6563746f72202165786973747360781b6044820152606401610ad2565b600454600090612aa29060019061353e565b905080831015612bbb57600060048281548110612ac157612ac1613551565b90600052602060002090600891828204019190066004029054906101000a900463ffffffff1690508060048581548110612afd57612afd613551565b90600052602060002090600891828204019190066004026101000a81548163ffffffff021916908363ffffffff16021790555060068281548110612b4357612b43613551565b600091825260209091200154600680546001600160a01b039092169186908110612b6f57612b6f613551565b600091825260209091200180546001600160a01b0319166001600160a01b0392909216919091179055612ba384600161346c565b63ffffffff9091166000908152600860205260409020555b6004805480612bcc57612bcc613985565b600082815260209020600860001990920191820401805463ffffffff600460078516026101000a021916905590556006805480612c0b57612c0b613985565b60008281526020808220830160001990810180546001600160a01b031916905590920190925563ffffffff87168252600890526040812055612c4b612dd4565b60405163ffffffff861681527f7e560b48a4bba1688eb45afd6712a11fa42b9abbb48a8e14e2f15e467ab420e49060200160405180910390a1509392505050565b80471015612cdc5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a20696e73756666696369656e742062616c616e63650000006044820152606401610ad2565b6000826001600160a01b03168260405160006040518083038185875af1925050503d8060008114612d29576040519150601f19603f3d011682016040523d82523d6000602084013e612d2e565b606091505b5050905080612da55760405162461bcd60e51b815260206004820152603a60248201527f416464726573733a20756e61626c6520746f2073656e642076616c75652c207260448201527f6563697069656e74206d617920686176652072657665727465640000000000006064820152608401610ad2565b505050565b600081612db8846001613965565b612dc2919061384e565b6001600160801b031690505b92915050565b60006004805480602002602001604051908101604052809291908181526020018280548015612e4e57602002820191906000526020600020906000905b82829054906101000a900463ffffffff1663ffffffff1681526020019060040190602082600301049283019260010382029150808411612e115790505b5050505050905060006006805480602002602001604051908101604052809291908181526020018280548015612ead57602002820191906000526020600020905b81546001600160a01b03168152600190910190602001808311612e8f575b5050505050905081604051602001612ec5919061399b565b60408051601f19818403018152908290528051602091820120600555612eed918391016139e5565b60408051601f1981840301815291905280516020909101206007555050565b60008083601f840112612f1e57600080fd5b50813567ffffffffffffffff811115612f3657600080fd5b6020830191508360208260051b8501011115612f5157600080fd5b9250929050565b60008060008060008060808789031215612f7157600080fd5b8635955060208701359450604087013567ffffffffffffffff80821115612f9757600080fd5b612fa38a838b01612f0c565b90965094506060890135915080821115612fbc57600080fd5b50612fc989828a01612f0c565b979a9699509497509295939492505050565b80356001600160a01b0381168114612ff257600080fd5b919050565b60006020828403121561300957600080fd5b61105082612fdb565b60006020828403121561302457600080fd5b5035919050565b803563ffffffff81168114612ff257600080fd5b60006020828403121561305157600080fd5b6110508261302b565b6000806020838503121561306d57600080fd5b823567ffffffffffffffff81111561308457600080fd5b61309085828601612f0c565b90969095509350505050565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f1916810167ffffffffffffffff811182821017156130db576130db61309c565b604052919050565b6000601f83818401126130f557600080fd5b8235602067ffffffffffffffff808311156131125761311261309c565b8260051b6131218382016130b2565b938452868101830193838101908986111561313b57600080fd5b84890192505b858310156131cb578235848111156131595760008081fd5b8901603f81018b1361316b5760008081fd5b858101356040868211156131815761318161309c565b613192828b01601f191689016130b2565b8281528d828486010111156131a75760008081fd5b828285018a8301376000928101890192909252508352509184019190840190613141565b9998505050505050505050565b6000806000806000606086880312156131f057600080fd5b853567ffffffffffffffff8082111561320857600080fd5b61321489838a01612f0c565b9097509550602088013591508082111561322d57600080fd5b61323989838a01612f0c565b9095509350604088013591508082111561325257600080fd5b5061325f888289016130e3565b9150509295509295909350565b600080600080600080600060a0888a03121561328757600080fd5b873567ffffffffffffffff8082111561329f57600080fd5b6132ab8b838c01612f0c565b909950975060208a01359150808211156132c457600080fd5b6132d08b838c01612f0c565b909750955060408a01359150808211156132e957600080fd5b506132f68a828b016130e3565b935050606088013591506080880135905092959891949750929550565b6000806040838503121561332657600080fd5b61332f8361302b565b946020939093013593505050565b6000806040838503121561335057600080fd5b6133598361302b565b915061336760208401612fdb565b90509250929050565b6000806000806040858703121561338657600080fd5b843567ffffffffffffffff8082111561339e57600080fd5b6133aa88838901612f0c565b909650945060208701359150808211156133c357600080fd5b506133d087828801612f0c565b95989497509550505050565b600080604083850312156133ef57600080fd5b50508035926020909101359150565b8183526000602080850194508260005b858110156134375763ffffffff6134248361302b565b168752958201959082019060010161340e565b509495945050505050565b6020815260006123ed6020830184866133fe565b634e487b7160e01b600052601160045260246000fd5b80820180821115612dce57612dce613456565b60006020828403121561349157600080fd5b5051919050565b858152606060208201819052810184905260006001600160fb1b038511156134bf57600080fd5b8460051b808760808501378201828103608090810160408501526134e690820185876133fe565b98975050505050505050565b60208082528181018390526000908460408401835b86811015613533576001600160a01b0361352084612fdb565b1682529183019190830190600101613507565b509695505050505050565b81810381811115612dce57612dce613456565b634e487b7160e01b600052603260045260246000fd5b60006020828403121561357957600080fd5b8151801515811461105057600080fd5b60208082526008908201526710bbb0ba31b432b960c11b604082015260600190565b600080604083850312156135be57600080fd5b505080516020909101519092909150565b600081518084526020808501945080840160005b83811015613437578151875295820195908201906001016135e3565b60208152600061105060208301846135cf565b83815260606020820152600061362b60608301856135cf565b9050826040830152949350505050565b805480835260008281526020808220940193909190825b826007820110156136ca57815463ffffffff8082168852602082811c821690890152604082811c821690890152606082811c821690890152608082811c82169089015260a082811c82169089015260c082811c9091169088015260e090811c9087015261010090950194600190910190600801613652565b905490828110156136e85763ffffffff821686526020909501946001015b8281101561370857602082901c63ffffffff168652602095909501946001015b828110156137275763ffffffff604083901c1686526020909501946001015b828110156137465763ffffffff606083901c1686526020909501946001015b828110156137655763ffffffff608083901c1686526020909501946001015b828110156137845763ffffffff60a083901c1686526020909501946001015b828110156137a35763ffffffff60c083901c1686526020909501946001015b828110156137b95760e082901c86526020860195505b5093949350505050565b6000815480845260208085019450836000528060002060005b838110156134375781546001600160a01b0316875295820195600191820191016137dc565b63ffffffff851681526001600160a01b03841660208201526080604082018190526000906138319083018561363b565b828103606084015261384381856137c3565b979650505050505050565b6001600160801b0382811682821603908082111561386e5761386e613456565b5092915050565b63ffffffff86168152600060018060a01b03808716602084015260a060408401526138a360a084018761363b565b83810360608501526138b581876137c3565b9250508084166080840152509695505050505050565b6000815180845260005b818110156138f1576020818501810151868301820152016138d5565b506000602082860101526020601f19601f83011685010191505092915050565b60408152600061392460408301856138cb565b828103602084015261393681856138cb565b95945050505050565b60006001600160801b0380831681810361395b5761395b613456565b6001019392505050565b6001600160801b0381811683821601908082111561386e5761386e613456565b634e487b7160e01b600052603160045260246000fd5b6020808252825182820181905260009190848201906040850190845b818110156139d957835163ffffffff16835292840192918401916001016139b7565b50909695505050505050565b6020808252825182820181905260009190848201906040850190845b818110156139d95783516001600160a01b031683529284019291840191600101613a0156fea26469706673582212200d5e9c96bcafc43636f113e0b7dcfb7f97a9c11ec78cb79bb5805797364caed964736f6c63430008110033",
  "devdoc": {
    "events": {
      "AggregateRootPropagated(bytes32,bytes32)": {
        "details": "It doesnt matter if the root was generated optimistically or on-chain.",
        "params": {
          "aggregateRoot": "The aggregate root propagated",
          "domainsHash": "The current domain hash"
        }
      },
      "AggregateRootProposed(uint256,uint256,bytes32,bytes32,bytes32[],uint32[])": {
        "params": {
          "aggregateRoot": "The new aggregate root proposed",
          "baseRoot": "The root of the tree before the snapshot roots were inserted by proposer",
          "domains": "The list of all domains",
          "endOfDispute": "The block at which the dispute period is over",
          "snapshotId": "The snapshot id",
          "snapshotsRoots": "The list of roots added to aggregate tree"
        }
      },
      "AggregateRootSavedOptimistic(bytes32,uint256)": {
        "params": {
          "aggregateRoot": "The saved aggregate root",
          "rootTimestamp": "The timestamp at which the aggregate root was saved."
        }
      },
      "AggregateRootSavedSlow(bytes32,uint256,bytes32[],uint256)": {
        "params": {
          "aggregateRoot": "The saved aggregate root",
          "aggregatedRoots": "The verified inbound roots inserted in the tree.",
          "leafCount": "The new number of leaves in the tree.",
          "rootTimestamp": "The timestamp at which the aggregate root was saved."
        }
      },
      "HubDomainSet(uint32)": {
        "params": {
          "domain": "The domain set as hub domain."
        }
      },
      "ProposerAdded(address)": {
        "params": {
          "proposer": "The address of the proposer"
        }
      },
      "ProposerRemoved(address)": {
        "params": {
          "proposer": "The address of the proposer"
        }
      },
      "SlowModeActivated(address)": {
        "params": {
          "watcher": "The address of the watcher who called the function"
        }
      }
    },
    "kind": "dev",
    "methods": {
      "activateOptimisticMode()": {
        "details": "Elements in the queue will be discarded. To save gas we are not deleting the elements from the queue, but moving the last counter to first - 1 so we can reassign new elements to those positions in the future. Discarded roots will be included on the upcoming optimistic aggregateRoot."
      },
      "activateSlowMode()": {
        "details": "Sets the proposed aggregate root hash to FINALIZED_HASH, invalidating it."
      },
      "addConnector(uint32,address)": {
        "details": "Only owner can add a new connector. Address should be the connector on L1.Cannot add address(0) to avoid duplicated domain in array and reduce gas fee while propagating.",
        "params": {
          "_connector": "Address of the hub connector.",
          "_domain": "The target spoke domain of the given connector."
        }
      },
      "addProposer(address)": {
        "details": "Only allowlisted proposers can call `proposeAggregateRoot`."
      },
      "aggregate(uint32,bytes32)": {
        "details": "The aggregate tree's root, which will include this inbound root, will be propagated to all spoke domains (via `propagate`) on a regular basis assuming the verification period is surpassed without dispute.",
        "params": {
          "_domain": "The source domain of the given root.",
          "_inbound": "The inbound root coming from the given domain."
        }
      },
      "constructor": {
        "params": {
          "_delayBlocks": "The delay for the validation period for incoming messages in blocks.",
          "_merkle": "The address of the MerkleTreeManager on this domain.",
          "_watcherManager": "The address of the WatcherManager on this domain."
        }
      },
      "dequeue()": {
        "details": "Will dequeue a fixed maximum amount of roots to prevent out of gas errors. As such, this method is public and separate from `propagate` so we can curtail an overloaded queue as needed.",
        "returns": {
          "_0": "bytes32 The new aggregate root.",
          "_1": "uint256 The updated count (number of leaves)."
        }
      },
      "discardRoot(bytes32)": {
        "details": "The given root does NOT have to currently be in the queue. It isn't removed from the queue directly, but instead is filtered out when dequeuing is done for the sake of aggregation.Can only be called by the owner when the protocol is paused.",
        "params": {
          "_root": "The root to be discarded."
        }
      },
      "finalize(bytes32,uint256)": {
        "details": "The system has to be in optimistic mode and propose's dispute time over. Finalized root will stop being monitored by off-chain agents.",
        "params": {
          "_endOfDispute": "The block in which the dispute period for proposedAggregateRootHash finalizes",
          "_proposedAggregateRoot": "The aggregate root currently proposed"
        }
      },
      "finalizeAndPropagate(address[],uint256[],bytes[],bytes32,uint256)": {
        "details": "Should be called by relayers only when proposed root is ready to be finalized.",
        "params": {
          "_connectors": "Array of connectors: should match exactly the array of `connectors` in storage; used here to reduce gas costs, and keep them static regardless of number of supported domains.",
          "_encodedData": "Array of encodedData: extra params for each AMB if required",
          "_endOfDispute": "The block in which the dispute period for proposedAggregateRootHash finalizes",
          "_fees": "Array of fees in native token for an AMB if required",
          "_proposedAggregateRoot": "The aggregate root currently proposed"
        }
      },
      "getConnectorForDomain(uint32)": {
        "details": "Inefficient, should only be used by caller if they have no index reference.",
        "params": {
          "_domain": "The domain for which to get the hub connector address."
        }
      },
      "getDomainIndex(uint32)": {
        "details": "Reverts if domain is not supported.",
        "params": {
          "_domain": "The domain for which to get the index value."
        }
      },
      "getSnapshotDuration()": {
        "returns": {
          "_snapshotDuration": "The duration of the snapshot"
        }
      },
      "isDomainSupported(uint32)": {
        "params": {
          "_domain": "Domain to check."
        }
      },
      "paused()": {
        "details": "Returns true if the contract is paused, and false otherwise."
      },
      "propagate(address[],uint256[],bytes[])": {
        "details": "Should be called by relayers at a regular interval. Workflow is slightly different depending on the mode the system is in.",
        "params": {
          "_connectors": "Array of connectors: should match exactly the array of `connectors` in storage; used here to reduce gas costs, and keep them static regardless of number of supported domains.",
          "_encodedData": "Array of encodedData: extra params for each AMB if required",
          "_fees": "Array of fees in native token for an AMB if required"
        }
      },
      "proposeAggregateRoot(uint256,bytes32,bytes32[],uint32[])": {
        "details": "snapshotId, snapshotRoots and domains are needed for validation and data availability for off-chain agents. In the case of domains we need to check which are the current valid domains at the time of proposing. This is gonna be used by the off-chain scripts to know which domains to check when validating each proposition. This is to avoid problems if a new domain is added in the middle of an on-going propose. Domains should be in the same order as they are in this contract. Snapshot roots provided should be in order of insertion and should respect the domains order.",
        "params": {
          "_aggregateRoot": "The new aggregate root",
          "_domains": "Array of all the domains",
          "_snapshotId": "The snapshot id used",
          "_snapshotsRoots": "Array of snapshot roots inserted"
        }
      },
      "removeConnector(uint32)": {
        "details": "Only watcher can remove a connector.The proposedAggregateRootHash will be set to the FINALIZED_HASH. TODO: Could add a metatx-able `removeConnectorWithSig` if we want to use relayers?",
        "params": {
          "_domain": "The spoke domain of the target connector we want to remove."
        }
      },
      "removeProposer(address)": {
        "details": "Only allowlisted proposers can call `proposeAggregateRoot`."
      },
      "renounceOwnership()": {
        "details": "Renounce ownership should be impossible as long as watchers can freely remove connectors and only the owner can add them back"
      },
      "sendRootToHubSpoke()": {
        "details": "This has no guards as the guards should be in the spoke connector. For example, the spoke connector should      guard against receiving the root through this function if the spoke connector is not in optimistic mode."
      },
      "setHubDomain(uint32)": {
        "params": {
          "_domain": "The domain to be set as hub domain."
        }
      },
      "validateConnectors(address[])": {
        "details": "Reverts if domains or connectors do not match, including ordering.",
        "params": {
          "_connectors": "The given connectors array to check."
        }
      },
      "validateDomains(uint32[],address[])": {
        "details": "Reverts if domains or connectors do not match, including ordering.",
        "params": {
          "_connectors": "The given connectors array to check.",
          "_domains": "The given domains array to check."
        }
      }
    },
    "stateVariables": {
      "lastSavedAggregateRootTimestamp": {
        "details": "Used to ensure that the propagate function will send the latest aggregate root available."
      },
      "pendingInboundRoots": {
        "details": "Watchers should be able to watch this queue for fraudulent messages and pause this contract if fraud is detected."
      },
      "proposedAggregateRootHash": {
        "details": "Set to 0x1 to prevent someone from calling finalize() the moment the contract is deployed"
      },
      "validAggregateRoots": {
        "details": "Each time a new aggregate root is generated or finalized, it will be added to this mapping using the block.timestamp as key.This is only used as Data-Availability for off-chain agents. Especially for the Watchers that fetch the correct aggregate root from this contract in order to verify the data proposed on the Spoke Connectors.rootTimestamp => aggregateRoot"
      }
    },
    "version": 1
  },
  "userdoc": {
    "events": {
      "AggregateRootPropagated(bytes32,bytes32)": {
        "notice": "Emitted when a root is propagated"
      },
      "AggregateRootProposed(uint256,uint256,bytes32,bytes32,bytes32[],uint32[])": {
        "notice": "Emitted when a new aggregate root is proposed"
      },
      "AggregateRootSavedOptimistic(bytes32,uint256)": {
        "notice": "Emitted when an aggregate root is added to the validAggregateRoots map during optimistic mode."
      },
      "AggregateRootSavedSlow(bytes32,uint256,bytes32[],uint256)": {
        "notice": "Emitted when an aggregate root is added to the validAggregateRoots map during slow mode."
      },
      "HubDomainCleared()": {
        "notice": "Emitted when the previously set hub domain is cleared."
      },
      "HubDomainSet(uint32)": {
        "notice": "Emitted when a domain is set as the hub domain."
      },
      "OptimisticModeActivated()": {
        "notice": "Emitted when optimistic mode is activated"
      },
      "ProposerAdded(address)": {
        "notice": "Emitted when a new proposer is added"
      },
      "ProposerRemoved(address)": {
        "notice": "Emitted when a proposer is removed"
      },
      "SlowModeActivated(address)": {
        "notice": "Emitted when slow mode is activated"
      },
      "WatcherManagerChanged(address)": {
        "notice": "Emitted when the manager address changes"
      }
    },
    "kind": "user",
    "methods": {
      "DEQUEUE_MAX()": {
        "notice": "Maximum number of values to dequeue from the queue in one sitting (one call of `propagate` or `dequeue`). Used to cap gas requirements."
      },
      "FINALIZED_HASH()": {
        "notice": "Root used to keep the slots of proposedAggregateRootHash warm."
      },
      "MAX_DOMAINS()": {
        "notice": "The absolute maximum number of domains that we should support. Domain and connector arrays are naturally unbounded, but the gas cost of reading these arrays in `updateHashes()` is bounded by the block's gas limit. If we want to set a hard ceiling for gas costs for the `updateHashes()` method at approx. 500K gas, with an average SLOAD cost of 900 gas per domain (1 uint32, 1 address):       500K / 900 = ~555 domains Realistically, the cap on the number of domains will likely exist in other places, but we cap it here as a last resort."
      },
      "MERKLE()": {
        "notice": "MerkleTreeManager contract instance. Will hold the active tree of aggregated inbound roots. The root of this tree will be distributed crosschain to all spoke domains."
      },
      "acceptProposedOwner()": {
        "notice": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
      },
      "activateOptimisticMode()": {
        "notice": "Owner can set the system to optimistic mode."
      },
      "activateSlowMode()": {
        "notice": "Watcher can set the system in slow mode."
      },
      "addConnector(uint32,address)": {
        "notice": "Add a new supported domain and corresponding hub connector to the system. This new domain will receive the propagated aggregate root."
      },
      "addProposer(address)": {
        "notice": "Adds a proposer to the allowlist."
      },
      "aggregate(uint32,bytes32)": {
        "notice": "Accept an inbound root coming from a given domain's hub connector, enqueuing this incoming root into the current queue as it awaits the verification period."
      },
      "allowlistedProposers(address)": {
        "notice": "This is used for the `onlyProposers` modifier, which gates who can propose new roots using `proposeAggregateRoot`."
      },
      "clearHubDomain()": {
        "notice": "Removes the domain associated with the hub domain."
      },
      "connectors(uint256)": {
        "notice": "Tracks the addresses of the hub connector contracts corresponding to subscribed spoke domains. The index of any given connector in this array should match the index of that connector's target spoke domain in the `domains` array above."
      },
      "connectorsHash()": {
        "notice": "A \"quick reference\" hash used in the `propagate` method below to validate that the provided array of connectors matches the one we have in storage."
      },
      "constructor": {
        "notice": "Creates a new RootManager instance."
      },
      "delay()": {
        "notice": "Returns the delay period before a new owner can be accepted."
      },
      "delayBlocks()": {
        "notice": "Number of blocks to delay the processing of a message to allow for watchers to verify the validity and pause if necessary."
      },
      "dequeue()": {
        "notice": "Dequeue verified inbound roots and insert them into the aggregator tree."
      },
      "discardRoot(bytes32)": {
        "notice": "Removes (effectively blocklists) a given (fraudulent) root from the queue of pending inbound roots."
      },
      "disputeBlocks()": {
        "notice": "The number of blocks watchers have to detect and invalidate the proposed root."
      },
      "domains(uint256)": {
        "notice": "Domains array tracks currently subscribed domains to this hub aggregator. We should distribute the aggregate root to all of these domains in the `propagate` method."
      },
      "domainsHash()": {
        "notice": "A \"quick reference\" hash used in the `propagate` method below to validate that the provided array of domains matches the one we have in storage."
      },
      "finalize(bytes32,uint256)": {
        "notice": "Finalizes the proposed aggregate root. This makes the current proposed root the new validated and ready to propagate root."
      },
      "finalizeAndPropagate(address[],uint256[],bytes[],bytes32,uint256)": {
        "notice": "Unifies the flow of finalize and propagate."
      },
      "getConnectorForDomain(uint32)": {
        "notice": "Gets the corresponding hub connector address for a given spoke domain."
      },
      "getDomainIndex(uint32)": {
        "notice": "Gets the index of a given domain in the domains and connectors arrays."
      },
      "getSnapshotDuration()": {
        "notice": "Get the duration of the snapshot"
      },
      "hubDomain()": {
        "notice": "Domain id of the current network"
      },
      "isDomainSupported(uint32)": {
        "notice": "Convenience shortcut for supported domains. Used to sanity check adding new domains."
      },
      "lastPropagatedRoot(uint32)": {
        "notice": "The last aggregate root we propagated to spoke chains (mapping keyed on domain). Used to prevent sending redundant aggregate roots in `propagate`."
      },
      "lastSavedAggregateRootTimestamp()": {
        "notice": "Timestamp of the last aggregate root saved."
      },
      "minDisputeBlocks()": {
        "notice": "The minimum number of blocks disputeBlocks can be set to."
      },
      "optimisticMode()": {
        "notice": "True if the system is working in optimistic mode. Otherwise is working in slow mode"
      },
      "owner()": {
        "notice": "Returns the address of the current owner."
      },
      "pause()": {
        "notice": "Watchers can pause contracts if fraud is detected"
      },
      "pendingInboundRoots()": {
        "notice": "Queue used for management of verification for inbound roots from spoke chains. Once the verification period elapses, the inbound messages can be aggregated into the merkle tree for propagation to spoke chains."
      },
      "propagate(address[],uint256[],bytes[])": {
        "notice": "This is called by relayers to take the current aggregate tree root and propagate it to all spoke domains (via their respective hub connectors)."
      },
      "proposeAggregateRoot(uint256,bytes32,bytes32[],uint32[])": {
        "notice": "Propose a new aggregate root"
      },
      "proposeNewOwner(address)": {
        "notice": "Sets the timestamp for an owner to be proposed, and sets the newly proposed owner as step 1 in a 2-step process"
      },
      "proposed()": {
        "notice": "Returns the address of the proposed owner."
      },
      "proposedAggregateRootHash()": {
        "notice": "The resulting hash of keccaking the proposed aggregate root and the block at which its dispute ends."
      },
      "proposedTimestamp()": {
        "notice": "Returns the address of the proposed owner."
      },
      "removeConnector(uint32)": {
        "notice": "Remove support for a connector and respective domain. That connector/domain will no longer receive updates for the latest aggregate root."
      },
      "removeProposer(address)": {
        "notice": "Removes a proposer from the allowlist."
      },
      "renounceOwnership()": {
        "notice": "Remove ability to renounce ownership"
      },
      "renounced()": {
        "notice": "Indicates if the ownership has been renounced() by checking if current owner is address(0)"
      },
      "sendRootToHubSpoke()": {
        "notice": "Sends the latest valid aggregate root to the hub domain's spoke connector."
      },
      "setDelayBlocks(uint256)": {
        "notice": "Set the `delayBlocks`, the period in blocks over which an incoming message is verified."
      },
      "setDisputeBlocks(uint256)": {
        "notice": "Set the `disputeBlocks`, the duration, in blocks, of the dispute process for a given proposed root"
      },
      "setHubDomain(uint32)": {
        "notice": "Sets domain corresponding to the hub domain."
      },
      "setMinDisputeBlocks(uint256)": {
        "notice": "Set the `minDisputeBlocks` variable to the provided parameter."
      },
      "setWatcherManager(address)": {
        "notice": "Owner can enroll a watcher (abilities are defined by inheriting contracts)"
      },
      "unpause()": {
        "notice": "Owner can unpause contracts if fraud is detected by watchers"
      },
      "validAggregateRoots(uint256)": {
        "notice": "The list of valid aggregate roots for a given timestamp."
      },
      "validateConnectors(address[])": {
        "notice": "Validate given connectors array is correct (i.e. it mirrors what is currently saved in storage)."
      },
      "validateDomains(uint32[],address[])": {
        "notice": "Validate given domains and connectors arrays are correct (i.e. they mirror what is currently saved in storage)."
      },
      "watcherManager()": {
        "notice": "The `WatcherManager` contract governs the watcher allowlist."
      }
    },
    "notice": "This contract exists at cluster hubs, and aggregates all transfer roots from messaging spokes into a single merkle tree. Regularly broadcasts the root of the aggregator tree back out to all the messaging spokes.",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 49365,
        "contract": "contracts/messaging/RootManager.sol:RootManager",
        "label": "_owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 49367,
        "contract": "contracts/messaging/RootManager.sol:RootManager",
        "label": "_proposed",
        "offset": 0,
        "slot": "1",
        "type": "t_address"
      },
      {
        "astId": 49369,
        "contract": "contracts/messaging/RootManager.sol:RootManager",
        "label": "_proposedOwnershipTimestamp",
        "offset": 0,
        "slot": "2",
        "type": "t_uint256"
      },
      {
        "astId": 2738,
        "contract": "contracts/messaging/RootManager.sol:RootManager",
        "label": "_paused",
        "offset": 0,
        "slot": "3",
        "type": "t_bool"
      },
      {
        "astId": 34245,
        "contract": "contracts/messaging/RootManager.sol:RootManager",
        "label": "watcherManager",
        "offset": 1,
        "slot": "3",
        "type": "t_contract(WatcherManager)34436"
      },
      {
        "astId": 48052,
        "contract": "contracts/messaging/RootManager.sol:RootManager",
        "label": "domains",
        "offset": 0,
        "slot": "4",
        "type": "t_array(t_uint32)dyn_storage"
      },
      {
        "astId": 48055,
        "contract": "contracts/messaging/RootManager.sol:RootManager",
        "label": "domainsHash",
        "offset": 0,
        "slot": "5",
        "type": "t_bytes32"
      },
      {
        "astId": 48059,
        "contract": "contracts/messaging/RootManager.sol:RootManager",
        "label": "connectors",
        "offset": 0,
        "slot": "6",
        "type": "t_array(t_address)dyn_storage"
      },
      {
        "astId": 48062,
        "contract": "contracts/messaging/RootManager.sol:RootManager",
        "label": "connectorsHash",
        "offset": 0,
        "slot": "7",
        "type": "t_bytes32"
      },
      {
        "astId": 48067,
        "contract": "contracts/messaging/RootManager.sol:RootManager",
        "label": "domainToIndexPlusOne",
        "offset": 0,
        "slot": "8",
        "type": "t_mapping(t_uint32,t_uint256)"
      },
      {
        "astId": 33253,
        "contract": "contracts/messaging/RootManager.sol:RootManager",
        "label": "delayBlocks",
        "offset": 0,
        "slot": "9",
        "type": "t_uint256"
      },
      {
        "astId": 33256,
        "contract": "contracts/messaging/RootManager.sol:RootManager",
        "label": "disputeBlocks",
        "offset": 0,
        "slot": "10",
        "type": "t_uint256"
      },
      {
        "astId": 33259,
        "contract": "contracts/messaging/RootManager.sol:RootManager",
        "label": "minDisputeBlocks",
        "offset": 0,
        "slot": "11",
        "type": "t_uint256"
      },
      {
        "astId": 33262,
        "contract": "contracts/messaging/RootManager.sol:RootManager",
        "label": "optimisticMode",
        "offset": 0,
        "slot": "12",
        "type": "t_bool"
      },
      {
        "astId": 33267,
        "contract": "contracts/messaging/RootManager.sol:RootManager",
        "label": "lastPropagatedRoot",
        "offset": 0,
        "slot": "13",
        "type": "t_mapping(t_uint32,t_bytes32)"
      },
      {
        "astId": 33271,
        "contract": "contracts/messaging/RootManager.sol:RootManager",
        "label": "pendingInboundRoots",
        "offset": 0,
        "slot": "14",
        "type": "t_struct(Queue)48869_storage"
      },
      {
        "astId": 33275,
        "contract": "contracts/messaging/RootManager.sol:RootManager",
        "label": "proposedAggregateRootHash",
        "offset": 0,
        "slot": "18",
        "type": "t_bytes32"
      },
      {
        "astId": 33284,
        "contract": "contracts/messaging/RootManager.sol:RootManager",
        "label": "allowlistedProposers",
        "offset": 0,
        "slot": "19",
        "type": "t_mapping(t_address,t_bool)"
      },
      {
        "astId": 33289,
        "contract": "contracts/messaging/RootManager.sol:RootManager",
        "label": "validAggregateRoots",
        "offset": 0,
        "slot": "20",
        "type": "t_mapping(t_uint256,t_bytes32)"
      },
      {
        "astId": 33292,
        "contract": "contracts/messaging/RootManager.sol:RootManager",
        "label": "lastSavedAggregateRootTimestamp",
        "offset": 0,
        "slot": "21",
        "type": "t_uint256"
      },
      {
        "astId": 33295,
        "contract": "contracts/messaging/RootManager.sol:RootManager",
        "label": "hubDomain",
        "offset": 0,
        "slot": "22",
        "type": "t_uint32"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_address)dyn_storage": {
        "base": "t_address",
        "encoding": "dynamic_array",
        "label": "address[]",
        "numberOfBytes": "32"
      },
      "t_array(t_uint32)dyn_storage": {
        "base": "t_uint32",
        "encoding": "dynamic_array",
        "label": "uint32[]",
        "numberOfBytes": "32"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_contract(WatcherManager)34436": {
        "encoding": "inplace",
        "label": "contract WatcherManager",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_bytes32,t_bool)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_uint256,t_bytes32)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => bytes32)",
        "numberOfBytes": "32",
        "value": "t_bytes32"
      },
      "t_mapping(t_uint256,t_uint256)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_uint32,t_bytes32)": {
        "encoding": "mapping",
        "key": "t_uint32",
        "label": "mapping(uint32 => bytes32)",
        "numberOfBytes": "32",
        "value": "t_bytes32"
      },
      "t_mapping(t_uint32,t_uint256)": {
        "encoding": "mapping",
        "key": "t_uint32",
        "label": "mapping(uint32 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_struct(Queue)48869_storage": {
        "encoding": "inplace",
        "label": "struct QueueLib.Queue",
        "members": [
          {
            "astId": 48854,
            "contract": "contracts/messaging/RootManager.sol:RootManager",
            "label": "first",
            "offset": 0,
            "slot": "0",
            "type": "t_uint128"
          },
          {
            "astId": 48856,
            "contract": "contracts/messaging/RootManager.sol:RootManager",
            "label": "last",
            "offset": 16,
            "slot": "0",
            "type": "t_uint128"
          },
          {
            "astId": 48860,
            "contract": "contracts/messaging/RootManager.sol:RootManager",
            "label": "data",
            "offset": 0,
            "slot": "1",
            "type": "t_mapping(t_uint256,t_bytes32)"
          },
          {
            "astId": 48864,
            "contract": "contracts/messaging/RootManager.sol:RootManager",
            "label": "commitBlock",
            "offset": 0,
            "slot": "2",
            "type": "t_mapping(t_uint256,t_uint256)"
          },
          {
            "astId": 48868,
            "contract": "contracts/messaging/RootManager.sol:RootManager",
            "label": "removed",
            "offset": 0,
            "slot": "3",
            "type": "t_mapping(t_bytes32,t_bool)"
          }
        ],
        "numberOfBytes": "128"
      },
      "t_uint128": {
        "encoding": "inplace",
        "label": "uint128",
        "numberOfBytes": "16"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint32": {
        "encoding": "inplace",
        "label": "uint32",
        "numberOfBytes": "4"
      }
    }
  }
}