{
  "address": "0x157F14f906985CcbCF4c6fCd689147642c7a1766",
  "abi": [
    {
      "inputs": [],
      "name": "AssetLogic__handleIncomingAsset_feeOnTransferNotSupported",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "AssetLogic__handleIncomingAsset_nativeAssetNotSupported",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "AssetLogic__handleOutgoingAsset_notNative",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "BaseConnextFacet__getAdoptedAsset_notWhitelisted",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "BaseConnextFacet__getApprovedCanonicalId_notWhitelisted",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "BaseConnextFacet__nonReentrant_reentrantCall",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "BaseConnextFacet__onlyBridgeRouter_notBridgeRouter",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "BaseConnextFacet__onlyOwnerOrAdmin_notOwnerOrAdmin",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "BaseConnextFacet__onlyOwnerOrRouter_notOwnerOrRouter",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "BaseConnextFacet__onlyOwnerOrWatcher_notOwnerOrWatcher",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "BaseConnextFacet__onlyOwner_notOwner",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "BaseConnextFacet__onlyProposed_notProposedOwner",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "BaseConnextFacet__whenNotPaused_paused",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RoutersFacet__acceptProposedRouterOwner_notElapsed",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RoutersFacet__addLiquidityForRouter_amountIsZero",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RoutersFacet__addLiquidityForRouter_badRouter",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RoutersFacet__addLiquidityForRouter_capReached",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RoutersFacet__addLiquidityForRouter_routerEmpty",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RoutersFacet__approveRouterForPortal_alreadyApproved",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RoutersFacet__approveRouterForPortal_notAdded",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RoutersFacet__onlyProposedRouterOwner_notProposedRouterOwner",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RoutersFacet__onlyProposedRouterOwner_notRouterOwner",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RoutersFacet__onlyRouterOwner_notRouterOwner",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RoutersFacet__proposeRouterOwner_badRouter",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RoutersFacet__proposeRouterOwner_notNewOwner",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RoutersFacet__removeRouterLiquidityFor_notOwner",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RoutersFacet__removeRouterLiquidity_amountIsZero",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RoutersFacet__removeRouterLiquidity_insufficientFunds",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RoutersFacet__removeRouterLiquidity_recipientEmpty",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RoutersFacet__removeRouter_notAdded",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RoutersFacet__removeRouter_routerEmpty",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RoutersFacet__setLiquidityFeeNumerator_tooLarge",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RoutersFacet__setLiquidityFeeNumerator_tooSmall",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RoutersFacet__setMaxRoutersPerTransfer_invalidMaxRoutersPerTransfer",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RoutersFacet__setRouterRecipient_notNewRecipient",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RoutersFacet__setupRouter_alreadyAdded",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RoutersFacet__setupRouter_routerEmpty",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RoutersFacet__unapproveRouterForPortal_notApproved",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "liquidityFeeNumerator",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "caller",
          "type": "address"
        }
      ],
      "name": "LiquidityFeeNumeratorUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "maxRoutersPerTransfer",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "caller",
          "type": "address"
        }
      ],
      "name": "MaxRoutersPerTransferUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "router",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "caller",
          "type": "address"
        }
      ],
      "name": "RouterAdded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "router",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "caller",
          "type": "address"
        }
      ],
      "name": "RouterApprovedForPortal",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "router",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "local",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "key",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "caller",
          "type": "address"
        }
      ],
      "name": "RouterLiquidityAdded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "router",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "local",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "key",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "caller",
          "type": "address"
        }
      ],
      "name": "RouterLiquidityRemoved",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "router",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "prevOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "RouterOwnerAccepted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "router",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "prevProposed",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newProposed",
          "type": "address"
        }
      ],
      "name": "RouterOwnerProposed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "router",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "prevRecipient",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newRecipient",
          "type": "address"
        }
      ],
      "name": "RouterRecipientSet",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "router",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "caller",
          "type": "address"
        }
      ],
      "name": "RouterRemoved",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "router",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "caller",
          "type": "address"
        }
      ],
      "name": "RouterUnapprovedForPortal",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "LIQUIDITY_FEE_DENOMINATOR",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "LIQUIDITY_FEE_NUMERATOR",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "router",
          "type": "address"
        }
      ],
      "name": "acceptProposedRouterOwner",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_amount",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "_local",
          "type": "address"
        }
      ],
      "name": "addRouterLiquidity",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_amount",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "_local",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_router",
          "type": "address"
        }
      ],
      "name": "addRouterLiquidityFor",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_router",
          "type": "address"
        }
      ],
      "name": "approveRouterForPortal",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_router",
          "type": "address"
        }
      ],
      "name": "getProposedRouterOwner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_router",
          "type": "address"
        }
      ],
      "name": "getProposedRouterOwnerTimestamp",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_router",
          "type": "address"
        }
      ],
      "name": "getRouterApproval",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_router",
          "type": "address"
        }
      ],
      "name": "getRouterApprovalForPortal",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_router",
          "type": "address"
        }
      ],
      "name": "getRouterOwner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_router",
          "type": "address"
        }
      ],
      "name": "getRouterRecipient",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "maxRoutersPerTransfer",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "router",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "proposed",
          "type": "address"
        }
      ],
      "name": "proposeRouterOwner",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "router",
          "type": "address"
        }
      ],
      "name": "removeRouter",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_amount",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "_local",
          "type": "address"
        },
        {
          "internalType": "address payable",
          "name": "_to",
          "type": "address"
        }
      ],
      "name": "removeRouterLiquidity",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_amount",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "_local",
          "type": "address"
        },
        {
          "internalType": "address payable",
          "name": "_to",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_router",
          "type": "address"
        }
      ],
      "name": "removeRouterLiquidityFor",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_router",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_asset",
          "type": "address"
        }
      ],
      "name": "routerBalances",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_numerator",
          "type": "uint256"
        }
      ],
      "name": "setLiquidityFeeNumerator",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_newMaxRouters",
          "type": "uint256"
        }
      ],
      "name": "setMaxRoutersPerTransfer",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "router",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        }
      ],
      "name": "setRouterRecipient",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "router",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        }
      ],
      "name": "setupRouter",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_router",
          "type": "address"
        }
      ],
      "name": "unapproveRouterForPortal",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xd8f7c321b0715abb8e1b00d418b1964d2a8341fe175abfd5d63c1e54c4bff249",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0x54BAA998771639628ffC0206c3b916c466b79c89",
    "contractAddress": null,
    "transactionIndex": 0,
    "gasUsed": "1859001",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x16623db68938f669c1ad31715edb94a4dfcb8e22c9b141ae7e14ba5dca662619",
    "transactionHash": "0xd8f7c321b0715abb8e1b00d418b1964d2a8341fe175abfd5d63c1e54c4bff249",
    "logs": [],
    "blockNumber": 2098682,
    "cumulativeGasUsed": "1859001",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "2cb19c6ff260c62b0df6791111e721e0",
  "metadata": "{\"compiler\":{\"version\":\"0.8.15+commit.e14f2714\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"AssetLogic__handleIncomingAsset_feeOnTransferNotSupported\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AssetLogic__handleIncomingAsset_nativeAssetNotSupported\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AssetLogic__handleOutgoingAsset_notNative\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BaseConnextFacet__getAdoptedAsset_notWhitelisted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BaseConnextFacet__getApprovedCanonicalId_notWhitelisted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BaseConnextFacet__nonReentrant_reentrantCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BaseConnextFacet__onlyBridgeRouter_notBridgeRouter\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BaseConnextFacet__onlyOwnerOrAdmin_notOwnerOrAdmin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BaseConnextFacet__onlyOwnerOrRouter_notOwnerOrRouter\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BaseConnextFacet__onlyOwnerOrWatcher_notOwnerOrWatcher\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BaseConnextFacet__onlyOwner_notOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BaseConnextFacet__onlyProposed_notProposedOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BaseConnextFacet__whenNotPaused_paused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RoutersFacet__acceptProposedRouterOwner_notElapsed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RoutersFacet__addLiquidityForRouter_amountIsZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RoutersFacet__addLiquidityForRouter_badRouter\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RoutersFacet__addLiquidityForRouter_capReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RoutersFacet__addLiquidityForRouter_routerEmpty\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RoutersFacet__approveRouterForPortal_alreadyApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RoutersFacet__approveRouterForPortal_notAdded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RoutersFacet__onlyProposedRouterOwner_notProposedRouterOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RoutersFacet__onlyProposedRouterOwner_notRouterOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RoutersFacet__onlyRouterOwner_notRouterOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RoutersFacet__proposeRouterOwner_badRouter\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RoutersFacet__proposeRouterOwner_notNewOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RoutersFacet__removeRouterLiquidityFor_notOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RoutersFacet__removeRouterLiquidity_amountIsZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RoutersFacet__removeRouterLiquidity_insufficientFunds\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RoutersFacet__removeRouterLiquidity_recipientEmpty\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RoutersFacet__removeRouter_notAdded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RoutersFacet__removeRouter_routerEmpty\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RoutersFacet__setLiquidityFeeNumerator_tooLarge\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RoutersFacet__setLiquidityFeeNumerator_tooSmall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RoutersFacet__setMaxRoutersPerTransfer_invalidMaxRoutersPerTransfer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RoutersFacet__setRouterRecipient_notNewRecipient\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RoutersFacet__setupRouter_alreadyAdded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RoutersFacet__setupRouter_routerEmpty\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RoutersFacet__unapproveRouterForPortal_notApproved\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidityFeeNumerator\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"LiquidityFeeNumeratorUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxRoutersPerTransfer\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"MaxRoutersPerTransferUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"RouterAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"RouterApprovedForPortal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"local\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"RouterLiquidityAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"local\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"RouterLiquidityRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"prevOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"RouterOwnerAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"prevProposed\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newProposed\",\"type\":\"address\"}],\"name\":\"RouterOwnerProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"prevRecipient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newRecipient\",\"type\":\"address\"}],\"name\":\"RouterRecipientSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"RouterRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"RouterUnapprovedForPortal\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"LIQUIDITY_FEE_DENOMINATOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LIQUIDITY_FEE_NUMERATOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"}],\"name\":\"acceptProposedRouterOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_local\",\"type\":\"address\"}],\"name\":\"addRouterLiquidity\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_local\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"}],\"name\":\"addRouterLiquidityFor\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"}],\"name\":\"approveRouterForPortal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"}],\"name\":\"getProposedRouterOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"}],\"name\":\"getProposedRouterOwnerTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"}],\"name\":\"getRouterApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"}],\"name\":\"getRouterApprovalForPortal\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"}],\"name\":\"getRouterOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"}],\"name\":\"getRouterRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxRoutersPerTransfer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"proposed\",\"type\":\"address\"}],\"name\":\"proposeRouterOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"}],\"name\":\"removeRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_local\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"removeRouterLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_local\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"}],\"name\":\"removeRouterLiquidityFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"}],\"name\":\"routerBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_numerator\",\"type\":\"uint256\"}],\"name\":\"setLiquidityFeeNumerator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newMaxRouters\",\"type\":\"uint256\"}],\"name\":\"setMaxRoutersPerTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"setRouterRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"setupRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"}],\"name\":\"unapproveRouterForPortal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"events\":{\"LiquidityFeeNumeratorUpdated(uint256,address)\":{\"params\":{\"caller\":\"- The account that called the function\",\"liquidityFeeNumerator\":\"- The LIQUIDITY_FEE_NUMERATOR new value\"}},\"MaxRoutersPerTransferUpdated(uint256,address)\":{\"params\":{\"caller\":\"- The account that called the function\",\"maxRoutersPerTransfer\":\"- The maxRoutersPerTransfer new value\"}},\"RouterAdded(address,address)\":{\"params\":{\"caller\":\"- The account that called the function\",\"router\":\"- The address of the added router\"}},\"RouterApprovedForPortal(address,address)\":{\"params\":{\"caller\":\"- The account that called the function\",\"router\":\"- The address of the approved router\"}},\"RouterLiquidityAdded(address,address,bytes32,uint256,address)\":{\"params\":{\"amount\":\"- The amount of liquidity added\",\"caller\":\"- The account that called the function\",\"key\":\"- The hash of the canonical id and domain\",\"local\":\"- The address of the token added (all liquidity held in local asset)\",\"router\":\"- The address of the router the funds were credited to\"}},\"RouterLiquidityRemoved(address,address,address,bytes32,uint256,address)\":{\"params\":{\"amount\":\"- The amount of liquidity withdrawn\",\"caller\":\"- The account that called the function\",\"local\":\"- The address of the token withdrawn\",\"router\":\"- The router you are removing liquidity from\",\"to\":\"- The address the funds were withdrawn to\"}},\"RouterOwnerAccepted(address,address,address)\":{\"params\":{\"newOwner\":\"- The address of the new owner of the router\",\"prevOwner\":\"- The address of the previous owner of the router\",\"router\":\"- The address of the added router\"}},\"RouterOwnerProposed(address,address,address)\":{\"params\":{\"newProposed\":\"- The address of the new proposed\",\"prevProposed\":\"- The address of the previous proposed\",\"router\":\"- The address of the added router\"}},\"RouterRecipientSet(address,address,address)\":{\"params\":{\"newRecipient\":\"- The address of the new recipient of the router\",\"prevRecipient\":\"- The address of the previous recipient of the router\",\"router\":\"- The address of the added router\"}},\"RouterRemoved(address,address)\":{\"params\":{\"caller\":\"- The account that called the function\",\"router\":\"- The address of the removed router\"}},\"RouterUnapprovedForPortal(address,address)\":{\"params\":{\"caller\":\"- The account that called the function\",\"router\":\"- The address of the disapproved router\"}}},\"kind\":\"dev\",\"methods\":{\"acceptProposedRouterOwner(address)\":{\"params\":{\"router\":\"Router address to set recipient\"}},\"addRouterLiquidity(uint256,address)\":{\"details\":\"The liquidity will be held in the local asset, which is the representation if you are *not* on the canonical domain, and the canonical asset otherwise.\",\"params\":{\"_amount\":\"- The amount of liquidity to add for the router\",\"_local\":\"- The address of the asset you're adding liquidity for. If adding liquidity of the native asset, routers may use `address(0)` or the wrapped asset\"}},\"addRouterLiquidityFor(uint256,address,address)\":{\"details\":\"The liquidity will be held in the local asset, which is the representation if you are *not* on the canonical domain, and the canonical asset otherwise.\",\"params\":{\"_amount\":\"- The amount of liquidity to add for the router\",\"_local\":\"- The address of the asset you're adding liquidity for. If adding liquidity of the native asset, routers may use `address(0)` or the wrapped asset\",\"_router\":\"The router you are adding liquidity on behalf of\"}},\"approveRouterForPortal(address)\":{\"params\":{\"_router\":\"- The router address to approve\"}},\"getProposedRouterOwner(address)\":{\"details\":\"All routers must wait for the delay timeout before accepting a new owner\",\"params\":{\"_router\":\"The relevant router address\"}},\"getProposedRouterOwnerTimestamp(address)\":{\"details\":\"All routers must wait for the delay timeout before accepting a new owner\",\"params\":{\"_router\":\"The relevant router address\"}},\"getRouterApproval(address)\":{\"params\":{\"_router\":\"The relevant router address\"}},\"getRouterApprovalForPortal(address)\":{\"params\":{\"_router\":\"The relevant router address\"}},\"getRouterOwner(address)\":{\"details\":\"Uses logic function here to handle the case where router owner is not set. Other getters within this interface use explicitly the stored value\",\"params\":{\"_router\":\"The relevant router address\"}},\"getRouterRecipient(address)\":{\"details\":\"The recipient (if set) receives all funds when router liquidity is removed\",\"params\":{\"_router\":\"The relevant router address\"}},\"proposeRouterOwner(address,address)\":{\"params\":{\"proposed\":\"Proposed owner Address to set to router\",\"router\":\"Router address to set recipient\"}},\"removeRouter(address)\":{\"params\":{\"router\":\"Router address to remove\"}},\"removeRouterLiquidity(uint256,address,address)\":{\"params\":{\"_amount\":\"- The amount of liquidity to remove for the router\",\"_local\":\"- The address of the asset you're removing liquidity from. If removing liquidity of the native asset, routers may use `address(0)` or the wrapped asset\",\"_to\":\"The address that will receive the liquidity being removed if no router recipient exists.\"}},\"removeRouterLiquidityFor(uint256,address,address,address)\":{\"params\":{\"_amount\":\"- The amount of liquidity to remove for the router\",\"_local\":\"- The address of the asset you're removing liquidity from. If removing liquidity of the native asset, routers may use `address(0)` or the wrapped asset\",\"_router\":\"The address of the router\",\"_to\":\"The address that will receive the liquidity being removed\"}},\"setLiquidityFeeNumerator(uint256)\":{\"details\":\"Admin can set LIQUIDITY_FEE_NUMERATOR variable, Liquidity fee should be less than 5%\",\"params\":{\"_numerator\":\"new LIQUIDITY_FEE_NUMERATOR\"}},\"setMaxRoutersPerTransfer(uint256)\":{\"params\":{\"_newMaxRouters\":\"The new max amount of routers\"}},\"setRouterRecipient(address,address)\":{\"details\":\"Router should only be able to set this once otherwise if router key compromised, no problem is solved since attacker could just update recipient\",\"params\":{\"recipient\":\"Recipient Address to set to router\",\"router\":\"Router address to set recipient\"}},\"setupRouter(address,address,address)\":{\"params\":{\"owner\":\"Initial Owner of router\",\"recipient\":\"Initial Recipient of router\",\"router\":\"Router address to setup\"}},\"unapproveRouterForPortal(address)\":{\"params\":{\"_router\":\"- The router address to remove approval\"}}},\"version\":1},\"userdoc\":{\"events\":{\"LiquidityFeeNumeratorUpdated(uint256,address)\":{\"notice\":\"Emitted when the LIQUIDITY_FEE_NUMERATOR variable is updated\"},\"MaxRoutersPerTransferUpdated(uint256,address)\":{\"notice\":\"Emitted when the maxRoutersPerTransfer variable is updated\"},\"RouterAdded(address,address)\":{\"notice\":\"Emitted when a new router is added\"},\"RouterApprovedForPortal(address,address)\":{\"notice\":\"Emitted when a router is approved for Portal\"},\"RouterLiquidityAdded(address,address,bytes32,uint256,address)\":{\"notice\":\"Emitted when a router adds liquidity to the contract\"},\"RouterLiquidityRemoved(address,address,address,bytes32,uint256,address)\":{\"notice\":\"Emitted when a router withdraws liquidity from the contract\"},\"RouterOwnerAccepted(address,address,address)\":{\"notice\":\"Emitted when the owner of router is accepted\"},\"RouterOwnerProposed(address,address,address)\":{\"notice\":\"Emitted when the owner of router is proposed\"},\"RouterRecipientSet(address,address,address)\":{\"notice\":\"Emitted when the recipient of router is updated\"},\"RouterRemoved(address,address)\":{\"notice\":\"Emitted when an existing router is removed\"},\"RouterUnapprovedForPortal(address,address)\":{\"notice\":\"Emitted when a router is disapproved for Portal\"}},\"kind\":\"user\",\"methods\":{\"acceptProposedRouterOwner(address)\":{\"notice\":\"New router owner must accept role, or previous if proposed is 0x0\"},\"addRouterLiquidity(uint256,address)\":{\"notice\":\"This is used by any router to increase their available liquidity for a given asset.\"},\"addRouterLiquidityFor(uint256,address,address)\":{\"notice\":\"This is used by anyone to increase a router's available liquidity for a given asset.\"},\"approveRouterForPortal(address)\":{\"notice\":\"Allow router to use Portals\"},\"getProposedRouterOwner(address)\":{\"notice\":\"Returns the currently proposed router owner\"},\"getProposedRouterOwnerTimestamp(address)\":{\"notice\":\"Returns the currently proposed router owner timestamp\"},\"getRouterApproval(address)\":{\"notice\":\"Returns the approved router for the given router address\"},\"getRouterApprovalForPortal(address)\":{\"notice\":\"Returns whether the router is approved for portals or not\"},\"getRouterOwner(address)\":{\"notice\":\"Returns the router owner if it is set, or the router itself if not\"},\"getRouterRecipient(address)\":{\"notice\":\"Returns the recipient for the specified router\"},\"proposeRouterOwner(address,address)\":{\"notice\":\"Current owner or router may propose a new router owner\"},\"removeRouter(address)\":{\"notice\":\"Used to remove routers that can transact crosschain\"},\"removeRouterLiquidity(uint256,address,address)\":{\"notice\":\"This is used by any router to decrease their available liquidity for a given asset.\"},\"removeRouterLiquidityFor(uint256,address,address,address)\":{\"notice\":\"This is used by any router owner to decrease their available liquidity for a given asset.\"},\"setLiquidityFeeNumerator(uint256)\":{\"notice\":\"Sets the LIQUIDITY_FEE_NUMERATOR\"},\"setMaxRoutersPerTransfer(uint256)\":{\"notice\":\"Used to set the max amount of routers a payment can be routed through\"},\"setRouterRecipient(address,address)\":{\"notice\":\"Sets the designated recipient for a router\"},\"setupRouter(address,address,address)\":{\"notice\":\"Used to set router initial properties\"},\"unapproveRouterForPortal(address)\":{\"notice\":\"Remove router access to use Portals\"}},\"notice\":\"This contract is designed to manage router access, meaning it maintains the router recipients, owners, and the router whitelist itself. As a router, there are three important permissions: `router` - this is the address that will sign bids sent to the sequencer `routerRecipient` - this is the address that receives funds when liquidity is withdrawn `routerOwner` - this is the address permitted to update recipients and propose new owners In cases where the owner is not set, the caller should be the `router` itself. In cases where the `routerRecipient` is not set, the funds can be removed to anywhere. When setting a new `routerOwner`, the current owner (or router) must create a proposal, which can be accepted by the proposed owner after the delay period. If the proposed owner is the empty address, then it must be accepted by the current owner.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/core/connext/facets/RoutersFacet.sol\":\"RoutersFacet\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal onlyInitializing {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x247c62047745915c0af6b955470a72d1696ebad4352d7d3011aef1a2463cd888\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\\n     * initialization.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized < type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x0203dcadc5737d9ef2c211d6fa15d18ebc3b30dfa51903b64870b01a062b0b4e\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20Upgradeable.sol\\\";\\nimport \\\"./extensions/IERC20MetadataUpgradeable.sol\\\";\\nimport \\\"../../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\\n        __ERC20_init_unchained(name_, symbol_);\\n    }\\n\\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n        }\\n        _balances[to] += amount;\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[45] private __gap;\\n}\\n\",\"keccak256\":\"0x7c7ac0bc6c340a7f320524b9a4b4b079ee9da3c51258080d4bab237f329a427c\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x4e733d3164f73f461eaf9d8087a7ad1ea180bdc8ba0d3d61b0e1ae16d8e63dff\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC20Upgradeable.sol\\\";\\nimport \\\"../../../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\\n * tokens and those that they have an allowance for, in a way that can be\\n * recognized off-chain (via event analysis).\\n */\\nabstract contract ERC20BurnableUpgradeable is Initializable, ContextUpgradeable, ERC20Upgradeable {\\n    function __ERC20Burnable_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC20Burnable_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev Destroys `amount` tokens from the caller.\\n     *\\n     * See {ERC20-_burn}.\\n     */\\n    function burn(uint256 amount) public virtual {\\n        _burn(_msgSender(), amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\\n     * allowance.\\n     *\\n     * See {ERC20-_burn} and {ERC20-allowance}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have allowance for ``accounts``'s tokens of at least\\n     * `amount`.\\n     */\\n    function burnFrom(address account, uint256 amount) public virtual {\\n        _spendAllowance(account, _msgSender(), amount);\\n        _burn(account, amount);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0xea2c6f9d434127bf36b1e3e5ebaaf6d28a64dbaeea560508e570014e905a5ad2\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x605434219ebbe4653f703640f06969faa5a1d78f0bfef878e5ddbb1ca369ceeb\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x611aa3f23e59cfdd1863c536776407b3e33d695152a266fa7cfb34440a29a8a3\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x963ea7f0b48b032eef72fe3a7582edf78408d6f834115b9feadd673a4d5bd149\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n        }\\n        _balances[to] += amount;\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\",\"keccak256\":\"0x24b04b8aacaaf1a4a0719117b29c9c3647b1f479c5ac2a60f5ff1bb6d839c238\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x9750c6b834f7b43000631af5cc30001c5f547b3ceb3635488f140f60e897ea6b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x8de418a5503946cabe331f35fe242d3201a73f67f77aaeb7110acb1f30423aca\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xf41ca991f30855bf80ffd11e9347856a517b977f0a6c2d52e6421a99b7840329\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x032807210d1d7d218963d7355d62e021a84bf1b3339f4f50be2f63b53cccaf29\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xd6153ce99bcdcce22b124f755e72553295be6abcd63804cfdffceb188b8bef10\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"contracts/core/connext/facets/BaseConnextFacet.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.15;\\n\\nimport {TransferInfo, AppStorage, TokenId, Role} from \\\"../libraries/LibConnextStorage.sol\\\";\\nimport {LibDiamond} from \\\"../libraries/LibDiamond.sol\\\";\\nimport {AssetLogic} from \\\"../libraries/AssetLogic.sol\\\";\\n\\ncontract BaseConnextFacet {\\n  AppStorage internal s;\\n\\n  // ========== Properties ===========\\n  uint256 internal constant _NOT_ENTERED = 1;\\n  uint256 internal constant _ENTERED = 2;\\n  uint256 internal constant BPS_FEE_DENOMINATOR = 10_000;\\n\\n  // Contains hash of empty bytes\\n  bytes32 internal constant EMPTY_HASH = hex\\\"c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\\\";\\n\\n  // ========== Custom Errors ===========\\n\\n  error BaseConnextFacet__onlyBridgeRouter_notBridgeRouter();\\n  error BaseConnextFacet__onlyOwner_notOwner();\\n  error BaseConnextFacet__onlyProposed_notProposedOwner();\\n  error BaseConnextFacet__onlyOwnerOrRouter_notOwnerOrRouter();\\n  error BaseConnextFacet__onlyOwnerOrWatcher_notOwnerOrWatcher();\\n  error BaseConnextFacet__onlyOwnerOrAdmin_notOwnerOrAdmin();\\n  error BaseConnextFacet__whenNotPaused_paused();\\n  error BaseConnextFacet__nonReentrant_reentrantCall();\\n  error BaseConnextFacet__getAdoptedAsset_notWhitelisted();\\n  error BaseConnextFacet__getApprovedCanonicalId_notWhitelisted();\\n\\n  // ============ Modifiers ============\\n\\n  /**\\n   * @dev Prevents a contract from calling itself, directly or indirectly.\\n   * Calling a `nonReentrant` function from another `nonReentrant`\\n   * function is not supported. It is possible to prevent this from happening\\n   * by making the `nonReentrant` function external, and making it call a\\n   * `private` function that does the actual work.\\n   */\\n  modifier nonReentrant() {\\n    // On the first call to nonReentrant, _notEntered will be true\\n    if (s._status == _ENTERED) revert BaseConnextFacet__nonReentrant_reentrantCall();\\n\\n    // Any calls to nonReentrant after this point will fail\\n    s._status = _ENTERED;\\n\\n    _;\\n\\n    // By storing the original value once again, a refund is triggered (see\\n    // https://eips.ethereum.org/EIPS/eip-2200)\\n    s._status = _NOT_ENTERED;\\n  }\\n\\n  /**\\n   * @notice Throws if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    if (LibDiamond.contractOwner() != msg.sender) revert BaseConnextFacet__onlyOwner_notOwner();\\n    _;\\n  }\\n\\n  /**\\n   * @notice Throws if called by any account other than the proposed owner.\\n   */\\n  modifier onlyProposed() {\\n    if (s._proposed != msg.sender) revert BaseConnextFacet__onlyProposed_notProposedOwner();\\n    _;\\n  }\\n\\n  /**\\n   * @notice Throws if called by any account other than the owner and router role.\\n   */\\n  modifier onlyOwnerOrRouter() {\\n    if (LibDiamond.contractOwner() != msg.sender && s.roles[msg.sender] != Role.Router)\\n      revert BaseConnextFacet__onlyOwnerOrRouter_notOwnerOrRouter();\\n    _;\\n  }\\n\\n  /**\\n   * @notice Throws if called by any account other than the owner and watcher role.\\n   */\\n  modifier onlyOwnerOrWatcher() {\\n    if (LibDiamond.contractOwner() != msg.sender && s.roles[msg.sender] != Role.Watcher)\\n      revert BaseConnextFacet__onlyOwnerOrWatcher_notOwnerOrWatcher();\\n    _;\\n  }\\n\\n  /**\\n   * @notice Throws if called by any account other than the owner and admin role.\\n   */\\n  modifier onlyOwnerOrAdmin() {\\n    if (LibDiamond.contractOwner() != msg.sender && s.roles[msg.sender] != Role.Admin)\\n      revert BaseConnextFacet__onlyOwnerOrAdmin_notOwnerOrAdmin();\\n    _;\\n  }\\n\\n  /**\\n   * @notice Throws if all functionality is paused\\n   */\\n  modifier whenNotPaused() {\\n    if (s._paused) revert BaseConnextFacet__whenNotPaused_paused();\\n    _;\\n  }\\n\\n  // ============ Internal functions ============\\n  /**\\n   * @notice Indicates if the router whitelist has been removed\\n   */\\n  function _isRouterWhitelistRemoved() internal view returns (bool) {\\n    return LibDiamond.contractOwner() == address(0) || s._routerWhitelistRemoved;\\n  }\\n\\n  /**\\n   * @notice Indicates if the asset whitelist has been removed\\n   */\\n  function _isAssetWhitelistRemoved() internal view returns (bool) {\\n    return LibDiamond.contractOwner() == address(0) || s._assetWhitelistRemoved;\\n  }\\n\\n  /**\\n   * @notice Returns the adopted assets for given canonical information\\n   */\\n  function _getAdoptedAsset(bytes32 _key) internal view returns (address) {\\n    address adopted = s.canonicalToAdopted[_key];\\n    if (adopted == address(0)) {\\n      revert BaseConnextFacet__getAdoptedAsset_notWhitelisted();\\n    }\\n    return adopted;\\n  }\\n\\n  /**\\n   * @notice Returns the adopted assets for given canonical information\\n   */\\n  function _getRepresentationAsset(bytes32 _key) internal view returns (address) {\\n    address representation = s.canonicalToRepresentation[_key];\\n    // If this is address(0), then there is no mintable token for this asset on this\\n    // domain\\n    return representation;\\n  }\\n\\n  /**\\n   * @notice Calculates a transferId\\n   */\\n  function _calculateTransferId(TransferInfo memory _params) internal pure returns (bytes32) {\\n    return keccak256(abi.encode(_params));\\n  }\\n\\n  /**\\n   * @notice Internal utility function that combines\\n   *         `_origin` and `_nonce`.\\n   * @dev Both origin and nonce should be less than 2^32 - 1\\n   * @param _origin Domain of chain where the transfer originated\\n   * @param _nonce The unique identifier for the message from origin to destination\\n   * @return Returns (`_origin` << 32) & `_nonce`\\n   */\\n  function _originAndNonce(uint32 _origin, uint32 _nonce) internal pure returns (uint64) {\\n    return (uint64(_origin) << 32) | _nonce;\\n  }\\n\\n  function _getLocalAsset(\\n    bytes32 _key,\\n    bytes32 _id,\\n    uint32 _domain\\n  ) internal view returns (address) {\\n    return AssetLogic.getLocalAsset(_key, _id, _domain, s);\\n  }\\n\\n  function _getCanonicalTokenId(address _candidate) internal view returns (TokenId memory) {\\n    return AssetLogic.getCanonicalTokenId(_candidate, s);\\n  }\\n\\n  function _getLocalAndAdoptedToken(\\n    bytes32 _key,\\n    bytes32 _id,\\n    uint32 _domain\\n  ) internal view returns (address, address) {\\n    address _local = AssetLogic.getLocalAsset(_key, _id, _domain, s);\\n    address _adopted = _getAdoptedAsset(_key);\\n    return (_local, _adopted);\\n  }\\n\\n  function _isLocalOrigin(address _token) internal view returns (bool) {\\n    return AssetLogic.isLocalOrigin(_token, s);\\n  }\\n\\n  function _getApprovedCanonicalId(address _candidate) internal view returns (TokenId memory, bytes32) {\\n    TokenId memory _canonical = _getCanonicalTokenId(_candidate);\\n    bytes32 _key = AssetLogic.calculateCanonicalHash(_canonical.id, _canonical.domain);\\n    if (!_isAssetWhitelistRemoved() && !s.approvedAssets[_key]) {\\n      revert BaseConnextFacet__getApprovedCanonicalId_notWhitelisted();\\n    }\\n    return (_canonical, _key);\\n  }\\n}\\n\",\"keccak256\":\"0xc8c6fa0e67f48de47acc734b86ec59488c112255643d40ded1616183a6d490f0\",\"license\":\"UNLICENSED\"},\"contracts/core/connext/facets/RoutersFacet.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.15;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport {BaseConnextFacet} from \\\"./BaseConnextFacet.sol\\\";\\nimport {AssetLogic} from \\\"../libraries/AssetLogic.sol\\\";\\nimport {AppStorage, TokenId} from \\\"../libraries/LibConnextStorage.sol\\\";\\n\\n/**\\n * @notice\\n * This contract is designed to manage router access, meaning it maintains the\\n * router recipients, owners, and the router whitelist itself.\\n *\\n * As a router, there are three important permissions:\\n * `router` - this is the address that will sign bids sent to the sequencer\\n * `routerRecipient` - this is the address that receives funds when liquidity is withdrawn\\n * `routerOwner` - this is the address permitted to update recipients and propose new owners\\n *\\n * In cases where the owner is not set, the caller should be the `router` itself. In cases where the\\n * `routerRecipient` is not set, the funds can be removed to anywhere.\\n *\\n * When setting a new `routerOwner`, the current owner (or router) must create a proposal, which\\n * can be accepted by the proposed owner after the delay period. If the proposed owner is the empty\\n * address, then it must be accepted by the current owner.\\n */\\ncontract RoutersFacet is BaseConnextFacet {\\n  // ========== Custom Errors ===========\\n  error RoutersFacet__acceptProposedRouterOwner_notElapsed();\\n  error RoutersFacet__setRouterRecipient_notNewRecipient();\\n  error RoutersFacet__onlyRouterOwner_notRouterOwner();\\n  error RoutersFacet__onlyProposedRouterOwner_notRouterOwner();\\n  error RoutersFacet__onlyProposedRouterOwner_notProposedRouterOwner();\\n  error RoutersFacet__removeRouter_routerEmpty();\\n  error RoutersFacet__removeRouter_notAdded();\\n  error RoutersFacet__setupRouter_routerEmpty();\\n  error RoutersFacet__setupRouter_alreadyAdded();\\n  error RoutersFacet__proposeRouterOwner_notNewOwner();\\n  error RoutersFacet__proposeRouterOwner_badRouter();\\n  error RoutersFacet__setMaxRoutersPerTransfer_invalidMaxRoutersPerTransfer();\\n  error RoutersFacet__addLiquidityForRouter_routerEmpty();\\n  error RoutersFacet__addLiquidityForRouter_amountIsZero();\\n  error RoutersFacet__addLiquidityForRouter_badRouter();\\n  error RoutersFacet__addLiquidityForRouter_capReached();\\n  error RoutersFacet__removeRouterLiquidity_recipientEmpty();\\n  error RoutersFacet__removeRouterLiquidity_amountIsZero();\\n  error RoutersFacet__removeRouterLiquidity_insufficientFunds();\\n  error RoutersFacet__removeRouterLiquidityFor_notOwner();\\n  error RoutersFacet__setLiquidityFeeNumerator_tooSmall();\\n  error RoutersFacet__setLiquidityFeeNumerator_tooLarge();\\n  error RoutersFacet__approveRouterForPortal_notAdded();\\n  error RoutersFacet__approveRouterForPortal_alreadyApproved();\\n  error RoutersFacet__unapproveRouterForPortal_notApproved();\\n\\n  // ============ Properties ============\\n\\n  // ============ Constants ============\\n  uint256 private constant _delay = 7 days;\\n\\n  // ============ Events ============\\n\\n  /**\\n   * @notice Emitted when a new router is added\\n   * @param router - The address of the added router\\n   * @param caller - The account that called the function\\n   */\\n  event RouterAdded(address indexed router, address caller);\\n\\n  /**\\n   * @notice Emitted when an existing router is removed\\n   * @param router - The address of the removed router\\n   * @param caller - The account that called the function\\n   */\\n  event RouterRemoved(address indexed router, address caller);\\n\\n  /**\\n   * @notice Emitted when the recipient of router is updated\\n   * @param router - The address of the added router\\n   * @param prevRecipient  - The address of the previous recipient of the router\\n   * @param newRecipient  - The address of the new recipient of the router\\n   */\\n  event RouterRecipientSet(address indexed router, address indexed prevRecipient, address indexed newRecipient);\\n\\n  /**\\n   * @notice Emitted when the owner of router is proposed\\n   * @param router - The address of the added router\\n   * @param prevProposed  - The address of the previous proposed\\n   * @param newProposed  - The address of the new proposed\\n   */\\n  event RouterOwnerProposed(address indexed router, address indexed prevProposed, address indexed newProposed);\\n\\n  /**\\n   * @notice Emitted when the owner of router is accepted\\n   * @param router - The address of the added router\\n   * @param prevOwner  - The address of the previous owner of the router\\n   * @param newOwner  - The address of the new owner of the router\\n   */\\n  event RouterOwnerAccepted(address indexed router, address indexed prevOwner, address indexed newOwner);\\n\\n  /**\\n   * @notice Emitted when the maxRoutersPerTransfer variable is updated\\n   * @param maxRoutersPerTransfer - The maxRoutersPerTransfer new value\\n   * @param caller - The account that called the function\\n   */\\n  event MaxRoutersPerTransferUpdated(uint256 maxRoutersPerTransfer, address caller);\\n\\n  /**\\n   * @notice Emitted when the LIQUIDITY_FEE_NUMERATOR variable is updated\\n   * @param liquidityFeeNumerator - The LIQUIDITY_FEE_NUMERATOR new value\\n   * @param caller - The account that called the function\\n   */\\n  event LiquidityFeeNumeratorUpdated(uint256 liquidityFeeNumerator, address caller);\\n\\n  /**\\n   * @notice Emitted when a router is approved for Portal\\n   * @param router - The address of the approved router\\n   * @param caller - The account that called the function\\n   */\\n  event RouterApprovedForPortal(address router, address caller);\\n\\n  /**\\n   * @notice Emitted when a router is disapproved for Portal\\n   * @param router - The address of the disapproved router\\n   * @param caller - The account that called the function\\n   */\\n  event RouterUnapprovedForPortal(address router, address caller);\\n\\n  /**\\n   * @notice Emitted when a router adds liquidity to the contract\\n   * @param router - The address of the router the funds were credited to\\n   * @param local - The address of the token added (all liquidity held in local asset)\\n   * @param key - The hash of the canonical id and domain\\n   * @param amount - The amount of liquidity added\\n   * @param caller - The account that called the function\\n   */\\n  event RouterLiquidityAdded(address indexed router, address local, bytes32 key, uint256 amount, address caller);\\n\\n  /**\\n   * @notice Emitted when a router withdraws liquidity from the contract\\n   * @param router - The router you are removing liquidity from\\n   * @param to - The address the funds were withdrawn to\\n   * @param local - The address of the token withdrawn\\n   * @param amount - The amount of liquidity withdrawn\\n   * @param caller - The account that called the function\\n   */\\n  event RouterLiquidityRemoved(\\n    address indexed router,\\n    address to,\\n    address local,\\n    bytes32 key,\\n    uint256 amount,\\n    address caller\\n  );\\n\\n  // ============ Modifiers ============\\n\\n  /**\\n   * @notice Asserts caller is the router owner (if set) or the router itself\\n   */\\n  modifier onlyRouterOwner(address _router) {\\n    address owner = s.routerPermissionInfo.routerOwners[_router];\\n    if (!((owner == address(0) && msg.sender == _router) || owner == msg.sender))\\n      revert RoutersFacet__onlyRouterOwner_notRouterOwner();\\n    _;\\n  }\\n\\n  /**\\n   * @notice Asserts caller is the proposed router. If proposed router is address(0), then asserts\\n   * the owner is calling the function (if set), or the router itself is calling the function\\n   */\\n  modifier onlyProposedRouterOwner(address _router) {\\n    address proposed = s.routerPermissionInfo.proposedRouterOwners[_router];\\n    if (proposed == address(0)) {\\n      address owner = s.routerPermissionInfo.routerOwners[_router];\\n      if (!((owner == address(0) && msg.sender == _router) || owner == msg.sender))\\n        revert RoutersFacet__onlyProposedRouterOwner_notRouterOwner();\\n    } else {\\n      if (msg.sender != proposed) revert RoutersFacet__onlyProposedRouterOwner_notProposedRouterOwner();\\n    }\\n    _;\\n  }\\n\\n  // ============ Getters ==============\\n\\n  function LIQUIDITY_FEE_NUMERATOR() public view returns (uint256) {\\n    return s.LIQUIDITY_FEE_NUMERATOR;\\n  }\\n\\n  function LIQUIDITY_FEE_DENOMINATOR() public pure returns (uint256) {\\n    return BPS_FEE_DENOMINATOR;\\n  }\\n\\n  /**\\n   * @notice Returns the approved router for the given router address\\n   * @param _router The relevant router address\\n   */\\n  function getRouterApproval(address _router) public view returns (bool) {\\n    return s.routerPermissionInfo.approvedRouters[_router];\\n  }\\n\\n  /**\\n   * @notice Returns the recipient for the specified router\\n   * @dev The recipient (if set) receives all funds when router liquidity is removed\\n   * @param _router The relevant router address\\n   */\\n  function getRouterRecipient(address _router) public view returns (address) {\\n    return s.routerPermissionInfo.routerRecipients[_router];\\n  }\\n\\n  /**\\n   * @notice Returns the router owner if it is set, or the router itself if not\\n   * @dev Uses logic function here to handle the case where router owner is not set.\\n   * Other getters within this interface use explicitly the stored value\\n   * @param _router The relevant router address\\n   */\\n  function getRouterOwner(address _router) public view returns (address) {\\n    address _owner = s.routerPermissionInfo.routerOwners[_router];\\n    return _owner == address(0) ? _router : _owner;\\n  }\\n\\n  /**\\n   * @notice Returns the currently proposed router owner\\n   * @dev All routers must wait for the delay timeout before accepting a new owner\\n   * @param _router The relevant router address\\n   */\\n  function getProposedRouterOwner(address _router) public view returns (address) {\\n    return s.routerPermissionInfo.proposedRouterOwners[_router];\\n  }\\n\\n  /**\\n   * @notice Returns the currently proposed router owner timestamp\\n   * @dev All routers must wait for the delay timeout before accepting a new owner\\n   * @param _router The relevant router address\\n   */\\n  function getProposedRouterOwnerTimestamp(address _router) public view returns (uint256) {\\n    return s.routerPermissionInfo.proposedRouterTimestamp[_router];\\n  }\\n\\n  function maxRoutersPerTransfer() public view returns (uint256) {\\n    return s.maxRoutersPerTransfer;\\n  }\\n\\n  function routerBalances(address _router, address _asset) public view returns (uint256) {\\n    return s.routerBalances[_router][_asset];\\n  }\\n\\n  /**\\n   * @notice Returns whether the router is approved for portals or not\\n   * @param _router The relevant router address\\n   */\\n  function getRouterApprovalForPortal(address _router) public view returns (bool) {\\n    return s.routerPermissionInfo.approvedForPortalRouters[_router];\\n  }\\n\\n  // ============ Admin methods ==============\\n\\n  /**\\n   * @notice Used to set router initial properties\\n   * @param router Router address to setup\\n   * @param owner Initial Owner of router\\n   * @param recipient Initial Recipient of router\\n   */\\n  function setupRouter(\\n    address router,\\n    address owner,\\n    address recipient\\n  ) external onlyOwnerOrRouter {\\n    // Sanity check: not empty\\n    if (router == address(0)) revert RoutersFacet__setupRouter_routerEmpty();\\n\\n    // Sanity check: needs approval\\n    if (s.routerPermissionInfo.approvedRouters[router]) revert RoutersFacet__setupRouter_alreadyAdded();\\n\\n    // Approve router\\n    s.routerPermissionInfo.approvedRouters[router] = true;\\n\\n    // Emit event\\n    emit RouterAdded(router, msg.sender);\\n\\n    // Update routerOwner (zero address possible)\\n    if (owner != address(0)) {\\n      s.routerPermissionInfo.routerOwners[router] = owner;\\n      emit RouterOwnerAccepted(router, address(0), owner);\\n    }\\n\\n    // Update router recipient\\n    if (recipient != address(0)) {\\n      s.routerPermissionInfo.routerRecipients[router] = recipient;\\n      emit RouterRecipientSet(router, address(0), recipient);\\n    }\\n  }\\n\\n  /**\\n   * @notice Used to remove routers that can transact crosschain\\n   * @param router Router address to remove\\n   */\\n  function removeRouter(address router) external onlyOwnerOrRouter {\\n    // Sanity check: not empty\\n    if (router == address(0)) revert RoutersFacet__removeRouter_routerEmpty();\\n\\n    // Sanity check: needs removal\\n    if (!s.routerPermissionInfo.approvedRouters[router]) revert RoutersFacet__removeRouter_notAdded();\\n\\n    // Update mapping\\n    s.routerPermissionInfo.approvedRouters[router] = false;\\n\\n    // Emit event\\n    emit RouterRemoved(router, msg.sender);\\n\\n    // Remove router owner\\n    address _owner = s.routerPermissionInfo.routerOwners[router];\\n    if (_owner != address(0)) {\\n      emit RouterOwnerAccepted(router, _owner, address(0));\\n      // delete routerOwners[router];\\n      s.routerPermissionInfo.routerOwners[router] = address(0);\\n    }\\n\\n    // Remove router recipient\\n    address _recipient = s.routerPermissionInfo.routerRecipients[router];\\n    if (_recipient != address(0)) {\\n      emit RouterRecipientSet(router, _recipient, address(0));\\n      // delete routerRecipients[router];\\n      s.routerPermissionInfo.routerRecipients[router] = address(0);\\n    }\\n\\n    // Clear any proposed ownership changes\\n    delete s.routerPermissionInfo.proposedRouterOwners[router];\\n    delete s.routerPermissionInfo.proposedRouterTimestamp[router];\\n\\n    // Clear approvedForPortal status.\\n    delete s.routerPermissionInfo.approvedForPortalRouters[router];\\n  }\\n\\n  /**\\n   * @notice Used to set the max amount of routers a payment can be routed through\\n   * @param _newMaxRouters The new max amount of routers\\n   */\\n  function setMaxRoutersPerTransfer(uint256 _newMaxRouters) external onlyOwnerOrAdmin {\\n    if (_newMaxRouters == 0 || _newMaxRouters == s.maxRoutersPerTransfer)\\n      revert RoutersFacet__setMaxRoutersPerTransfer_invalidMaxRoutersPerTransfer();\\n\\n    emit MaxRoutersPerTransferUpdated(_newMaxRouters, msg.sender);\\n\\n    s.maxRoutersPerTransfer = _newMaxRouters;\\n  }\\n\\n  /**\\n   * @notice Sets the LIQUIDITY_FEE_NUMERATOR\\n   * @dev Admin can set LIQUIDITY_FEE_NUMERATOR variable, Liquidity fee should be less than 5%\\n   * @param _numerator new LIQUIDITY_FEE_NUMERATOR\\n   */\\n  function setLiquidityFeeNumerator(uint256 _numerator) external onlyOwnerOrAdmin {\\n    // Slightly misleading: the liquidity fee numerator is not the amount charged,\\n    // but the amount received after fees are deducted (e.g. 9995/10000 would be .005%).\\n    uint256 denominator = BPS_FEE_DENOMINATOR;\\n    if (_numerator < (denominator * 95) / 100) revert RoutersFacet__setLiquidityFeeNumerator_tooSmall();\\n\\n    if (_numerator > denominator) revert RoutersFacet__setLiquidityFeeNumerator_tooLarge();\\n    s.LIQUIDITY_FEE_NUMERATOR = _numerator;\\n\\n    emit LiquidityFeeNumeratorUpdated(_numerator, msg.sender);\\n  }\\n\\n  /**\\n   * @notice Allow router to use Portals\\n   * @param _router - The router address to approve\\n   */\\n  function approveRouterForPortal(address _router) external onlyOwnerOrAdmin {\\n    if (!s.routerPermissionInfo.approvedRouters[_router] && !_isRouterWhitelistRemoved())\\n      revert RoutersFacet__approveRouterForPortal_notAdded();\\n    if (s.routerPermissionInfo.approvedForPortalRouters[_router])\\n      revert RoutersFacet__approveRouterForPortal_alreadyApproved();\\n\\n    s.routerPermissionInfo.approvedForPortalRouters[_router] = true;\\n\\n    emit RouterApprovedForPortal(_router, msg.sender);\\n  }\\n\\n  /**\\n   * @notice Remove router access to use Portals\\n   * @param _router - The router address to remove approval\\n   */\\n  function unapproveRouterForPortal(address _router) external onlyOwnerOrAdmin {\\n    if (!s.routerPermissionInfo.approvedForPortalRouters[_router])\\n      revert RoutersFacet__unapproveRouterForPortal_notApproved();\\n\\n    delete s.routerPermissionInfo.approvedForPortalRouters[_router];\\n\\n    emit RouterUnapprovedForPortal(_router, msg.sender);\\n  }\\n\\n  // ============ Public methods ==============\\n\\n  /**\\n   * @notice Sets the designated recipient for a router\\n   * @dev Router should only be able to set this once otherwise if router key compromised,\\n   * no problem is solved since attacker could just update recipient\\n   * @param router Router address to set recipient\\n   * @param recipient Recipient Address to set to router\\n   */\\n  function setRouterRecipient(address router, address recipient) external onlyRouterOwner(router) {\\n    // Check recipient is changing\\n    address _prevRecipient = s.routerPermissionInfo.routerRecipients[router];\\n    if (_prevRecipient == recipient) revert RoutersFacet__setRouterRecipient_notNewRecipient();\\n\\n    // Set new recipient\\n    s.routerPermissionInfo.routerRecipients[router] = recipient;\\n\\n    // Emit event\\n    emit RouterRecipientSet(router, _prevRecipient, recipient);\\n  }\\n\\n  /**\\n   * @notice Current owner or router may propose a new router owner\\n   * @param router Router address to set recipient\\n   * @param proposed Proposed owner Address to set to router\\n   */\\n  function proposeRouterOwner(address router, address proposed) external onlyRouterOwner(router) {\\n    // Check that proposed is different than current owner\\n    if (getRouterOwner(router) == proposed) revert RoutersFacet__proposeRouterOwner_notNewOwner();\\n\\n    // Check that proposed is different than current proposed\\n    address _currentProposed = s.routerPermissionInfo.proposedRouterOwners[router];\\n    if (_currentProposed == proposed) revert RoutersFacet__proposeRouterOwner_badRouter();\\n\\n    // Set proposed owner + timestamp\\n    s.routerPermissionInfo.proposedRouterOwners[router] = proposed;\\n    s.routerPermissionInfo.proposedRouterTimestamp[router] = block.timestamp;\\n\\n    // Emit event\\n    emit RouterOwnerProposed(router, _currentProposed, proposed);\\n  }\\n\\n  /**\\n   * @notice New router owner must accept role, or previous if proposed is 0x0\\n   * @param router Router address to set recipient\\n   */\\n  function acceptProposedRouterOwner(address router) external onlyProposedRouterOwner(router) {\\n    address owner = getRouterOwner(router);\\n\\n    // Check timestamp has passed\\n    if (block.timestamp - s.routerPermissionInfo.proposedRouterTimestamp[router] <= _delay)\\n      revert RoutersFacet__acceptProposedRouterOwner_notElapsed();\\n\\n    // Get current owner + proposed\\n    address _proposed = s.routerPermissionInfo.proposedRouterOwners[router];\\n\\n    // Update the current owner\\n    s.routerPermissionInfo.routerOwners[router] = _proposed;\\n\\n    // Reset proposal + timestamp\\n    if (_proposed != address(0)) {\\n      delete s.routerPermissionInfo.proposedRouterOwners[router];\\n    }\\n    delete s.routerPermissionInfo.proposedRouterTimestamp[router];\\n\\n    // Emit event\\n    emit RouterOwnerAccepted(router, owner, _proposed);\\n  }\\n\\n  /**\\n   * @notice This is used by anyone to increase a router's available liquidity for a given asset.\\n   * @dev The liquidity will be held in the local asset, which is the representation if you\\n   * are *not* on the canonical domain, and the canonical asset otherwise.\\n   * @param _amount - The amount of liquidity to add for the router\\n   * @param _local - The address of the asset you're adding liquidity for. If adding liquidity of the\\n   * native asset, routers may use `address(0)` or the wrapped asset\\n   * @param _router The router you are adding liquidity on behalf of\\n   */\\n  function addRouterLiquidityFor(\\n    uint256 _amount,\\n    address _local,\\n    address _router\\n  ) external payable nonReentrant whenNotPaused {\\n    _addLiquidityForRouter(_amount, _local, _router);\\n  }\\n\\n  /**\\n   * @notice This is used by any router to increase their available liquidity for a given asset.\\n   * @dev The liquidity will be held in the local asset, which is the representation if you\\n   * are *not* on the canonical domain, and the canonical asset otherwise.\\n   * @param _amount - The amount of liquidity to add for the router\\n   * @param _local - The address of the asset you're adding liquidity for. If adding liquidity of the\\n   * native asset, routers may use `address(0)` or the wrapped asset\\n   */\\n  function addRouterLiquidity(uint256 _amount, address _local) external payable nonReentrant whenNotPaused {\\n    _addLiquidityForRouter(_amount, _local, msg.sender);\\n  }\\n\\n  /**\\n   * @notice This is used by any router owner to decrease their available liquidity for a given asset.\\n   * @param _amount - The amount of liquidity to remove for the router\\n   * @param _local - The address of the asset you're removing liquidity from. If removing liquidity of the\\n   * native asset, routers may use `address(0)` or the wrapped asset\\n   * @param _to The address that will receive the liquidity being removed\\n   * @param _router The address of the router\\n   */\\n  function removeRouterLiquidityFor(\\n    uint256 _amount,\\n    address _local,\\n    address payable _to,\\n    address _router\\n  ) external nonReentrant whenNotPaused {\\n    // Caller must be the router owner\\n    if (msg.sender != getRouterOwner(_router)) revert RoutersFacet__removeRouterLiquidityFor_notOwner();\\n\\n    // Remove liquidity\\n    _removeLiquidityForRouter(_amount, _local, _to, _router);\\n  }\\n\\n  /**\\n   * @notice This is used by any router to decrease their available liquidity for a given asset.\\n   * @param _amount - The amount of liquidity to remove for the router\\n   * @param _local - The address of the asset you're removing liquidity from. If removing liquidity of the\\n   * native asset, routers may use `address(0)` or the wrapped asset\\n   * @param _to The address that will receive the liquidity being removed if no router recipient exists.\\n   */\\n  function removeRouterLiquidity(\\n    uint256 _amount,\\n    address _local,\\n    address payable _to\\n  ) external nonReentrant whenNotPaused {\\n    _removeLiquidityForRouter(_amount, _local, _to, msg.sender);\\n  }\\n\\n  // ============ Internal functions ============\\n\\n  /**\\n   * @notice Contains the logic to verify + increment a given routers liquidity\\n   * @dev The liquidity will be held in the local asset, which is the representation if you\\n   * are *not* on the canonical domain, and the canonical asset otherwise.\\n   * @param _amount - The amount of liquidity to add for the router\\n   * @param _local - The address of the nomad representation of the asset\\n   * @param _router - The router you are adding liquidity on behalf of\\n   */\\n  function _addLiquidityForRouter(\\n    uint256 _amount,\\n    address _local,\\n    address _router\\n  ) internal {\\n    // Sanity check: router is sensible.\\n    if (_router == address(0)) revert RoutersFacet__addLiquidityForRouter_routerEmpty();\\n\\n    // Sanity check: nonzero amounts.\\n    if (_amount == 0) revert RoutersFacet__addLiquidityForRouter_amountIsZero();\\n\\n    // Get the canonical asset ID from the representation.\\n    (TokenId memory canonical, bytes32 key) = _getApprovedCanonicalId(_local);\\n\\n    // Sanity check: router is approved.\\n    if (!_isRouterWhitelistRemoved() && !getRouterApproval(_router))\\n      revert RoutersFacet__addLiquidityForRouter_badRouter();\\n\\n    if (s.domain == canonical.domain) {\\n      // Sanity check: caps not reached\\n      uint256 custodied = IERC20(_local).balanceOf(address(this)) + _amount;\\n      uint256 cap = s.caps[key];\\n      if (cap > 0 && custodied > cap) {\\n        revert RoutersFacet__addLiquidityForRouter_capReached();\\n      }\\n    }\\n\\n    // Transfer funds to contract.\\n    AssetLogic.handleIncomingAsset(_local, _amount);\\n\\n    // Update the router balances. Happens after pulling funds to account for\\n    // the fee on transfer tokens.\\n    s.routerBalances[_router][_local] += _amount;\\n\\n    emit RouterLiquidityAdded(_router, _local, key, _amount, msg.sender);\\n  }\\n\\n  /**\\n   * @notice This is used by any router owner to decrease their available liquidity for a given asset.\\n   * @param _amount - The amount of liquidity to remove for the router\\n   * @param _local - The address of the asset you're removing liquidity from. If removing liquidity of the\\n   * native asset, routers may use `address(0)` or the wrapped asset\\n   * @param _to The address that will receive the liquidity being removed\\n   * @param _router The address of the router\\n   */\\n  function _removeLiquidityForRouter(\\n    uint256 _amount,\\n    address _local,\\n    address payable _to,\\n    address _router\\n  ) internal {\\n    // Transfer to specified recipient IF recipient not set.\\n    address recipient = getRouterRecipient(_router);\\n    recipient = recipient == address(0) ? _to : recipient;\\n\\n    // Sanity check: to is sensible.\\n    if (recipient == address(0)) revert RoutersFacet__removeRouterLiquidity_recipientEmpty();\\n\\n    // Sanity check: nonzero amounts.\\n    if (_amount == 0) revert RoutersFacet__removeRouterLiquidity_amountIsZero();\\n\\n    // Get the canonical asset ID from the representation.\\n    // NOTE: allow getting unapproved assets to prevent lockup on approval status change\\n    TokenId memory canonical = _getCanonicalTokenId(_local);\\n    bytes32 key = AssetLogic.calculateCanonicalHash(canonical.id, canonical.domain);\\n\\n    // Get existing router balance.\\n    uint256 routerBalance = s.routerBalances[_router][_local];\\n\\n    // Sanity check: amount can be deducted for the router.\\n    if (routerBalance < _amount) revert RoutersFacet__removeRouterLiquidity_insufficientFunds();\\n\\n    // Update router balances.\\n    unchecked {\\n      s.routerBalances[_router][_local] = routerBalance - _amount;\\n    }\\n\\n    // Transfer from contract to specified `to` address.\\n    AssetLogic.handleOutgoingAsset(_local, recipient, _amount);\\n\\n    emit RouterLiquidityRemoved(_router, recipient, _local, key, _amount, msg.sender);\\n  }\\n}\\n\",\"keccak256\":\"0x714a6cf621100d62c23252edea5b85594a42aad6c305100a5a59d65e39fe5088\",\"license\":\"UNLICENSED\"},\"contracts/core/connext/helpers/LPToken.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.15;\\n\\nimport {ERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol\\\";\\nimport {OwnableUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\n\\n/**\\n * @title Liquidity Provider Token\\n * @notice This token is an ERC20 detailed token with added capability to be minted by the owner.\\n * It is used to represent user's shares when providing liquidity to swap contracts.\\n * @dev Only Swap contracts should initialize and own LPToken contracts.\\n */\\ncontract LPToken is ERC20Upgradeable, OwnableUpgradeable {\\n  // ============ Upgrade Gap ============\\n\\n  uint256[49] private __GAP; // gap for upgrade safety\\n\\n  // ============ Storage ============\\n\\n  /**\\n   * @notice Used to enforce proper token dilution\\n   * @dev If this is the first mint of the LP token, this amount of funds are burned.\\n   * See audit recommendations here:\\n   * - https://github.com/code-423n4/2022-03-prepo-findings/issues/27\\n   * - https://github.com/code-423n4/2022-04-jpegd-findings/issues/12\\n   * and uniswap v2 implementation here:\\n   * https://github.com/Uniswap/v2-core/blob/8b82b04a0b9e696c0e83f8b2f00e5d7be6888c79/contracts/UniswapV2Pair.sol#L15\\n   */\\n  uint256 public constant MINIMUM_LIQUIDITY = 10**3;\\n\\n  // ============ Initializer ============\\n\\n  /**\\n   * @notice Initializes this LPToken contract with the given name and symbol\\n   * @dev The caller of this function will become the owner. A Swap contract should call this\\n   * in its initializer function.\\n   * @param name name of this token\\n   * @param symbol symbol of this token\\n   */\\n  function initialize(string memory name, string memory symbol) external initializer returns (bool) {\\n    __Context_init_unchained();\\n    __ERC20_init_unchained(name, symbol);\\n    __Ownable_init_unchained();\\n    return true;\\n  }\\n\\n  // ============ External functions ============\\n\\n  /**\\n   * @notice Mints the given amount of LPToken to the recipient.\\n   * @dev only owner can call this mint function\\n   * @param recipient address of account to receive the tokens\\n   * @param amount amount of tokens to mint\\n   */\\n  function mint(address recipient, uint256 amount) external onlyOwner {\\n    require(amount != 0, \\\"LPToken: cannot mint 0\\\");\\n    if (totalSupply() == 0) {\\n      // NOTE: using the _mint function directly will error because it is going\\n      // to the 0 address. fix by using the address(1) here instead\\n      _mint(address(1), MINIMUM_LIQUIDITY);\\n    }\\n    _mint(recipient, amount);\\n  }\\n\\n  /**\\n   * @notice Burns the given amount of LPToken from provided account\\n   * @dev only owner can call this burn function\\n   * @param account address of account from which to burn token\\n   * @param amount amount of tokens to mint\\n   */\\n  function burnFrom(address account, uint256 amount) external onlyOwner {\\n    require(amount != 0, \\\"LPToken: cannot burn 0\\\");\\n    _burn(account, amount);\\n  }\\n\\n  // ============ Internal functions ============\\n\\n  /**\\n   * @dev Overrides ERC20._beforeTokenTransfer() which get called on every transfers including\\n   * minting and burning. This ensures that Swap.updateUserWithdrawFees are called everytime.\\n   * This assumes the owner is set to a Swap contract's address.\\n   */\\n  function _beforeTokenTransfer(\\n    address from,\\n    address to,\\n    uint256 amount\\n  ) internal virtual override(ERC20Upgradeable) {\\n    super._beforeTokenTransfer(from, to, amount);\\n    require(to != address(this), \\\"LPToken: cannot send to itself\\\");\\n  }\\n}\\n\",\"keccak256\":\"0x1d3f871488111c70a6f9b09ad3baeb21ebc635c82aa2c6d627d07e09720e4126\",\"license\":\"UNLICENSED\"},\"contracts/core/connext/interfaces/IDiamondCut.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\ninterface IDiamondCut {\\n  enum FacetCutAction {\\n    Add,\\n    Replace,\\n    Remove\\n  }\\n  // Add=0, Replace=1, Remove=2\\n\\n  struct FacetCut {\\n    address facetAddress;\\n    FacetCutAction action;\\n    bytes4[] functionSelectors;\\n  }\\n\\n  /// @notice Propose to add/replace/remove any number of functions and optionally execute\\n  ///         a function with delegatecall\\n  /// @param _diamondCut Contains the facet addresses and function selectors\\n  /// @param _init The address of the contract or facet to execute _calldata\\n  /// @param _calldata A function call, including function selector and arguments\\n  ///                  _calldata is executed with delegatecall on _init\\n  function proposeDiamondCut(\\n    FacetCut[] calldata _diamondCut,\\n    address _init,\\n    bytes calldata _calldata\\n  ) external;\\n\\n  event DiamondCutProposed(FacetCut[] _diamondCut, address _init, bytes _calldata, uint256 deadline);\\n\\n  /// @notice Add/replace/remove any number of functions and optionally execute\\n  ///         a function with delegatecall\\n  /// @param _diamondCut Contains the facet addresses and function selectors\\n  /// @param _init The address of the contract or facet to execute _calldata\\n  /// @param _calldata A function call, including function selector and arguments\\n  ///                  _calldata is executed with delegatecall on _init\\n  function diamondCut(\\n    FacetCut[] calldata _diamondCut,\\n    address _init,\\n    bytes calldata _calldata\\n  ) external;\\n\\n  event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n  /// @notice Propose to add/replace/remove any number of functions and optionally execute\\n  ///         a function with delegatecall\\n  /// @param _diamondCut Contains the facet addresses and function selectors\\n  /// @param _init The address of the contract or facet to execute _calldata\\n  /// @param _calldata A function call, including function selector and arguments\\n  ///                  _calldata is executed with delegatecall on _init\\n  function rescindDiamondCut(\\n    FacetCut[] calldata _diamondCut,\\n    address _init,\\n    bytes calldata _calldata\\n  ) external;\\n\\n  event DiamondCutRescinded(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\",\"keccak256\":\"0xd75a7bfdb3aeac3acebf8cf999330a0fc7bec65e9a68711bbb58f4554ef087b2\",\"license\":\"MIT\"},\"contracts/core/connext/interfaces/IStableSwap.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.15;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IStableSwap {\\n  /*** EVENTS ***/\\n\\n  // events replicated from SwapUtils to make the ABI easier for dumb\\n  // clients\\n  event TokenSwap(address indexed buyer, uint256 tokensSold, uint256 tokensBought, uint128 soldId, uint128 boughtId);\\n  event AddLiquidity(\\n    address indexed provider,\\n    uint256[] tokenAmounts,\\n    uint256[] fees,\\n    uint256 invariant,\\n    uint256 lpTokenSupply\\n  );\\n  event RemoveLiquidity(address indexed provider, uint256[] tokenAmounts, uint256 lpTokenSupply);\\n  event RemoveLiquidityOne(\\n    address indexed provider,\\n    uint256 lpTokenAmount,\\n    uint256 lpTokenSupply,\\n    uint256 boughtId,\\n    uint256 tokensBought\\n  );\\n  event RemoveLiquidityImbalance(\\n    address indexed provider,\\n    uint256[] tokenAmounts,\\n    uint256[] fees,\\n    uint256 invariant,\\n    uint256 lpTokenSupply\\n  );\\n  event NewAdminFee(uint256 newAdminFee);\\n  event NewSwapFee(uint256 newSwapFee);\\n  event NewWithdrawFee(uint256 newWithdrawFee);\\n  event RampA(uint256 oldA, uint256 newA, uint256 initialTime, uint256 futureTime);\\n  event StopRampA(uint256 currentA, uint256 time);\\n\\n  function swap(\\n    uint8 tokenIndexFrom,\\n    uint8 tokenIndexTo,\\n    uint256 dx,\\n    uint256 minDy,\\n    uint256 deadline\\n  ) external returns (uint256);\\n\\n  function swapExact(\\n    uint256 amountIn,\\n    address assetIn,\\n    address assetOut,\\n    uint256 minAmountOut,\\n    uint256 deadline\\n  ) external payable returns (uint256);\\n\\n  function swapExactOut(\\n    uint256 amountOut,\\n    address assetIn,\\n    address assetOut,\\n    uint256 maxAmountIn,\\n    uint256 deadline\\n  ) external payable returns (uint256);\\n\\n  function getA() external view returns (uint256);\\n\\n  function getToken(uint8 index) external view returns (IERC20);\\n\\n  function getTokenIndex(address tokenAddress) external view returns (uint8);\\n\\n  function getTokenBalance(uint8 index) external view returns (uint256);\\n\\n  function getVirtualPrice() external view returns (uint256);\\n\\n  // min return calculation functions\\n  function calculateSwap(\\n    uint8 tokenIndexFrom,\\n    uint8 tokenIndexTo,\\n    uint256 dx\\n  ) external view returns (uint256);\\n\\n  function calculateSwapOut(\\n    uint8 tokenIndexFrom,\\n    uint8 tokenIndexTo,\\n    uint256 dy\\n  ) external view returns (uint256);\\n\\n  function calculateSwapFromAddress(\\n    address assetIn,\\n    address assetOut,\\n    uint256 amountIn\\n  ) external view returns (uint256);\\n\\n  function calculateSwapOutFromAddress(\\n    address assetIn,\\n    address assetOut,\\n    uint256 amountOut\\n  ) external view returns (uint256);\\n\\n  function calculateTokenAmount(uint256[] calldata amounts, bool deposit) external view returns (uint256);\\n\\n  function calculateRemoveLiquidity(uint256 amount) external view returns (uint256[] memory);\\n\\n  function calculateRemoveLiquidityOneToken(uint256 tokenAmount, uint8 tokenIndex)\\n    external\\n    view\\n    returns (uint256 availableTokenAmount);\\n\\n  // state modifying functions\\n  function initialize(\\n    IERC20[] memory pooledTokens,\\n    uint8[] memory decimals,\\n    string memory lpTokenName,\\n    string memory lpTokenSymbol,\\n    uint256 a,\\n    uint256 fee,\\n    uint256 adminFee,\\n    address lpTokenTargetAddress\\n  ) external;\\n\\n  function addLiquidity(\\n    uint256[] calldata amounts,\\n    uint256 minToMint,\\n    uint256 deadline\\n  ) external returns (uint256);\\n\\n  function removeLiquidity(\\n    uint256 amount,\\n    uint256[] calldata minAmounts,\\n    uint256 deadline\\n  ) external returns (uint256[] memory);\\n\\n  function removeLiquidityOneToken(\\n    uint256 tokenAmount,\\n    uint8 tokenIndex,\\n    uint256 minAmount,\\n    uint256 deadline\\n  ) external returns (uint256);\\n\\n  function removeLiquidityImbalance(\\n    uint256[] calldata amounts,\\n    uint256 maxBurnAmount,\\n    uint256 deadline\\n  ) external returns (uint256);\\n}\\n\",\"keccak256\":\"0xfbbb2cad0639658aa781212c69df10718250a6926d94a1a7508fc9927216abe8\",\"license\":\"UNLICENSED\"},\"contracts/core/connext/libraries/AmplificationUtils.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.15;\\n\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\nimport {SwapUtils} from \\\"./SwapUtils.sol\\\";\\n\\n/**\\n * @title AmplificationUtils library\\n * @notice A library to calculate and ramp the A parameter of a given `SwapUtils.Swap` struct.\\n * This library assumes the struct is fully validated.\\n */\\nlibrary AmplificationUtils {\\n  event RampA(uint256 oldA, uint256 newA, uint256 initialTime, uint256 futureTime);\\n  event StopRampA(uint256 currentA, uint256 time);\\n\\n  // Constant values used in ramping A calculations\\n  uint256 public constant A_PRECISION = 100;\\n  uint256 public constant MAX_A = 10**6;\\n  uint256 private constant MAX_A_CHANGE = 2;\\n  uint256 private constant MIN_RAMP_TIME = 14 days;\\n\\n  /**\\n   * @notice Return A, the amplification coefficient * n * (n - 1)\\n   * @dev See the StableSwap paper for details\\n   * @param self Swap struct to read from\\n   * @return A parameter\\n   */\\n  function getA(SwapUtils.Swap storage self) internal view returns (uint256) {\\n    return _getAPrecise(self) / A_PRECISION;\\n  }\\n\\n  /**\\n   * @notice Return A in its raw precision\\n   * @dev See the StableSwap paper for details\\n   * @param self Swap struct to read from\\n   * @return A parameter in its raw precision form\\n   */\\n  function getAPrecise(SwapUtils.Swap storage self) internal view returns (uint256) {\\n    return _getAPrecise(self);\\n  }\\n\\n  /**\\n   * @notice Return A in its raw precision\\n   * @dev See the StableSwap paper for details\\n   * @param self Swap struct to read from\\n   * @return A parameter in its raw precision form\\n   */\\n  function _getAPrecise(SwapUtils.Swap storage self) internal view returns (uint256) {\\n    uint256 t1 = self.futureATime; // time when ramp is finished\\n    uint256 a1 = self.futureA; // final A value when ramp is finished\\n\\n    if (block.timestamp < t1) {\\n      uint256 t0 = self.initialATime; // time when ramp is started\\n      uint256 a0 = self.initialA; // initial A value when ramp is started\\n      if (a1 > a0) {\\n        // a0 + (a1 - a0) * (block.timestamp - t0) / (t1 - t0)\\n        return a0 + ((a1 - a0) * (block.timestamp - t0)) / (t1 - t0);\\n      } else {\\n        // a0 - (a0 - a1) * (block.timestamp - t0) / (t1 - t0)\\n        return a0 - ((a0 - a1) * (block.timestamp - t0)) / (t1 - t0);\\n      }\\n    } else {\\n      return a1;\\n    }\\n  }\\n\\n  /**\\n   * @notice Start ramping up or down A parameter towards given futureA_ and futureTime_\\n   * Checks if the change is too rapid, and commits the new A value only when it falls under\\n   * the limit range.\\n   * @param self Swap struct to update\\n   * @param futureA_ the new A to ramp towards\\n   * @param futureTime_ timestamp when the new A should be reached\\n   */\\n  function rampA(\\n    SwapUtils.Swap storage self,\\n    uint256 futureA_,\\n    uint256 futureTime_\\n  ) internal {\\n    require(block.timestamp >= self.initialATime + 1 days, \\\"Wait 1 day before starting ramp\\\");\\n    require(futureTime_ >= block.timestamp + MIN_RAMP_TIME, \\\"Insufficient ramp time\\\");\\n    require(futureA_ != 0 && futureA_ < MAX_A, \\\"futureA_ must be > 0 and < MAX_A\\\");\\n\\n    uint256 initialAPrecise = _getAPrecise(self);\\n    uint256 futureAPrecise = futureA_ * A_PRECISION;\\n\\n    if (futureAPrecise < initialAPrecise) {\\n      require(futureAPrecise * MAX_A_CHANGE >= initialAPrecise, \\\"futureA_ is too small\\\");\\n    } else {\\n      require(futureAPrecise <= initialAPrecise * MAX_A_CHANGE, \\\"futureA_ is too large\\\");\\n    }\\n\\n    self.initialA = initialAPrecise;\\n    self.futureA = futureAPrecise;\\n    self.initialATime = block.timestamp;\\n    self.futureATime = futureTime_;\\n\\n    emit RampA(initialAPrecise, futureAPrecise, block.timestamp, futureTime_);\\n  }\\n\\n  /**\\n   * @notice Stops ramping A immediately. Once this function is called, rampA()\\n   * cannot be called for another 24 hours\\n   * @param self Swap struct to update\\n   */\\n  function stopRampA(SwapUtils.Swap storage self) internal {\\n    require(self.futureATime > block.timestamp, \\\"Ramp is already stopped\\\");\\n\\n    uint256 currentA = _getAPrecise(self);\\n    self.initialA = currentA;\\n    self.futureA = currentA;\\n    self.initialATime = block.timestamp;\\n    self.futureATime = block.timestamp;\\n\\n    emit StopRampA(currentA, block.timestamp);\\n  }\\n}\\n\",\"keccak256\":\"0x7dca96b10fa307f469c142aaea0855d3c9ba45f79066eaeae1467ce113fc8d28\",\"license\":\"UNLICENSED\"},\"contracts/core/connext/libraries/AssetLogic.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.15;\\n\\nimport {SafeERC20, Address} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {ERC20} from \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport {TypeCasts} from \\\"../../../shared/libraries/TypeCasts.sol\\\";\\n\\nimport {IStableSwap} from \\\"../interfaces/IStableSwap.sol\\\";\\n\\nimport {LibConnextStorage, AppStorage, TokenId} from \\\"./LibConnextStorage.sol\\\";\\nimport {SwapUtils} from \\\"./SwapUtils.sol\\\";\\n\\nlibrary AssetLogic {\\n  // ============ Libraries ============\\n\\n  using SwapUtils for SwapUtils.Swap;\\n\\n  // ============ Errors ============\\n\\n  error AssetLogic__handleIncomingAsset_nativeAssetNotSupported();\\n  error AssetLogic__handleIncomingAsset_feeOnTransferNotSupported();\\n  error AssetLogic__handleOutgoingAsset_notNative();\\n  error AssetLogic__swapToLocalAssetIfNeeded_swapPaused();\\n  error AssetLogic__swapFromLocalAssetIfNeeded_swapPaused();\\n  error AssetLogic__getTokenIndexFromStableSwapPool_notExist();\\n\\n  // ============ Internal: Handle Transfer ============\\n\\n  /**\\n   * @notice Handles transferring funds from msg.sender to the Connext contract.\\n   * @dev Does NOT work with fee-on-transfer tokens: will revert.\\n   *\\n   * @param _asset - The address of the ERC20 token to transfer.\\n   * @param _amount - The specified amount to transfer.\\n   */\\n  function handleIncomingAsset(address _asset, uint256 _amount) internal {\\n    // Sanity check: if amount is 0, do nothing.\\n    if (_amount == 0) {\\n      return;\\n    }\\n    // Sanity check: asset address is not zero.\\n    if (_asset == address(0)) {\\n      revert AssetLogic__handleIncomingAsset_nativeAssetNotSupported();\\n    }\\n\\n    // Record starting amount to validate correct amount is transferred.\\n    uint256 starting = IERC20(_asset).balanceOf(address(this));\\n\\n    // Transfer asset to contract.\\n    SafeERC20.safeTransferFrom(IERC20(_asset), msg.sender, address(this), _amount);\\n\\n    // Ensure correct amount was transferred (i.e. this was not a fee-on-transfer token).\\n    if (IERC20(_asset).balanceOf(address(this)) - starting != _amount) {\\n      revert AssetLogic__handleIncomingAsset_feeOnTransferNotSupported();\\n    }\\n  }\\n\\n  /**\\n   * @notice Handles transferring funds from the Connext contract to msg.sender.\\n   * @param _asset - The address of the ERC20 token to transfer.\\n   * @param _to - The recipient address that will receive the funds.\\n   * @param _amount - The amount to withdraw from contract.\\n   */\\n  function handleOutgoingAsset(\\n    address _asset,\\n    address _to,\\n    uint256 _amount\\n  ) internal {\\n    // Sanity check: if amount is 0, do nothing.\\n    if (_amount == 0) {\\n      return;\\n    }\\n    // Sanity check: asset address is not zero.\\n    if (_asset == address(0)) revert AssetLogic__handleOutgoingAsset_notNative();\\n\\n    // Transfer ERC20 asset to target recipient.\\n    SafeERC20.safeTransfer(IERC20(_asset), _to, _amount);\\n  }\\n\\n  // ============ Internal: StableSwap Pools ============\\n\\n  /**\\n   * @notice Return the index of the given token address. Reverts if no matching\\n   * token is found.\\n   * @param key the hash of the canonical id and domain\\n   * @param tokenAddress address of the token\\n   * @return the index of the given token address\\n   */\\n  function getTokenIndexFromStableSwapPool(bytes32 key, address tokenAddress) internal view returns (uint8) {\\n    AppStorage storage s = LibConnextStorage.connextStorage();\\n    uint8 index = s.tokenIndexes[key][tokenAddress];\\n    if (address(s.swapStorages[key].pooledTokens[index]) != tokenAddress)\\n      revert AssetLogic__getTokenIndexFromStableSwapPool_notExist();\\n    return index;\\n  }\\n\\n  // ============ Internal: Handle Swap ============\\n\\n  /**\\n   * @notice Swaps an adopted asset to the local (representation or canonical) nomad asset.\\n   * @dev Will not swap if the asset passed in is the local asset.\\n   * @param _key - The hash of canonical id and domain.\\n   * @param _asset - The address of the adopted asset to swap into the local asset.\\n   * @param _amount - The amount of the adopted asset to swap.\\n   * @param _slippage - The maximum amount of slippage user will take on from _amount in BPS.\\n   * @return uint256 The amount of local asset received from swap.\\n   */\\n  function swapToLocalAssetIfNeeded(\\n    bytes32 _key,\\n    address _asset,\\n    address _local,\\n    uint256 _amount,\\n    uint256 _slippage\\n  ) internal returns (uint256) {\\n    // If there's no amount, no need to swap.\\n    if (_amount == 0) {\\n      return _amount;\\n    }\\n\\n    // Check the case where the adopted asset *is* the local asset. If so, no need to swap.\\n    if (_local == _asset) {\\n      return _amount;\\n    }\\n\\n    // Swap the asset to the proper local asset.\\n    (uint256 out, ) = _swapAsset(\\n      _key,\\n      _asset,\\n      _local,\\n      _amount,\\n      calculateSlippageBoundary(ERC20(_asset).decimals(), ERC20(_local).decimals(), _amount, _slippage)\\n    );\\n    return out;\\n  }\\n\\n  /**\\n   * @notice Swaps a local nomad asset for the adopted asset using the stored stable swap\\n   * @dev Will not swap if the asset passed in is the adopted asset\\n   * @param _key the hash of the canonical id and domain\\n   * @param _asset - The address of the local asset to swap into the adopted asset\\n   * @param _amount - The amount of the local asset to swap\\n   * @param _slippage - The minimum amount of slippage user will take on from _amount in BPS\\n   * @param _normalizedIn - The amount sent in on xcall to take the slippage from, in 18 decimals\\n   * by convention\\n   * @return The amount of adopted asset received from swap\\n   * @return The address of asset received post-swap\\n   */\\n  function swapFromLocalAssetIfNeeded(\\n    bytes32 _key,\\n    address _asset,\\n    uint256 _amount,\\n    uint256 _slippage,\\n    uint256 _normalizedIn\\n  ) internal returns (uint256, address) {\\n    AppStorage storage s = LibConnextStorage.connextStorage();\\n\\n    // If the adopted asset is the local asset, no need to swap.\\n    address adopted = s.canonicalToAdopted[_key];\\n    if (adopted == _asset) {\\n      return (_amount, _asset);\\n    }\\n\\n    // If there's no amount, no need to swap.\\n    if (_amount == 0) {\\n      return (_amount, adopted);\\n    }\\n\\n    // Swap the asset to the proper local asset\\n    return\\n      _swapAsset(\\n        _key,\\n        _asset,\\n        adopted,\\n        _amount,\\n        // NOTE: To get the slippage boundary here, you must take the slippage % off of the\\n        // normalized amount in (at 18 decimals by convention), then convert that amount\\n        // to the proper decimals of adopted.\\n        calculateSlippageBoundary(uint8(18), ERC20(adopted).decimals(), _normalizedIn, _slippage)\\n      );\\n  }\\n\\n  /**\\n   * @notice Swaps a local nomad asset for the adopted asset using the stored stable swap\\n   * @dev Will not swap if the asset passed in is the adopted asset\\n   * @param _key the hash of the canonical id and domain\\n   * @param _asset - The address of the local asset to swap into the adopted asset\\n   * @param _amount - The exact amount to receive out of the swap\\n   * @param _maxIn - The most you will supply to the swap\\n   * @return The amount of local asset put into  swap\\n   * @return The address of asset received post-swap\\n   */\\n  function swapFromLocalAssetIfNeededForExactOut(\\n    bytes32 _key,\\n    address _asset,\\n    uint256 _amount,\\n    uint256 _maxIn\\n  )\\n    internal\\n    returns (\\n      bool,\\n      uint256,\\n      address\\n    )\\n  {\\n    AppStorage storage s = LibConnextStorage.connextStorage();\\n\\n    // If the adopted asset is the local asset, no need to swap.\\n    address adopted = s.canonicalToAdopted[_key];\\n    if (adopted == _asset) {\\n      return (true, _amount, _asset);\\n    }\\n\\n    return _swapAssetOut(_key, _asset, adopted, _amount, _maxIn);\\n  }\\n\\n  /**\\n   * @notice Swaps assetIn to assetOut using the stored stable swap or internal swap pool.\\n   * @dev Will not swap if the asset passed in is the adopted asset\\n   * @param _key - The canonical token id\\n   * @param _assetIn - The address of the from asset\\n   * @param _assetOut - The address of the to asset\\n   * @param _amount - The amount of the local asset to swap\\n   * @param _minOut - The minimum amount of `_assetOut` the user will accept\\n   * @return The amount of assetOut\\n   * @return The address of assetOut\\n   */\\n  function _swapAsset(\\n    bytes32 _key,\\n    address _assetIn,\\n    address _assetOut,\\n    uint256 _amount,\\n    uint256 _minOut\\n  ) internal returns (uint256, address) {\\n    AppStorage storage s = LibConnextStorage.connextStorage();\\n\\n    // Retrieve internal swap pool reference.\\n    SwapUtils.Swap storage ipool = s.swapStorages[_key];\\n\\n    if (ipool.exists()) {\\n      // Swap via the internal pool.\\n      return (\\n        ipool.swapInternal(\\n          getTokenIndexFromStableSwapPool(_key, _assetIn),\\n          getTokenIndexFromStableSwapPool(_key, _assetOut),\\n          _amount,\\n          _minOut\\n        ),\\n        _assetOut\\n      );\\n    } else {\\n      // Otherwise, swap via external stableswap pool.\\n      IStableSwap pool = s.adoptedToLocalPools[_key];\\n\\n      SafeERC20.safeApprove(IERC20(_assetIn), address(pool), 0);\\n      SafeERC20.safeIncreaseAllowance(IERC20(_assetIn), address(pool), _amount);\\n\\n      // NOTE: If pool is not registered here, then this call will revert.\\n      return (pool.swapExact(_amount, _assetIn, _assetOut, _minOut, block.timestamp + 3600), _assetOut);\\n    }\\n  }\\n\\n  /**\\n   * @notice Swaps assetIn to assetOut using the stored stable swap or internal swap pool.\\n   * @param _key - The hash of the canonical id and domain.\\n   * @param _assetIn - The address of the from asset.\\n   * @param _assetOut - The address of the to asset.\\n   * @param _amountOut - The amount of the _assetOut to swap.\\n   * @param _maxIn - The most you will supply to the swap.\\n   * @return success Success value. Will be false if the swap was unsuccessful (slippage too\\n   * high).\\n   * @return amountIn The amount of assetIn. Will be 0 if the swap was unsuccessful (slippage\\n   * too high).\\n   * @return assetOut The address of assetOut.\\n   */\\n  function _swapAssetOut(\\n    bytes32 _key,\\n    address _assetIn,\\n    address _assetOut,\\n    uint256 _amountOut,\\n    uint256 _maxIn\\n  )\\n    internal\\n    returns (\\n      bool success,\\n      uint256 amountIn,\\n      address assetOut\\n    )\\n  {\\n    AppStorage storage s = LibConnextStorage.connextStorage();\\n\\n    assetOut = _assetOut;\\n\\n    // Retrieve internal swap pool reference. If it doesn't exist, we'll resort to using an\\n    // external stableswap below.\\n    SwapUtils.Swap storage ipool = s.swapStorages[_key];\\n\\n    // Swap the asset to the proper local asset.\\n    // NOTE: IFF slippage was too high to perform swap in either case: success = false, amountIn = 0\\n    if (ipool.exists()) {\\n      // Swap via the internal pool.\\n      uint8 tokenIndexIn = getTokenIndexFromStableSwapPool(_key, _assetIn);\\n      uint8 tokenIndexOut = getTokenIndexFromStableSwapPool(_key, _assetOut);\\n\\n      // Calculate slippage before performing swap.\\n      // NOTE: This is less efficient then relying on the `swapInternalOut` revert, but makes it easier\\n      // to handle slippage failures (this can be called during reconcile, so must not fail).\\n      if (_maxIn >= ipool.calculateSwapInv(tokenIndexIn, tokenIndexOut, _amountOut)) {\\n        success = true;\\n        amountIn = ipool.swapInternalOut(tokenIndexIn, tokenIndexOut, _amountOut, _maxIn);\\n      }\\n    } else {\\n      // Otherwise, swap via external stableswap pool.\\n      IStableSwap pool = s.adoptedToLocalPools[_key];\\n\\n      // NOTE: This call will revert if the external stableswap pool doesn't exist.\\n      uint256 _amountIn = pool.calculateSwapOutFromAddress(_assetIn, _assetOut, _amountOut);\\n      if (_amountIn <= _maxIn) {\\n        success = true;\\n\\n        // Perform the swap.\\n        // Edge case with some tokens: Example USDT in ETH Mainnet, after the backUnbacked call\\n        // there could be a remaining allowance if not the whole amount is pulled by aave.\\n        // Later, if we try to increase the allowance it will fail. USDT demands if allowance\\n        // is not 0, it has to be set to 0 first.\\n        // Example: https://github.com/aave/aave-v3-periphery/blob/ca184e5278bcbc10d28c3dbbc604041d7cfac50b/contracts/adapters/paraswap/ParaSwapRepayAdapter.sol#L138-L140\\n        SafeERC20.safeApprove(IERC20(_assetIn), address(pool), 0);\\n        SafeERC20.safeIncreaseAllowance(IERC20(_assetIn), address(pool), _amountIn);\\n        amountIn = pool.swapExactOut(_amountOut, _assetIn, _assetOut, _maxIn, block.timestamp + 3600);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @notice Calculate amount of tokens you receive on a local nomad asset for the adopted asset\\n   * using the stored stable swap\\n   * @dev Will not use the stored stable swap if the asset passed in is the local asset\\n   * @param _key - The hash of the canonical id and domain\\n   * @param _asset - The address of the local asset to swap into the local asset\\n   * @param _amount - The amount of the local asset to swap\\n   * @return The amount of local asset received from swap\\n   * @return The address of asset received post-swap\\n   */\\n  function calculateSwapFromLocalAssetIfNeeded(\\n    bytes32 _key,\\n    address _asset,\\n    uint256 _amount\\n  ) internal view returns (uint256, address) {\\n    AppStorage storage s = LibConnextStorage.connextStorage();\\n\\n    // If the adopted asset is the local asset, no need to swap.\\n    address adopted = s.canonicalToAdopted[_key];\\n    if (adopted == _asset) {\\n      return (_amount, _asset);\\n    }\\n\\n    SwapUtils.Swap storage ipool = s.swapStorages[_key];\\n\\n    // Calculate the swap using the appropriate pool.\\n    if (ipool.exists()) {\\n      // Calculate with internal swap pool.\\n      uint8 tokenIndexIn = getTokenIndexFromStableSwapPool(_key, _asset);\\n      uint8 tokenIndexOut = getTokenIndexFromStableSwapPool(_key, adopted);\\n      return (ipool.calculateSwap(tokenIndexIn, tokenIndexOut, _amount), adopted);\\n    } else {\\n      // Otherwise, try to calculate with external pool.\\n      IStableSwap pool = s.adoptedToLocalPools[_key];\\n      // NOTE: This call will revert if no external pool exists.\\n      return (pool.calculateSwapFromAddress(_asset, adopted, _amount), adopted);\\n    }\\n  }\\n\\n  /**\\n   * @notice Calculate amount of tokens you receive of a local nomad asset for the adopted asset\\n   * using the stored stable swap\\n   * @dev Will not use the stored stable swap if the asset passed in is the local asset\\n   * @param _asset - The address of the asset to swap into the local asset\\n   * @param _amount - The amount of the asset to swap\\n   * @return The amount of local asset received from swap\\n   * @return The address of asset received post-swap\\n   */\\n  function calculateSwapToLocalAssetIfNeeded(\\n    bytes32 _key,\\n    address _asset,\\n    address _local,\\n    uint256 _amount\\n  ) internal view returns (uint256, address) {\\n    AppStorage storage s = LibConnextStorage.connextStorage();\\n\\n    // If the asset is the local asset, no swap needed\\n    if (_asset == _local) {\\n      return (_amount, _asset);\\n    }\\n\\n    SwapUtils.Swap storage ipool = s.swapStorages[_key];\\n\\n    // Calculate the swap using the appropriate pool.\\n    if (ipool.exists()) {\\n      // if internal swap pool exists\\n      uint8 tokenIndexIn = getTokenIndexFromStableSwapPool(_key, _asset);\\n      uint8 tokenIndexOut = getTokenIndexFromStableSwapPool(_key, _local);\\n      return (ipool.calculateSwap(tokenIndexIn, tokenIndexOut, _amount), _local);\\n    } else {\\n      IStableSwap pool = s.adoptedToLocalPools[_key];\\n\\n      return (pool.calculateSwapFromAddress(_asset, _local, _amount), _local);\\n    }\\n  }\\n\\n  // ============ Internal: Token ID Helpers ============\\n\\n  /**\\n   * @notice Gets the canonical information for a given candidate.\\n   * @dev First checks the `address(0)` convention, then checks if the asset given is the\\n   * adopted asset, then calculates the local address.\\n   * @return TokenId The canonical token ID information for the given candidate.\\n   */\\n  function getCanonicalTokenId(address _candidate, AppStorage storage s) internal view returns (TokenId memory) {\\n    TokenId memory _canonical;\\n    // If candidate is address(0), return an empty `_canonical`.\\n    if (_candidate == address(0)) {\\n      return _canonical;\\n    }\\n\\n    // Check to see if candidate is an adopted asset.\\n    _canonical = s.adoptedToCanonical[_candidate];\\n    if (_canonical.domain != 0) {\\n      // Candidate is an adopted asset, return canonical info.\\n      return _canonical;\\n    }\\n\\n    // Candidate was not adopted; it could be the local address.\\n    // IFF this domain is the canonical domain, then the local == canonical.\\n    // Otherwise, it will be the representation asset.\\n    if (isLocalOrigin(_candidate, s)) {\\n      // The token originates on this domain, canonical information is the information\\n      // of the candidate\\n      _canonical.domain = s.domain;\\n      _canonical.id = TypeCasts.addressToBytes32(_candidate);\\n    } else {\\n      // on a remote domain, return the representation\\n      _canonical = s.representationToCanonical[_candidate];\\n    }\\n    return _canonical;\\n  }\\n\\n  /**\\n   * @notice Determine if token is of local origin (i.e. it is a locally originating contract,\\n   * and NOT a token deployed by the bridge).\\n   * @param s AppStorage instance.\\n   * @return bool true if token is locally originating, false otherwise.\\n   */\\n  function isLocalOrigin(address _token, AppStorage storage s) internal view returns (bool) {\\n    // If the token contract WAS deployed by the bridge, it will be stored in this mapping.\\n    // If so, the token is NOT of local origin.\\n    if (s.representationToCanonical[_token].domain != 0) {\\n      return false;\\n    }\\n    // If the contract was NOT deployed by the bridge, but the contract does exist, then it\\n    // IS of local origin. Returns true if code exists at `_addr`.\\n    uint256 _codeSize;\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      _codeSize := extcodesize(_token)\\n    }\\n    return _codeSize != 0;\\n  }\\n\\n  /**\\n   * @notice Get the local asset address for a given canonical key, id, and domain.\\n   * @param _key Canonical hash.\\n   * @param _id Canonical ID.\\n   * @param _domain Canonical domain.\\n   * @param s AppStorage instance.\\n   * @return address of the the local asset.\\n   */\\n  function getLocalAsset(\\n    bytes32 _key,\\n    bytes32 _id,\\n    uint32 _domain,\\n    AppStorage storage s\\n  ) internal view returns (address) {\\n    if (_domain == s.domain) {\\n      // Token is of local origin\\n      return TypeCasts.bytes32ToAddress(_id);\\n    } else {\\n      // Token is a representation of a token of remote origin\\n      return s.canonicalToRepresentation[_key];\\n    }\\n  }\\n\\n  /**\\n   * @notice Calculates the hash of canonical ID and domain.\\n   * @dev This hash is used as the key for many asset-related mappings.\\n   * @param _id Canonical ID.\\n   * @param _domain Canonical domain.\\n   * @return bytes32 Canonical hash, used as key for accessing token info from mappings.\\n   */\\n  function calculateCanonicalHash(bytes32 _id, uint32 _domain) internal pure returns (bytes32) {\\n    return keccak256(abi.encode(_id, _domain));\\n  }\\n\\n  // ============ Internal: Math ============\\n\\n  /**\\n   * @notice This function calculates slippage as a %age of the amount in, and normalizes\\n   * That to the `_out` decimals.\\n   *\\n   * @dev This *ONLY* works for 1:1 assets\\n   *\\n   * @param _in The decimals of the asset in / amount in\\n   * @param _out The decimals of the target asset\\n   * @param _amountIn The starting amount for the swap\\n   * @param _slippage The slippage allowed for the swap, in BPS\\n   * @return uint256 The minimum amount out for the swap\\n   */\\n  function calculateSlippageBoundary(\\n    uint8 _in,\\n    uint8 _out,\\n    uint256 _amountIn,\\n    uint256 _slippage\\n  ) internal pure returns (uint256) {\\n    if (_amountIn == 0) {\\n      return 0;\\n    }\\n    // Get the min recieved (in same decimals as _amountIn)\\n    uint256 min = (_amountIn * (10_000 - _slippage)) / 10_000;\\n    return normalizeDecimals(_in, _out, min);\\n  }\\n\\n  /**\\n   * @notice This function translates the _amount in _in decimals\\n   * to _out decimals\\n   *\\n   * @param _in The decimals of the asset in / amount in\\n   * @param _out The decimals of the target asset\\n   * @param _amount The value to normalize to the `_out` decimals\\n   * @return uint256 Normalized decimals.\\n   */\\n  function normalizeDecimals(\\n    uint8 _in,\\n    uint8 _out,\\n    uint256 _amount\\n  ) internal pure returns (uint256) {\\n    if (_in == _out) {\\n      return _amount;\\n    }\\n    // Convert this value to the same decimals as _out\\n    uint256 normalized;\\n    if (_in < _out) {\\n      normalized = _amount * (10**(_out - _in));\\n    } else {\\n      normalized = _amount / (10**(_in - _out));\\n    }\\n    return normalized;\\n  }\\n}\\n\",\"keccak256\":\"0x0c1420903ed5079b70b51217353ec83bed1c7200740731a3b5b3b2241e01cd02\",\"license\":\"UNLICENSED\"},\"contracts/core/connext/libraries/LibConnextStorage.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.15;\\n\\nimport {IStableSwap} from \\\"../interfaces/IStableSwap.sol\\\";\\nimport {IConnectorManager} from \\\"../../../messaging/interfaces/IConnectorManager.sol\\\";\\nimport {SwapUtils} from \\\"./SwapUtils.sol\\\";\\n\\n// ============= Enum =============\\n\\n/// @notice Enum representing address role\\n// Returns uint\\n// None     - 0\\n// Router   - 1\\n// Watcher  - 2\\n// Admin    - 3\\nenum Role {\\n  None,\\n  Router,\\n  Watcher,\\n  Admin\\n}\\n\\n/**\\n * @notice Enum representing status of destination transfer\\n * @dev Status is only assigned on the destination domain, will always be \\\"none\\\" for the\\n * origin domains\\n * @return uint - Index of value in enum\\n */\\nenum DestinationTransferStatus {\\n  None, // 0\\n  Reconciled, // 1\\n  Executed, // 2\\n  Completed // 3 - executed + reconciled\\n}\\n\\n// ============= Structs =============\\n\\nstruct TokenId {\\n  uint32 domain;\\n  bytes32 id;\\n}\\n\\n/**\\n * @notice These are the parameters that will remain constant between the\\n * two chains. They are supplied on `xcall` and should be asserted on `execute`\\n * @property to - The account that receives funds, in the event of a crosschain call,\\n * will receive funds if the call fails.\\n *\\n * @param originDomain - The originating domain (i.e. where `xcall` is called). Must match nomad domain schema\\n * @param destinationDomain - The final domain (i.e. where `execute` / `reconcile` are called). Must match nomad domain schema\\n * @param canonicalDomain - The canonical domain of the asset you are bridging\\n * @param to - The address you are sending funds (and potentially data) to\\n * @param delegate - An address who can execute txs on behalf of `to`, in addition to allowing relayers\\n * @param receiveLocal - If true, will use the local nomad asset on the destination instead of adopted.\\n * @param callData - The data to execute on the receiving chain. If no crosschain call is needed, then leave empty.\\n * @param slippage - Slippage user is willing to accept from original amount in expressed in BPS (i.e. if\\n * a user takes 1% slippage, this is expressed as 1_000)\\n * @param originSender - The msg.sender of the xcall\\n * @param bridgedAmt - The amount sent over the bridge (after potential AMM on xcall)\\n * @param normalizedIn - The amount sent to `xcall`, normalized to 18 decimals\\n * @param nonce - The nonce on the origin domain used to ensure the transferIds are unique\\n * @param canonicalId - The unique identifier of the canonical token corresponding to bridge assets\\n */\\nstruct TransferInfo {\\n  uint32 originDomain;\\n  uint32 destinationDomain;\\n  uint32 canonicalDomain;\\n  address to;\\n  address delegate;\\n  bool receiveLocal;\\n  bytes callData;\\n  uint256 slippage;\\n  address originSender;\\n  uint256 bridgedAmt;\\n  uint256 normalizedIn;\\n  uint256 nonce;\\n  bytes32 canonicalId;\\n}\\n\\n/**\\n * @notice\\n * @param params - The TransferInfo. These are consistent across sending and receiving chains.\\n * @param routers - The routers who you are sending the funds on behalf of.\\n * @param routerSignatures - Signatures belonging to the routers indicating permission to use funds\\n * for the signed transfer ID.\\n * @param sequencer - The sequencer who assigned the router path to this transfer.\\n * @param sequencerSignature - Signature produced by the sequencer for path assignment accountability\\n * for the path that was signed.\\n */\\nstruct ExecuteArgs {\\n  TransferInfo params;\\n  address[] routers;\\n  bytes[] routerSignatures;\\n  address sequencer;\\n  bytes sequencerSignature;\\n}\\n\\n/**\\n * @notice Contains RouterFacet related state\\n * @param approvedRouters - Mapping of whitelisted router addresses\\n * @param routerRecipients - Mapping of router withdraw recipient addresses.\\n * If set, all liquidity is withdrawn only to this address. Must be set by routerOwner\\n * (if configured) or the router itself\\n * @param routerOwners - Mapping of router owners\\n * If set, can update the routerRecipient\\n * @param proposedRouterOwners - Mapping of proposed router owners\\n * Must wait timeout to set the\\n * @param proposedRouterTimestamp - Mapping of proposed router owners timestamps\\n * When accepting a proposed owner, must wait for delay to elapse\\n */\\nstruct RouterPermissionsManagerInfo {\\n  mapping(address => bool) approvedRouters;\\n  mapping(address => bool) approvedForPortalRouters;\\n  mapping(address => address) routerRecipients;\\n  mapping(address => address) routerOwners;\\n  mapping(address => address) proposedRouterOwners;\\n  mapping(address => uint256) proposedRouterTimestamp;\\n}\\n\\nstruct AppStorage {\\n  //\\n  // 0\\n  bool initialized;\\n  //\\n  // Connext\\n  //\\n  // 1\\n  uint256 LIQUIDITY_FEE_NUMERATOR;\\n  /**\\n   * @notice The local address that is custodying relayer fees\\n   */\\n  // 2\\n  address relayerFeeVault;\\n  /**\\n   * @notice Nonce for the contract, used to keep unique transfer ids.\\n   * @dev Assigned at first interaction (xcall on origin domain).\\n   */\\n  // 3\\n  uint256 nonce;\\n  /**\\n   * @notice The domain this contract exists on.\\n   * @dev Must match the nomad domain, which is distinct from the \\\"chainId\\\".\\n   */\\n  // 4\\n  uint32 domain;\\n  /**\\n   * @notice Mapping holding the AMMs for swapping in and out of local assets.\\n   * @dev Swaps for an adopted asset <> nomad local asset (i.e. POS USDC <> madUSDC on polygon).\\n   * This mapping is keyed on the hash of the canonical id + domain for local asset.\\n   */\\n  // 6\\n  mapping(bytes32 => IStableSwap) adoptedToLocalPools;\\n  /**\\n   * @notice Mapping of whitelisted assets on same domain as contract.\\n   * @dev Mapping is keyed on the hash of the canonical id and domain\\n   */\\n  // 7\\n  mapping(bytes32 => bool) approvedAssets;\\n  /**\\n   * @notice Mapping of liquidity caps of whitelisted assets. If 0, no cap is enforced.\\n   * @dev Mapping is keyed on the hash of the canonical id and domain\\n   */\\n  // 7\\n  mapping(bytes32 => uint256) caps;\\n  /**\\n   * @notice Mapping of adopted to canonical asset information.\\n   * @dev If the adopted asset is the native asset, the keyed address will\\n   * be the wrapped asset address.\\n   */\\n  // 8\\n  mapping(address => TokenId) adoptedToCanonical;\\n  /**\\n   * @notice Mapping of representation to canonical asset information.\\n   */\\n  // 9\\n  mapping(address => TokenId) representationToCanonical;\\n  /**\\n   * @notice Mapping of hash(canonicalId, canonicalDomain) to adopted asset on this domain.\\n   * @dev If the adopted asset is the native asset, the stored address will be the\\n   * wrapped asset address.\\n   */\\n  // 10\\n  mapping(bytes32 => address) canonicalToAdopted;\\n  /**\\n   * @notice Mapping of canonical to representation asset information.\\n   * @dev If the token is of local origin (meaning it was originanlly deployed on this chain),\\n   * this MUST map to address(0).\\n   */\\n  // 11\\n  mapping(bytes32 => address) canonicalToRepresentation;\\n  /**\\n   * @notice Mapping to track transfer status on destination domain\\n   */\\n  // 12\\n  mapping(bytes32 => DestinationTransferStatus) transferStatus;\\n  /**\\n   * @notice Mapping holding router address that provided fast liquidity.\\n   */\\n  // 13\\n  mapping(bytes32 => address[]) routedTransfers;\\n  /**\\n   * @notice Mapping of router to available balance of an asset.\\n   * @dev Routers should always store liquidity that they can expect to receive via the bridge on\\n   * this domain (the nomad local asset).\\n   */\\n  // 14\\n  mapping(address => mapping(address => uint256)) routerBalances;\\n  /**\\n   * @notice Mapping of approved relayers\\n   * @dev Send relayer fee if msg.sender is approvedRelayer; otherwise revert.\\n   */\\n  // 15\\n  mapping(address => bool) approvedRelayers;\\n  /**\\n   * @notice The max amount of routers a payment can be routed through.\\n   */\\n  // 18\\n  uint256 maxRoutersPerTransfer;\\n  /**\\n   * @notice Stores a mapping of transfer id to slippage overrides.\\n   */\\n  // 20\\n  mapping(bytes32 => uint256) slippage;\\n  /**\\n   * @notice Stores a mapping of remote routers keyed on domains.\\n   * @dev Addresses are cast to bytes32.\\n   * This mapping is required because the Connext now contains the BridgeRouter and must implement\\n   * the remotes interface.\\n   */\\n  // 21\\n  mapping(uint32 => bytes32) remotes;\\n  //\\n  // ProposedOwnable\\n  //\\n  // 22\\n  address _proposed;\\n  // 23\\n  uint256 _proposedOwnershipTimestamp;\\n  // 24\\n  bool _routerWhitelistRemoved;\\n  // 25\\n  uint256 _routerWhitelistTimestamp;\\n  // 26\\n  bool _assetWhitelistRemoved;\\n  // 27\\n  uint256 _assetWhitelistTimestamp;\\n  /**\\n   * @notice Stores a mapping of address to Roles\\n   * @dev returns uint representing the enum Role value\\n   */\\n  // 28\\n  mapping(address => Role) roles;\\n  //\\n  // RouterFacet\\n  //\\n  // 29\\n  RouterPermissionsManagerInfo routerPermissionInfo;\\n  //\\n  // ReentrancyGuard\\n  //\\n  // 30\\n  uint256 _status;\\n  //\\n  // StableSwap\\n  //\\n  /**\\n   * @notice Mapping holding the AMM storages for swapping in and out of local assets\\n   * @dev Swaps for an adopted asset <> nomad local asset (i.e. POS USDC <> madUSDC on polygon)\\n   * Struct storing data responsible for automatic market maker functionalities. In order to\\n   * access this data, this contract uses SwapUtils library. For more details, see SwapUtils.sol.\\n   */\\n  // 31\\n  mapping(bytes32 => SwapUtils.Swap) swapStorages;\\n  /**\\n   * @notice Maps token address to an index in the pool. Used to prevent duplicate tokens in the pool.\\n   * @dev getTokenIndex function also relies on this mapping to retrieve token index.\\n   */\\n  // 32\\n  mapping(bytes32 => mapping(address => uint8)) tokenIndexes;\\n  /**\\n   * @notice Stores whether or not bribing, AMMs, have been paused.\\n   */\\n  // 33\\n  bool _paused;\\n  //\\n  // AavePortals\\n  //\\n  /**\\n   * @notice Address of Aave Pool contract.\\n   */\\n  // 34\\n  address aavePool;\\n  /**\\n   * @notice Fee percentage numerator for using Portal liquidity.\\n   * @dev Assumes the same basis points as the liquidity fee.\\n   */\\n  // 35\\n  uint256 aavePortalFeeNumerator;\\n  /**\\n   * @notice Mapping to store the transfer liquidity amount provided by Aave Portals.\\n   */\\n  // 36\\n  mapping(bytes32 => uint256) portalDebt;\\n  /**\\n   * @notice Mapping to store the transfer liquidity amount provided by Aave Portals.\\n   */\\n  // 37\\n  mapping(bytes32 => uint256) portalFeeDebt;\\n  /**\\n   * @notice Mapping of approved sequencers\\n   * @dev Sequencer address provided must belong to an approved sequencer in order to call `execute`\\n   * for the fast liquidity route.\\n   */\\n  // 38\\n  mapping(address => bool) approvedSequencers;\\n  /**\\n   * @notice Remote connection manager for xapp.\\n   */\\n  // 39\\n  IConnectorManager xAppConnectionManager;\\n}\\n\\nlibrary LibConnextStorage {\\n  function connextStorage() internal pure returns (AppStorage storage ds) {\\n    assembly {\\n      ds.slot := 0\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x24f998cc9edbb1f3f00c7148d18b7ca0d40eaaac7e3f7fa990ffe89bdee8ec32\",\"license\":\"UNLICENSED\"},\"contracts/core/connext/libraries/LibDiamond.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.15;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\nimport {IDiamondCut} from \\\"../interfaces/IDiamondCut.sol\\\";\\n\\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\\n// The loupe functions are required by the EIP2535 Diamonds standard\\n\\nlibrary LibDiamond {\\n  bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n  struct FacetAddressAndPosition {\\n    address facetAddress;\\n    uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\\n  }\\n\\n  struct FacetFunctionSelectors {\\n    bytes4[] functionSelectors;\\n    uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\\n  }\\n\\n  struct DiamondStorage {\\n    // maps function selector to the facet address and\\n    // the position of the selector in the facetFunctionSelectors.selectors array\\n    mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\\n    // maps facet addresses to function selectors\\n    mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\\n    // facet addresses\\n    address[] facetAddresses;\\n    // Used to query if a contract implements an interface.\\n    // Used to implement ERC-165.\\n    mapping(bytes4 => bool) supportedInterfaces;\\n    // owner of the contract\\n    address contractOwner;\\n    // hash of proposed facets => acceptance time\\n    mapping(bytes32 => uint256) acceptanceTimes;\\n    // acceptance delay for upgrading facets\\n    uint256 acceptanceDelay;\\n  }\\n\\n  function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n    bytes32 position = DIAMOND_STORAGE_POSITION;\\n    assembly {\\n      ds.slot := position\\n    }\\n  }\\n\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n  function setContractOwner(address _newOwner) internal {\\n    DiamondStorage storage ds = diamondStorage();\\n    address previousOwner = ds.contractOwner;\\n    ds.contractOwner = _newOwner;\\n    emit OwnershipTransferred(previousOwner, _newOwner);\\n  }\\n\\n  function contractOwner() internal view returns (address contractOwner_) {\\n    contractOwner_ = diamondStorage().contractOwner;\\n  }\\n\\n  function acceptanceDelay() internal view returns (uint256) {\\n    return diamondStorage().acceptanceDelay;\\n  }\\n\\n  function acceptanceTime(bytes32 _key) internal view returns (uint256) {\\n    return diamondStorage().acceptanceTimes[_key];\\n  }\\n\\n  function enforceIsContractOwner() internal view {\\n    require(msg.sender == diamondStorage().contractOwner, \\\"LibDiamond: !contract owner\\\");\\n  }\\n\\n  event DiamondCutProposed(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata, uint256 deadline);\\n\\n  function proposeDiamondCut(\\n    IDiamondCut.FacetCut[] memory _diamondCut,\\n    address _init,\\n    bytes memory _calldata\\n  ) internal {\\n    DiamondStorage storage ds = diamondStorage();\\n    uint256 acceptance = block.timestamp + ds.acceptanceDelay;\\n    ds.acceptanceTimes[keccak256(abi.encode(_diamondCut, _init, _calldata))] = acceptance;\\n    emit DiamondCutProposed(_diamondCut, _init, _calldata, acceptance);\\n  }\\n\\n  event DiamondCutRescinded(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n  function rescindDiamondCut(\\n    IDiamondCut.FacetCut[] memory _diamondCut,\\n    address _init,\\n    bytes memory _calldata\\n  ) internal {\\n    // NOTE: you can always rescind a proposed facet cut as the owner, even if outside of the validity\\n    // period or befor the delay elpases\\n    diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut, _init, _calldata))] = 0;\\n    emit DiamondCutRescinded(_diamondCut, _init, _calldata);\\n  }\\n\\n  event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n  // Internal function version of diamondCut\\n  function diamondCut(\\n    IDiamondCut.FacetCut[] memory _diamondCut,\\n    address _init,\\n    bytes memory _calldata\\n  ) internal {\\n    DiamondStorage storage ds = diamondStorage();\\n    if (ds.facetAddresses.length != 0) {\\n      uint256 time = ds.acceptanceTimes[keccak256(abi.encode(_diamondCut, _init, _calldata))];\\n      require(time != 0 && time <= block.timestamp, \\\"LibDiamond: delay not elapsed\\\");\\n    } // Otherwise, this is the first instance of deployment and it can be set automatically\\n    for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n      IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\\n      if (action == IDiamondCut.FacetCutAction.Add) {\\n        addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n      } else if (action == IDiamondCut.FacetCutAction.Replace) {\\n        replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n      } else if (action == IDiamondCut.FacetCutAction.Remove) {\\n        removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n      } else {\\n        revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\n      }\\n    }\\n    emit DiamondCut(_diamondCut, _init, _calldata);\\n    initializeDiamondCut(_init, _calldata);\\n  }\\n\\n  function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n    require(_functionSelectors.length != 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n    DiamondStorage storage ds = diamondStorage();\\n    require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n    uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n    // add new facet address if it does not exist\\n    if (selectorPosition == 0) {\\n      addFacet(ds, _facetAddress);\\n    }\\n    for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n      bytes4 selector = _functionSelectors[selectorIndex];\\n      address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n      require(oldFacetAddress == address(0), \\\"LibDiamondCut: Can't add function that already exists\\\");\\n      addFunction(ds, selector, selectorPosition, _facetAddress);\\n      selectorPosition++;\\n    }\\n  }\\n\\n  function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n    require(_functionSelectors.length != 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n    DiamondStorage storage ds = diamondStorage();\\n    require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n    uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n    // add new facet address if it does not exist\\n    if (selectorPosition == 0) {\\n      addFacet(ds, _facetAddress);\\n    }\\n    for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n      bytes4 selector = _functionSelectors[selectorIndex];\\n      address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n      require(oldFacetAddress != _facetAddress, \\\"LibDiamondCut: Can't replace function with same function\\\");\\n      removeFunction(ds, oldFacetAddress, selector);\\n      addFunction(ds, selector, selectorPosition, _facetAddress);\\n      selectorPosition++;\\n    }\\n  }\\n\\n  function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n    require(_functionSelectors.length != 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n    DiamondStorage storage ds = diamondStorage();\\n    // if function does not exist then do nothing and return\\n    require(_facetAddress == address(0), \\\"LibDiamondCut: Remove facet address must be address(0)\\\");\\n    for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n      bytes4 selector = _functionSelectors[selectorIndex];\\n      address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n      removeFunction(ds, oldFacetAddress, selector);\\n    }\\n  }\\n\\n  function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\\n    enforceHasContractCode(_facetAddress, \\\"LibDiamondCut: New facet has no code\\\");\\n    ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\\n    ds.facetAddresses.push(_facetAddress);\\n  }\\n\\n  function addFunction(\\n    DiamondStorage storage ds,\\n    bytes4 _selector,\\n    uint96 _selectorPosition,\\n    address _facetAddress\\n  ) internal {\\n    ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\\n    ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\\n    ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\\n  }\\n\\n  function removeFunction(\\n    DiamondStorage storage ds,\\n    address _facetAddress,\\n    bytes4 _selector\\n  ) internal {\\n    require(_facetAddress != address(0), \\\"LibDiamondCut: Can't remove function that doesn't exist\\\");\\n    // an immutable function is a function defined directly in a diamond\\n    require(_facetAddress != address(this), \\\"LibDiamondCut: Can't remove immutable function\\\");\\n    // replace selector with last selector, then delete last selector\\n    uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\\n    uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\\n    // if not the same then replace _selector with lastSelector\\n    if (selectorPosition != lastSelectorPosition) {\\n      bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\\n      ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\\n      ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\\n    }\\n    // delete the last selector\\n    ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\\n    delete ds.selectorToFacetAndPosition[_selector];\\n\\n    // if no more selectors for facet address then delete the facet address\\n    if (lastSelectorPosition == 0) {\\n      // replace facet address with last facet address and delete last facet address\\n      uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\\n      uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n      if (facetAddressPosition != lastFacetAddressPosition) {\\n        address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\\n        ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\\n        ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\\n      }\\n      ds.facetAddresses.pop();\\n      delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n    }\\n  }\\n\\n  function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n    if (_init == address(0)) {\\n      require(_calldata.length == 0, \\\"LibDiamondCut: _init is address(0) but_calldata is not empty\\\");\\n    } else {\\n      require(_calldata.length != 0, \\\"LibDiamondCut: _calldata is empty but _init is not address(0)\\\");\\n      if (_init != address(this)) {\\n        enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");\\n      }\\n      (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n      if (!success) {\\n        if (error.length != 0) {\\n          // bubble up the error\\n          revert(string(error));\\n        } else {\\n          revert(\\\"LibDiamondCut: _init function reverted\\\");\\n        }\\n      }\\n    }\\n  }\\n\\n  function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n    uint256 contractSize;\\n    assembly {\\n      contractSize := extcodesize(_contract)\\n    }\\n    require(contractSize != 0, _errorMessage);\\n  }\\n}\\n\",\"keccak256\":\"0x0ca55de8a7f4e2256b8b7a5e9ae6cca6d6ff850bbd9fd79542dfc4236871c6d8\",\"license\":\"MIT\"},\"contracts/core/connext/libraries/MathUtils.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.15;\\n\\n/**\\n * @title MathUtils library\\n * @notice A library to be used in conjunction with SafeMath. Contains functions for calculating\\n * differences between two uint256.\\n */\\nlibrary MathUtils {\\n  /**\\n   * @notice Compares a and b and returns true if the difference between a and b\\n   *         is less than 1 or equal to each other.\\n   * @param a uint256 to compare with\\n   * @param b uint256 to compare with\\n   * @return True if the difference between a and b is less than 1 or equal,\\n   *         otherwise return false\\n   */\\n  function within1(uint256 a, uint256 b) internal pure returns (bool) {\\n    return (difference(a, b) <= 1);\\n  }\\n\\n  /**\\n   * @notice Calculates absolute difference between a and b\\n   * @param a uint256 to compare with\\n   * @param b uint256 to compare with\\n   * @return Difference between a and b\\n   */\\n  function difference(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (a > b) {\\n      return a - b;\\n    }\\n    return b - a;\\n  }\\n}\\n\",\"keccak256\":\"0xc0e55e78b6b5fec92fbf16f77f10103450f012394d995c8ace507f1abae29371\",\"license\":\"UNLICENSED\"},\"contracts/core/connext/libraries/SwapUtils.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.15;\\n\\nimport {SafeERC20, IERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\nimport {LPToken} from \\\"../helpers/LPToken.sol\\\";\\n\\nimport {AmplificationUtils} from \\\"./AmplificationUtils.sol\\\";\\nimport {MathUtils} from \\\"./MathUtils.sol\\\";\\n\\n/**\\n * @title SwapUtils library\\n * @notice A library to be used within Swap.sol. Contains functions responsible for custody and AMM functionalities.\\n * @dev Contracts relying on this library must initialize SwapUtils.Swap struct then use this library\\n * for SwapUtils.Swap struct. Note that this library contains both functions called by users and admins.\\n * Admin functions should be protected within contracts using this library.\\n */\\nlibrary SwapUtils {\\n  using SafeERC20 for IERC20;\\n  using MathUtils for uint256;\\n\\n  /*** EVENTS ***/\\n\\n  event TokenSwap(\\n    bytes32 indexed key,\\n    address indexed buyer,\\n    uint256 tokensSold,\\n    uint256 tokensBought,\\n    uint128 soldId,\\n    uint128 boughtId\\n  );\\n  event AddLiquidity(\\n    bytes32 indexed key,\\n    address indexed provider,\\n    uint256[] tokenAmounts,\\n    uint256[] fees,\\n    uint256 invariant,\\n    uint256 lpTokenSupply\\n  );\\n  event RemoveLiquidity(bytes32 indexed key, address indexed provider, uint256[] tokenAmounts, uint256 lpTokenSupply);\\n  event RemoveLiquidityOne(\\n    bytes32 indexed key,\\n    address indexed provider,\\n    uint256 lpTokenAmount,\\n    uint256 lpTokenSupply,\\n    uint256 boughtId,\\n    uint256 tokensBought\\n  );\\n  event RemoveLiquidityImbalance(\\n    bytes32 indexed key,\\n    address indexed provider,\\n    uint256[] tokenAmounts,\\n    uint256[] fees,\\n    uint256 invariant,\\n    uint256 lpTokenSupply\\n  );\\n  event NewAdminFee(bytes32 indexed key, uint256 newAdminFee);\\n  event NewSwapFee(bytes32 indexed key, uint256 newSwapFee);\\n\\n  struct Swap {\\n    // variables around the ramp management of A,\\n    // the amplification coefficient * n * (n - 1)\\n    // see https://www.curve.fi/stableswap-paper.pdf for details\\n    bytes32 key;\\n    uint256 initialA;\\n    uint256 futureA;\\n    uint256 initialATime;\\n    uint256 futureATime;\\n    // fee calculation\\n    uint256 swapFee;\\n    uint256 adminFee;\\n    LPToken lpToken;\\n    // contract references for all tokens being pooled\\n    IERC20[] pooledTokens;\\n    // multipliers for each pooled token's precision to get to POOL_PRECISION_DECIMALS\\n    // for example, TBTC has 18 decimals, so the multiplier should be 1. WBTC\\n    // has 8, so the multiplier should be 10 ** 18 / 10 ** 8 => 10 ** 10\\n    uint256[] tokenPrecisionMultipliers;\\n    // the pool balance of each token, in the token's precision\\n    // the contract's actual token balance might differ\\n    uint256[] balances;\\n    // the admin fee balance of each token, in the token's precision\\n    uint256[] adminFees;\\n  }\\n\\n  // Struct storing variables used in calculations in the\\n  // calculateWithdrawOneTokenDY function to avoid stack too deep errors\\n  struct CalculateWithdrawOneTokenDYInfo {\\n    uint256 d0;\\n    uint256 d1;\\n    uint256 newY;\\n    uint256 feePerToken;\\n    uint256 preciseA;\\n  }\\n\\n  // Struct storing variables used in calculations in the\\n  // {add,remove}Liquidity functions to avoid stack too deep errors\\n  struct ManageLiquidityInfo {\\n    uint256 d0;\\n    uint256 d1;\\n    uint256 d2;\\n    uint256 preciseA;\\n    LPToken lpToken;\\n    uint256 totalSupply;\\n    uint256[] balances;\\n    uint256[] multipliers;\\n  }\\n\\n  // the precision all pools tokens will be converted to\\n  uint8 internal constant POOL_PRECISION_DECIMALS = 18;\\n\\n  // the denominator used to calculate admin and LP fees. For example, an\\n  // LP fee might be something like tradeAmount.mul(fee).div(FEE_DENOMINATOR)\\n  uint256 internal constant FEE_DENOMINATOR = 1e10;\\n\\n  // Max swap fee is 1% or 100bps of each swap\\n  uint256 internal constant MAX_SWAP_FEE = 1e8;\\n\\n  // Max adminFee is 100% of the swapFee\\n  // adminFee does not add additional fee on top of swapFee\\n  // Instead it takes a certain % of the swapFee. Therefore it has no impact on the\\n  // users but only on the earnings of LPs\\n  uint256 internal constant MAX_ADMIN_FEE = 1e10;\\n\\n  // Constant value used as max loop limit\\n  uint256 internal constant MAX_LOOP_LIMIT = 256;\\n\\n  /*** VIEW & PURE FUNCTIONS ***/\\n\\n  function _getAPrecise(Swap storage self) private view returns (uint256) {\\n    return AmplificationUtils._getAPrecise(self);\\n  }\\n\\n  /**\\n   * @notice Calculate the dy, the amount of selected token that user receives and\\n   * the fee of withdrawing in one token\\n   * @param tokenAmount the amount to withdraw in the pool's precision\\n   * @param tokenIndex which token will be withdrawn\\n   * @param self Swap struct to read from\\n   * @return the amount of token user will receive\\n   */\\n  function calculateWithdrawOneToken(\\n    Swap storage self,\\n    uint256 tokenAmount,\\n    uint8 tokenIndex\\n  ) internal view returns (uint256) {\\n    (uint256 availableTokenAmount, ) = _calculateWithdrawOneToken(\\n      self,\\n      tokenAmount,\\n      tokenIndex,\\n      self.lpToken.totalSupply()\\n    );\\n    return availableTokenAmount;\\n  }\\n\\n  function _calculateWithdrawOneToken(\\n    Swap storage self,\\n    uint256 tokenAmount,\\n    uint8 tokenIndex,\\n    uint256 totalSupply\\n  ) private view returns (uint256, uint256) {\\n    uint256 dy;\\n    uint256 newY;\\n    uint256 currentY;\\n\\n    (dy, newY, currentY) = calculateWithdrawOneTokenDY(self, tokenIndex, tokenAmount, totalSupply);\\n\\n    // dy_0 (without fees)\\n    // dy, dy_0 - dy\\n\\n    uint256 dySwapFee = (currentY - newY) / self.tokenPrecisionMultipliers[tokenIndex] - dy;\\n\\n    return (dy, dySwapFee);\\n  }\\n\\n  /**\\n   * @notice Calculate the dy of withdrawing in one token\\n   * @param self Swap struct to read from\\n   * @param tokenIndex which token will be withdrawn\\n   * @param tokenAmount the amount to withdraw in the pools precision\\n   * @return the d and the new y after withdrawing one token\\n   */\\n  function calculateWithdrawOneTokenDY(\\n    Swap storage self,\\n    uint8 tokenIndex,\\n    uint256 tokenAmount,\\n    uint256 totalSupply\\n  )\\n    internal\\n    view\\n    returns (\\n      uint256,\\n      uint256,\\n      uint256\\n    )\\n  {\\n    // Get the current D, then solve the stableswap invariant\\n    // y_i for D - tokenAmount\\n    uint256[] memory xp = _xp(self);\\n\\n    require(tokenIndex < xp.length, \\\"index out of range\\\");\\n\\n    CalculateWithdrawOneTokenDYInfo memory v = CalculateWithdrawOneTokenDYInfo(0, 0, 0, 0, 0);\\n    v.preciseA = _getAPrecise(self);\\n    v.d0 = getD(xp, v.preciseA);\\n    v.d1 = v.d0 - ((tokenAmount * v.d0) / totalSupply);\\n\\n    require(tokenAmount <= xp[tokenIndex], \\\"exceeds available\\\");\\n\\n    v.newY = getYD(v.preciseA, tokenIndex, xp, v.d1);\\n\\n    uint256[] memory xpReduced = new uint256[](xp.length);\\n\\n    v.feePerToken = _feePerToken(self.swapFee, xp.length);\\n    // TODO: Set a length variable (at top) instead of reading xp.length on each loop.\\n    for (uint256 i; i < xp.length; ) {\\n      uint256 xpi = xp[i];\\n      // if i == tokenIndex, dxExpected = xp[i] * d1 / d0 - newY\\n      // else dxExpected = xp[i] - (xp[i] * d1 / d0)\\n      // xpReduced[i] -= dxExpected * fee / FEE_DENOMINATOR\\n      xpReduced[i] =\\n        xpi -\\n        ((((i == tokenIndex) ? ((xpi * v.d1) / v.d0 - v.newY) : (xpi - (xpi * v.d1) / v.d0)) * v.feePerToken) /\\n          FEE_DENOMINATOR);\\n\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n\\n    uint256 dy = xpReduced[tokenIndex] - getYD(v.preciseA, tokenIndex, xpReduced, v.d1);\\n    dy = (dy - 1) / (self.tokenPrecisionMultipliers[tokenIndex]);\\n\\n    return (dy, v.newY, xp[tokenIndex]);\\n  }\\n\\n  /**\\n   * @notice Calculate the price of a token in the pool with given\\n   * precision-adjusted balances and a particular D.\\n   *\\n   * @dev This is accomplished via solving the invariant iteratively.\\n   * See the StableSwap paper and Curve.fi implementation for further details.\\n   *\\n   * x_1**2 + x1 * (sum' - (A*n**n - 1) * D / (A * n**n)) = D ** (n + 1) / (n ** (2 * n) * prod' * A)\\n   * x_1**2 + b*x_1 = c\\n   * x_1 = (x_1**2 + c) / (2*x_1 + b)\\n   *\\n   * @param a the amplification coefficient * n * (n - 1). See the StableSwap paper for details.\\n   * @param tokenIndex Index of token we are calculating for.\\n   * @param xp a precision-adjusted set of pool balances. Array should be\\n   * the same cardinality as the pool.\\n   * @param d the stableswap invariant\\n   * @return the price of the token, in the same precision as in xp\\n   */\\n  function getYD(\\n    uint256 a,\\n    uint8 tokenIndex,\\n    uint256[] memory xp,\\n    uint256 d\\n  ) internal pure returns (uint256) {\\n    uint256 numTokens = xp.length;\\n    require(tokenIndex < numTokens, \\\"Token not found\\\");\\n\\n    uint256 c = d;\\n    uint256 s;\\n    uint256 nA = a * numTokens;\\n\\n    for (uint256 i; i < numTokens; ) {\\n      if (i != tokenIndex) {\\n        s += xp[i];\\n        c = (c * d) / (xp[i] * numTokens);\\n        // If we were to protect the division loss we would have to keep the denominator separate\\n        // and divide at the end. However this leads to overflow with large numTokens or/and D.\\n        // c = c * D * D * D * ... overflow!\\n      }\\n\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n    c = (c * d * AmplificationUtils.A_PRECISION) / (nA * numTokens);\\n\\n    uint256 b = s + ((d * AmplificationUtils.A_PRECISION) / nA);\\n    uint256 yPrev;\\n    uint256 y = d;\\n    for (uint256 i; i < MAX_LOOP_LIMIT; ) {\\n      yPrev = y;\\n      y = ((y * y) + c) / ((y * 2) + b - d);\\n      if (y.within1(yPrev)) {\\n        return y;\\n      }\\n\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n    revert(\\\"Approximation did not converge\\\");\\n  }\\n\\n  /**\\n   * @notice Get D, the StableSwap invariant, based on a set of balances and a particular A.\\n   * @param xp a precision-adjusted set of pool balances. Array should be the same cardinality\\n   * as the pool.\\n   * @param a the amplification coefficient * n * (n - 1) in A_PRECISION.\\n   * See the StableSwap paper for details\\n   * @return the invariant, at the precision of the pool\\n   */\\n  function getD(uint256[] memory xp, uint256 a) internal pure returns (uint256) {\\n    uint256 numTokens = xp.length;\\n    uint256 s;\\n    for (uint256 i; i < numTokens; ) {\\n      s += xp[i];\\n\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n    if (s == 0) {\\n      return 0;\\n    }\\n\\n    uint256 prevD;\\n    uint256 d = s;\\n    uint256 nA = a * numTokens;\\n\\n    for (uint256 i; i < MAX_LOOP_LIMIT; ) {\\n      uint256 dP = d;\\n      for (uint256 j; j < numTokens; ) {\\n        dP = (dP * d) / (xp[j] * numTokens);\\n        // If we were to protect the division loss we would have to keep the denominator separate\\n        // and divide at the end. However this leads to overflow with large numTokens or/and D.\\n        // dP = dP * D * D * D * ... overflow!\\n\\n        unchecked {\\n          ++j;\\n        }\\n      }\\n      prevD = d;\\n      d =\\n        (((nA * s) / AmplificationUtils.A_PRECISION + dP * numTokens) * d) /\\n        ((((nA - AmplificationUtils.A_PRECISION) * d) / AmplificationUtils.A_PRECISION + (numTokens + 1) * dP));\\n      if (d.within1(prevD)) {\\n        return d;\\n      }\\n\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n\\n    // Convergence should occur in 4 loops or less. If this is reached, there may be something wrong\\n    // with the pool. If this were to occur repeatedly, LPs should withdraw via `removeLiquidity()`\\n    // function which does not rely on D.\\n    revert(\\\"D does not converge\\\");\\n  }\\n\\n  /**\\n   * @notice Given a set of balances and precision multipliers, return the\\n   * precision-adjusted balances.\\n   *\\n   * @param balances an array of token balances, in their native precisions.\\n   * These should generally correspond with pooled tokens.\\n   *\\n   * @param precisionMultipliers an array of multipliers, corresponding to\\n   * the amounts in the balances array. When multiplied together they\\n   * should yield amounts at the pool's precision.\\n   *\\n   * @return an array of amounts \\\"scaled\\\" to the pool's precision\\n   */\\n  function _xp(uint256[] memory balances, uint256[] memory precisionMultipliers)\\n    internal\\n    pure\\n    returns (uint256[] memory)\\n  {\\n    uint256 numTokens = balances.length;\\n    require(numTokens == precisionMultipliers.length, \\\"mismatch multipliers\\\");\\n    uint256[] memory xp = new uint256[](numTokens);\\n    for (uint256 i; i < numTokens; ) {\\n      xp[i] = balances[i] * precisionMultipliers[i];\\n\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n    return xp;\\n  }\\n\\n  /**\\n   * @notice Return the precision-adjusted balances of all tokens in the pool\\n   * @param self Swap struct to read from\\n   * @return the pool balances \\\"scaled\\\" to the pool's precision, allowing\\n   * them to be more easily compared.\\n   */\\n  function _xp(Swap storage self) internal view returns (uint256[] memory) {\\n    return _xp(self.balances, self.tokenPrecisionMultipliers);\\n  }\\n\\n  /**\\n   * @notice Get the virtual price, to help calculate profit\\n   * @param self Swap struct to read from\\n   * @return the virtual price, scaled to precision of POOL_PRECISION_DECIMALS\\n   */\\n  function getVirtualPrice(Swap storage self) internal view returns (uint256) {\\n    uint256 d = getD(_xp(self), _getAPrecise(self));\\n    LPToken lpToken = self.lpToken;\\n    uint256 supply = lpToken.totalSupply();\\n    if (supply != 0) {\\n      return (d * (10**uint256(POOL_PRECISION_DECIMALS))) / supply;\\n    }\\n    return 0;\\n  }\\n\\n  /**\\n   * @notice Calculate the new balances of the tokens given the indexes of the token\\n   * that is swapped from (FROM) and the token that is swapped to (TO).\\n   * This function is used as a helper function to calculate how much TO token\\n   * the user should receive on swap.\\n   *\\n   * @param preciseA precise form of amplification coefficient\\n   * @param tokenIndexFrom index of FROM token\\n   * @param tokenIndexTo index of TO token\\n   * @param x the new total amount of FROM token\\n   * @param xp balances of the tokens in the pool\\n   * @return the amount of TO token that should remain in the pool\\n   */\\n  function getY(\\n    uint256 preciseA,\\n    uint8 tokenIndexFrom,\\n    uint8 tokenIndexTo,\\n    uint256 x,\\n    uint256[] memory xp\\n  ) internal pure returns (uint256) {\\n    uint256 numTokens = xp.length;\\n    require(tokenIndexFrom != tokenIndexTo, \\\"compare token to itself\\\");\\n    require(tokenIndexFrom < numTokens && tokenIndexTo < numTokens, \\\"token not found\\\");\\n\\n    uint256 d = getD(xp, preciseA);\\n    uint256 c = d;\\n    uint256 s;\\n    uint256 nA = numTokens * preciseA;\\n\\n    uint256 _x;\\n    for (uint256 i; i < numTokens; ) {\\n      if (i == tokenIndexFrom) {\\n        _x = x;\\n      } else if (i != tokenIndexTo) {\\n        _x = xp[i];\\n      } else {\\n        unchecked {\\n          ++i;\\n        }\\n        continue;\\n      }\\n      s += _x;\\n      c = (c * d) / (_x * numTokens);\\n      // If we were to protect the division loss we would have to keep the denominator separate\\n      // and divide at the end. However this leads to overflow with large numTokens or/and D.\\n      // c = c * D * D * D * ... overflow!\\n\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n    c = (c * d * AmplificationUtils.A_PRECISION) / (nA * numTokens);\\n    uint256 b = s + ((d * AmplificationUtils.A_PRECISION) / nA);\\n    uint256 yPrev;\\n    uint256 y = d;\\n\\n    // iterative approximation\\n    for (uint256 i; i < MAX_LOOP_LIMIT; ) {\\n      yPrev = y;\\n      y = ((y * y) + c) / ((y * 2) + b - d);\\n      if (y.within1(yPrev)) {\\n        return y;\\n      }\\n\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n    revert(\\\"Approximation did not converge\\\");\\n  }\\n\\n  /**\\n   * @notice Externally calculates a swap between two tokens.\\n   * @param self Swap struct to read from\\n   * @param tokenIndexFrom the token to sell\\n   * @param tokenIndexTo the token to buy\\n   * @param dx the number of tokens to sell. If the token charges a fee on transfers,\\n   * use the amount that gets transferred after the fee.\\n   * @return dy the number of tokens the user will get\\n   */\\n  function calculateSwap(\\n    Swap storage self,\\n    uint8 tokenIndexFrom,\\n    uint8 tokenIndexTo,\\n    uint256 dx\\n  ) internal view returns (uint256 dy) {\\n    (dy, ) = _calculateSwap(self, tokenIndexFrom, tokenIndexTo, dx, self.balances);\\n  }\\n\\n  /**\\n   * @notice Externally calculates a swap between two tokens.\\n   * @param self Swap struct to read from\\n   * @param tokenIndexFrom the token to sell\\n   * @param tokenIndexTo the token to buy\\n   * @param dy the number of tokens to buy.\\n   * @return dx the number of tokens the user have to transfer + fee\\n   */\\n  function calculateSwapInv(\\n    Swap storage self,\\n    uint8 tokenIndexFrom,\\n    uint8 tokenIndexTo,\\n    uint256 dy\\n  ) internal view returns (uint256 dx) {\\n    (dx, ) = _calculateSwapInv(self, tokenIndexFrom, tokenIndexTo, dy, self.balances);\\n  }\\n\\n  /**\\n   * @notice Internally calculates a swap between two tokens.\\n   *\\n   * @dev The caller is expected to transfer the actual amounts (dx and dy)\\n   * using the token contracts.\\n   *\\n   * @param self Swap struct to read from\\n   * @param tokenIndexFrom the token to sell\\n   * @param tokenIndexTo the token to buy\\n   * @param dx the number of tokens to sell. If the token charges a fee on transfers,\\n   * use the amount that gets transferred after the fee.\\n   * @return dy the number of tokens the user will get in the token's precision. ex WBTC -> 8\\n   * @return dyFee the associated fee in multiplied precision (POOL_PRECISION_DECIMALS)\\n   */\\n  function _calculateSwap(\\n    Swap storage self,\\n    uint8 tokenIndexFrom,\\n    uint8 tokenIndexTo,\\n    uint256 dx,\\n    uint256[] memory balances\\n  ) internal view returns (uint256 dy, uint256 dyFee) {\\n    uint256[] memory multipliers = self.tokenPrecisionMultipliers;\\n    uint256[] memory xp = _xp(balances, multipliers);\\n    require(tokenIndexFrom < xp.length && tokenIndexTo < xp.length, \\\"index out of range\\\");\\n    uint256 x = dx * multipliers[tokenIndexFrom] + xp[tokenIndexFrom];\\n    uint256 y = getY(_getAPrecise(self), tokenIndexFrom, tokenIndexTo, x, xp);\\n    dy = xp[tokenIndexTo] - y - 1;\\n    dyFee = (dy * self.swapFee) / FEE_DENOMINATOR;\\n    dy = (dy - dyFee) / multipliers[tokenIndexTo];\\n  }\\n\\n  /**\\n   * @notice Internally calculates a swap between two tokens.\\n   *\\n   * @dev The caller is expected to transfer the actual amounts (dx and dy)\\n   * using the token contracts.\\n   *\\n   * @param self Swap struct to read from\\n   * @param tokenIndexFrom the token to sell\\n   * @param tokenIndexTo the token to buy\\n   * @param dy the number of tokens to buy. If the token charges a fee on transfers,\\n   * use the amount that gets transferred after the fee.\\n   * @return dx the number of tokens the user have to deposit in the token's precision. ex WBTC -> 8\\n   * @return dxFee the associated fee in multiplied precision (POOL_PRECISION_DECIMALS)\\n   */\\n  function _calculateSwapInv(\\n    Swap storage self,\\n    uint8 tokenIndexFrom,\\n    uint8 tokenIndexTo,\\n    uint256 dy,\\n    uint256[] memory balances\\n  ) internal view returns (uint256 dx, uint256 dxFee) {\\n    require(tokenIndexFrom != tokenIndexTo, \\\"compare token to itself\\\");\\n    uint256[] memory multipliers = self.tokenPrecisionMultipliers;\\n    uint256[] memory xp = _xp(balances, multipliers);\\n    require(tokenIndexFrom < xp.length && tokenIndexTo < xp.length, \\\"index out of range\\\");\\n\\n    uint256 a = _getAPrecise(self);\\n    uint256 d0 = getD(xp, a);\\n\\n    xp[tokenIndexTo] = xp[tokenIndexTo] - (dy * multipliers[tokenIndexTo]);\\n    uint256 x = getYD(a, tokenIndexFrom, xp, d0);\\n    dx = x - xp[tokenIndexFrom] + 1;\\n    dxFee = (dx * self.swapFee) / FEE_DENOMINATOR;\\n    dx = (dx + dxFee) / multipliers[tokenIndexFrom];\\n  }\\n\\n  /**\\n   * @notice A simple method to calculate amount of each underlying\\n   * tokens that is returned upon burning given amount of\\n   * LP tokens\\n   *\\n   * @param amount the amount of LP tokens that would to be burned on\\n   * withdrawal\\n   * @return array of amounts of tokens user will receive\\n   */\\n  function calculateRemoveLiquidity(Swap storage self, uint256 amount) internal view returns (uint256[] memory) {\\n    return _calculateRemoveLiquidity(self.balances, amount, self.lpToken.totalSupply());\\n  }\\n\\n  function _calculateRemoveLiquidity(\\n    uint256[] memory balances,\\n    uint256 amount,\\n    uint256 totalSupply\\n  ) internal pure returns (uint256[] memory) {\\n    require(amount <= totalSupply, \\\"exceed total supply\\\");\\n\\n    uint256 numBalances = balances.length;\\n    uint256[] memory amounts = new uint256[](numBalances);\\n\\n    for (uint256 i; i < numBalances; ) {\\n      amounts[i] = (balances[i] * amount) / totalSupply;\\n\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n    return amounts;\\n  }\\n\\n  /**\\n   * @notice A simple method to calculate prices from deposits or\\n   * withdrawals, excluding fees but including slippage. This is\\n   * helpful as an input into the various \\\"min\\\" parameters on calls\\n   * to fight front-running\\n   *\\n   * @dev This shouldn't be used outside frontends for user estimates.\\n   *\\n   * @param self Swap struct to read from\\n   * @param amounts an array of token amounts to deposit or withdrawal,\\n   * corresponding to pooledTokens. The amount should be in each\\n   * pooled token's native precision. If a token charges a fee on transfers,\\n   * use the amount that gets transferred after the fee.\\n   * @param deposit whether this is a deposit or a withdrawal\\n   * @return if deposit was true, total amount of lp token that will be minted and if\\n   * deposit was false, total amount of lp token that will be burned\\n   */\\n  function calculateTokenAmount(\\n    Swap storage self,\\n    uint256[] calldata amounts,\\n    bool deposit\\n  ) internal view returns (uint256) {\\n    uint256 a = _getAPrecise(self);\\n    uint256[] memory balances = self.balances;\\n    uint256[] memory multipliers = self.tokenPrecisionMultipliers;\\n\\n    uint256 numBalances = balances.length;\\n    uint256 d0 = getD(_xp(balances, multipliers), a);\\n    for (uint256 i; i < numBalances; ) {\\n      if (deposit) {\\n        balances[i] = balances[i] + amounts[i];\\n      } else {\\n        balances[i] = balances[i] - amounts[i];\\n      }\\n\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n    uint256 d1 = getD(_xp(balances, multipliers), a);\\n    uint256 totalSupply = self.lpToken.totalSupply();\\n\\n    if (deposit) {\\n      return ((d1 - d0) * totalSupply) / d0;\\n    } else {\\n      return ((d0 - d1) * totalSupply) / d0;\\n    }\\n  }\\n\\n  /**\\n   * @notice return accumulated amount of admin fees of the token with given index\\n   * @param self Swap struct to read from\\n   * @param index Index of the pooled token\\n   * @return admin balance in the token's precision\\n   */\\n  function getAdminBalance(Swap storage self, uint256 index) internal view returns (uint256) {\\n    require(index < self.pooledTokens.length, \\\"index out of range\\\");\\n    return self.adminFees[index];\\n  }\\n\\n  /**\\n   * @notice internal helper function to calculate fee per token multiplier used in\\n   * swap fee calculations\\n   * @param swapFee swap fee for the tokens\\n   * @param numTokens number of tokens pooled\\n   */\\n  function _feePerToken(uint256 swapFee, uint256 numTokens) internal pure returns (uint256) {\\n    return (swapFee * numTokens) / ((numTokens - 1) * 4);\\n  }\\n\\n  /*** STATE MODIFYING FUNCTIONS ***/\\n\\n  /**\\n   * @notice swap two tokens in the pool\\n   * @param self Swap struct to read from and write to\\n   * @param tokenIndexFrom the token the user wants to sell\\n   * @param tokenIndexTo the token the user wants to buy\\n   * @param dx the amount of tokens the user wants to sell\\n   * @param minDy the min amount the user would like to receive, or revert.\\n   * @return amount of token user received on swap\\n   */\\n  function swap(\\n    Swap storage self,\\n    uint8 tokenIndexFrom,\\n    uint8 tokenIndexTo,\\n    uint256 dx,\\n    uint256 minDy\\n  ) internal returns (uint256) {\\n    {\\n      IERC20 tokenFrom = self.pooledTokens[tokenIndexFrom];\\n      require(dx <= tokenFrom.balanceOf(msg.sender), \\\"swap more than you own\\\");\\n      // Transfer tokens first to see if a fee was charged on transfer\\n      uint256 beforeBalance = tokenFrom.balanceOf(address(this));\\n      tokenFrom.safeTransferFrom(msg.sender, address(this), dx);\\n\\n      // Use the actual transferred amount for AMM math\\n      require(dx == tokenFrom.balanceOf(address(this)) - beforeBalance, \\\"no fee token support\\\");\\n    }\\n\\n    uint256 dy;\\n    uint256 dyFee;\\n    uint256[] memory balances = self.balances;\\n    (dy, dyFee) = _calculateSwap(self, tokenIndexFrom, tokenIndexTo, dx, balances);\\n    require(dy >= minDy, \\\"dy < minDy\\\");\\n\\n    uint256 dyAdminFee = (dyFee * self.adminFee) / FEE_DENOMINATOR / self.tokenPrecisionMultipliers[tokenIndexTo];\\n\\n    self.balances[tokenIndexFrom] = balances[tokenIndexFrom] + dx;\\n    self.balances[tokenIndexTo] = balances[tokenIndexTo] - dy - dyAdminFee;\\n    if (dyAdminFee != 0) {\\n      self.adminFees[tokenIndexTo] = self.adminFees[tokenIndexTo] + dyAdminFee;\\n    }\\n\\n    self.pooledTokens[tokenIndexTo].safeTransfer(msg.sender, dy);\\n\\n    emit TokenSwap(self.key, msg.sender, dx, dy, tokenIndexFrom, tokenIndexTo);\\n\\n    return dy;\\n  }\\n\\n  /**\\n   * @notice swap two tokens in the pool\\n   * @param self Swap struct to read from and write to\\n   * @param tokenIndexFrom the token the user wants to sell\\n   * @param tokenIndexTo the token the user wants to buy\\n   * @param dy the amount of tokens the user wants to buy\\n   * @param maxDx the max amount the user would like to send.\\n   * @return amount of token user have to transfer on swap\\n   */\\n  function swapOut(\\n    Swap storage self,\\n    uint8 tokenIndexFrom,\\n    uint8 tokenIndexTo,\\n    uint256 dy,\\n    uint256 maxDx\\n  ) internal returns (uint256) {\\n    require(dy <= self.balances[tokenIndexTo], \\\">pool balance\\\");\\n\\n    uint256 dx;\\n    uint256 dxFee;\\n    uint256[] memory balances = self.balances;\\n    (dx, dxFee) = _calculateSwapInv(self, tokenIndexFrom, tokenIndexTo, dy, balances);\\n    require(dx <= maxDx, \\\"dx > maxDx\\\");\\n\\n    uint256 dxAdminFee = (dxFee * self.adminFee) / FEE_DENOMINATOR / self.tokenPrecisionMultipliers[tokenIndexFrom];\\n\\n    self.balances[tokenIndexFrom] = balances[tokenIndexFrom] + dx - dxAdminFee;\\n    self.balances[tokenIndexTo] = balances[tokenIndexTo] - dy;\\n    if (dxAdminFee != 0) {\\n      self.adminFees[tokenIndexFrom] = self.adminFees[tokenIndexFrom] + dxAdminFee;\\n    }\\n\\n    {\\n      IERC20 tokenFrom = self.pooledTokens[tokenIndexFrom];\\n      require(dx <= tokenFrom.balanceOf(msg.sender), \\\"more than you own\\\");\\n      // Transfer tokens first to see if a fee was charged on transfer\\n      uint256 beforeBalance = tokenFrom.balanceOf(address(this));\\n      tokenFrom.safeTransferFrom(msg.sender, address(this), dx);\\n\\n      // Use the actual transferred amount for AMM math\\n      require(dx == tokenFrom.balanceOf(address(this)) - beforeBalance, \\\"not support fee token\\\");\\n    }\\n\\n    self.pooledTokens[tokenIndexTo].safeTransfer(msg.sender, dy);\\n\\n    emit TokenSwap(self.key, msg.sender, dx, dy, tokenIndexFrom, tokenIndexTo);\\n\\n    return dx;\\n  }\\n\\n  /**\\n   * @notice swap two tokens in the pool internally\\n   * @param self Swap struct to read from and write to\\n   * @param tokenIndexFrom the token the user wants to sell\\n   * @param tokenIndexTo the token the user wants to buy\\n   * @param dx the amount of tokens the user wants to sell\\n   * @param minDy the min amount the user would like to receive, or revert.\\n   * @return amount of token user received on swap\\n   */\\n  function swapInternal(\\n    Swap storage self,\\n    uint8 tokenIndexFrom,\\n    uint8 tokenIndexTo,\\n    uint256 dx,\\n    uint256 minDy\\n  ) internal returns (uint256) {\\n    require(dx <= self.balances[tokenIndexFrom], \\\"more than pool balance\\\");\\n\\n    uint256 dy;\\n    uint256 dyFee;\\n    uint256[] memory balances = self.balances;\\n    (dy, dyFee) = _calculateSwap(self, tokenIndexFrom, tokenIndexTo, dx, balances);\\n    require(dy >= minDy, \\\"dy < minDy\\\");\\n\\n    uint256 dyAdminFee = (dyFee * self.adminFee) / FEE_DENOMINATOR / self.tokenPrecisionMultipliers[tokenIndexTo];\\n\\n    self.balances[tokenIndexFrom] = balances[tokenIndexFrom] + dx;\\n    self.balances[tokenIndexTo] = balances[tokenIndexTo] - dy - dyAdminFee;\\n\\n    if (dyAdminFee != 0) {\\n      self.adminFees[tokenIndexTo] = self.adminFees[tokenIndexTo] + dyAdminFee;\\n    }\\n\\n    emit TokenSwap(self.key, msg.sender, dx, dy, tokenIndexFrom, tokenIndexTo);\\n\\n    return dy;\\n  }\\n\\n  /**\\n   * @notice Should get exact amount out of AMM for asset put in\\n   */\\n  function swapInternalOut(\\n    Swap storage self,\\n    uint8 tokenIndexFrom,\\n    uint8 tokenIndexTo,\\n    uint256 dy,\\n    uint256 maxDx\\n  ) internal returns (uint256) {\\n    require(dy <= self.balances[tokenIndexTo], \\\"more than pool balance\\\");\\n\\n    uint256 dx;\\n    uint256 dxFee;\\n    uint256[] memory balances = self.balances;\\n    (dx, dxFee) = _calculateSwapInv(self, tokenIndexFrom, tokenIndexTo, dy, balances);\\n    require(dx <= maxDx, \\\"dx > maxDx\\\");\\n\\n    uint256 dxAdminFee = (dxFee * self.adminFee) / FEE_DENOMINATOR / self.tokenPrecisionMultipliers[tokenIndexFrom];\\n\\n    self.balances[tokenIndexFrom] = balances[tokenIndexFrom] + dx - dxAdminFee;\\n    self.balances[tokenIndexTo] = balances[tokenIndexTo] - dy;\\n\\n    if (dxAdminFee != 0) {\\n      self.adminFees[tokenIndexFrom] = self.adminFees[tokenIndexFrom] + dxAdminFee;\\n    }\\n\\n    emit TokenSwap(self.key, msg.sender, dx, dy, tokenIndexFrom, tokenIndexTo);\\n\\n    return dx;\\n  }\\n\\n  /**\\n   * @notice Add liquidity to the pool\\n   * @param self Swap struct to read from and write to\\n   * @param amounts the amounts of each token to add, in their native precision\\n   * @param minToMint the minimum LP tokens adding this amount of liquidity\\n   * should mint, otherwise revert. Handy for front-running mitigation\\n   * allowed addresses. If the pool is not in the guarded launch phase, this parameter will be ignored.\\n   * @return amount of LP token user received\\n   */\\n  function addLiquidity(\\n    Swap storage self,\\n    uint256[] memory amounts,\\n    uint256 minToMint\\n  ) internal returns (uint256) {\\n    uint256 numTokens = self.pooledTokens.length;\\n    require(amounts.length == numTokens, \\\"mismatch pooled tokens\\\");\\n\\n    // current state\\n    ManageLiquidityInfo memory v = ManageLiquidityInfo(\\n      0,\\n      0,\\n      0,\\n      _getAPrecise(self),\\n      self.lpToken,\\n      0,\\n      self.balances,\\n      self.tokenPrecisionMultipliers\\n    );\\n    v.totalSupply = v.lpToken.totalSupply();\\n    if (v.totalSupply != 0) {\\n      v.d0 = getD(_xp(v.balances, v.multipliers), v.preciseA);\\n    }\\n\\n    uint256[] memory newBalances = new uint256[](numTokens);\\n\\n    for (uint256 i; i < numTokens; ) {\\n      require(v.totalSupply != 0 || amounts[i] != 0, \\\"!supply all tokens\\\");\\n\\n      // Transfer tokens first to see if a fee was charged on transfer\\n      if (amounts[i] != 0) {\\n        IERC20 token = self.pooledTokens[i];\\n        uint256 beforeBalance = token.balanceOf(address(this));\\n        token.safeTransferFrom(msg.sender, address(this), amounts[i]);\\n\\n        // Update the amounts[] with actual transfer amount\\n        amounts[i] = token.balanceOf(address(this)) - beforeBalance;\\n      }\\n\\n      newBalances[i] = v.balances[i] + amounts[i];\\n\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n\\n    // invariant after change\\n    v.d1 = getD(_xp(newBalances, v.multipliers), v.preciseA);\\n    require(v.d1 > v.d0, \\\"D should increase\\\");\\n\\n    // updated to reflect fees and calculate the user's LP tokens\\n    v.d2 = v.d1;\\n    uint256[] memory fees = new uint256[](numTokens);\\n\\n    if (v.totalSupply != 0) {\\n      uint256 feePerToken = _feePerToken(self.swapFee, numTokens);\\n      for (uint256 i; i < numTokens; ) {\\n        uint256 idealBalance = (v.d1 * v.balances[i]) / v.d0;\\n        fees[i] = (feePerToken * (idealBalance.difference(newBalances[i]))) / FEE_DENOMINATOR;\\n        uint256 adminFee = (fees[i] * self.adminFee) / FEE_DENOMINATOR;\\n        self.balances[i] = newBalances[i] - adminFee;\\n        self.adminFees[i] = self.adminFees[i] + adminFee;\\n        newBalances[i] = newBalances[i] - fees[i];\\n\\n        unchecked {\\n          ++i;\\n        }\\n      }\\n      v.d2 = getD(_xp(newBalances, v.multipliers), v.preciseA);\\n    } else {\\n      // the initial depositor doesn't pay fees\\n      self.balances = newBalances;\\n    }\\n\\n    uint256 toMint;\\n    if (v.totalSupply == 0) {\\n      toMint = v.d1;\\n    } else {\\n      toMint = ((v.d2 - v.d0) * v.totalSupply) / v.d0;\\n    }\\n\\n    require(toMint >= minToMint, \\\"mint < min\\\");\\n\\n    // mint the user's LP tokens\\n    v.lpToken.mint(msg.sender, toMint);\\n\\n    emit AddLiquidity(self.key, msg.sender, amounts, fees, v.d1, v.totalSupply + toMint);\\n\\n    return toMint;\\n  }\\n\\n  /**\\n   * @notice Burn LP tokens to remove liquidity from the pool.\\n   * @dev Liquidity can always be removed, even when the pool is paused.\\n   * @param self Swap struct to read from and write to\\n   * @param amount the amount of LP tokens to burn\\n   * @param minAmounts the minimum amounts of each token in the pool\\n   * acceptable for this burn. Useful as a front-running mitigation\\n   * @return amounts of tokens the user received\\n   */\\n  function removeLiquidity(\\n    Swap storage self,\\n    uint256 amount,\\n    uint256[] calldata minAmounts\\n  ) internal returns (uint256[] memory) {\\n    LPToken lpToken = self.lpToken;\\n    require(amount <= lpToken.balanceOf(msg.sender), \\\">LP.balanceOf\\\");\\n    uint256 numTokens = self.pooledTokens.length;\\n    require(minAmounts.length == numTokens, \\\"mismatch poolTokens\\\");\\n\\n    uint256[] memory balances = self.balances;\\n    uint256 totalSupply = lpToken.totalSupply();\\n\\n    uint256[] memory amounts = _calculateRemoveLiquidity(balances, amount, totalSupply);\\n\\n    uint256 numAmounts = amounts.length;\\n    for (uint256 i; i < numAmounts; ) {\\n      require(amounts[i] >= minAmounts[i], \\\"amounts[i] < minAmounts[i]\\\");\\n      self.balances[i] = balances[i] - amounts[i];\\n      self.pooledTokens[i].safeTransfer(msg.sender, amounts[i]);\\n\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n\\n    lpToken.burnFrom(msg.sender, amount);\\n\\n    emit RemoveLiquidity(self.key, msg.sender, amounts, totalSupply - amount);\\n\\n    return amounts;\\n  }\\n\\n  /**\\n   * @notice Remove liquidity from the pool all in one token.\\n   * @param self Swap struct to read from and write to\\n   * @param tokenAmount the amount of the lp tokens to burn\\n   * @param tokenIndex the index of the token you want to receive\\n   * @param minAmount the minimum amount to withdraw, otherwise revert\\n   * @return amount chosen token that user received\\n   */\\n  function removeLiquidityOneToken(\\n    Swap storage self,\\n    uint256 tokenAmount,\\n    uint8 tokenIndex,\\n    uint256 minAmount\\n  ) internal returns (uint256) {\\n    LPToken lpToken = self.lpToken;\\n\\n    require(tokenAmount <= lpToken.balanceOf(msg.sender), \\\">LP.balanceOf\\\");\\n    uint256 numTokens = self.pooledTokens.length;\\n    require(tokenIndex < numTokens, \\\"not found\\\");\\n\\n    uint256 totalSupply = lpToken.totalSupply();\\n\\n    (uint256 dy, uint256 dyFee) = _calculateWithdrawOneToken(self, tokenAmount, tokenIndex, totalSupply);\\n\\n    require(dy >= minAmount, \\\"dy < minAmount\\\");\\n\\n    uint256 adminFee = (dyFee * self.adminFee) / FEE_DENOMINATOR;\\n    self.balances[tokenIndex] = self.balances[tokenIndex] - (dy + adminFee);\\n    if (adminFee != 0) {\\n      self.adminFees[tokenIndex] = self.adminFees[tokenIndex] + adminFee;\\n    }\\n    lpToken.burnFrom(msg.sender, tokenAmount);\\n    self.pooledTokens[tokenIndex].safeTransfer(msg.sender, dy);\\n\\n    emit RemoveLiquidityOne(self.key, msg.sender, tokenAmount, totalSupply, tokenIndex, dy);\\n\\n    return dy;\\n  }\\n\\n  /**\\n   * @notice Remove liquidity from the pool, weighted differently than the\\n   * pool's current balances.\\n   *\\n   * @param self Swap struct to read from and write to\\n   * @param amounts how much of each token to withdraw\\n   * @param maxBurnAmount the max LP token provider is willing to pay to\\n   * remove liquidity. Useful as a front-running mitigation.\\n   * @return actual amount of LP tokens burned in the withdrawal\\n   */\\n  function removeLiquidityImbalance(\\n    Swap storage self,\\n    uint256[] memory amounts,\\n    uint256 maxBurnAmount\\n  ) internal returns (uint256) {\\n    ManageLiquidityInfo memory v = ManageLiquidityInfo(\\n      0,\\n      0,\\n      0,\\n      _getAPrecise(self),\\n      self.lpToken,\\n      0,\\n      self.balances,\\n      self.tokenPrecisionMultipliers\\n    );\\n    v.totalSupply = v.lpToken.totalSupply();\\n\\n    uint256 numTokens = self.pooledTokens.length;\\n    uint256 numAmounts = amounts.length;\\n    require(numAmounts == numTokens, \\\"mismatch pool tokens\\\");\\n\\n    require(maxBurnAmount <= v.lpToken.balanceOf(msg.sender) && maxBurnAmount != 0, \\\">LP.balanceOf\\\");\\n\\n    uint256 feePerToken = _feePerToken(self.swapFee, numTokens);\\n    uint256[] memory fees = new uint256[](numTokens);\\n    {\\n      uint256[] memory balances1 = new uint256[](numTokens);\\n      v.d0 = getD(_xp(v.balances, v.multipliers), v.preciseA);\\n      for (uint256 i; i < numTokens; ) {\\n        require(v.balances[i] >= amounts[i], \\\"withdraw more than available\\\");\\n\\n        unchecked {\\n          balances1[i] = v.balances[i] - amounts[i];\\n          ++i;\\n        }\\n      }\\n      v.d1 = getD(_xp(balances1, v.multipliers), v.preciseA);\\n\\n      for (uint256 i; i < numTokens; ) {\\n        {\\n          uint256 idealBalance = (v.d1 * v.balances[i]) / v.d0;\\n          uint256 difference = idealBalance.difference(balances1[i]);\\n          fees[i] = (feePerToken * difference) / FEE_DENOMINATOR;\\n        }\\n        uint256 adminFee = (fees[i] * self.adminFee) / FEE_DENOMINATOR;\\n        self.balances[i] = balances1[i] - adminFee;\\n        self.adminFees[i] = self.adminFees[i] + adminFee;\\n        balances1[i] = balances1[i] - fees[i];\\n\\n        unchecked {\\n          ++i;\\n        }\\n      }\\n\\n      v.d2 = getD(_xp(balances1, v.multipliers), v.preciseA);\\n    }\\n    uint256 tokenAmount = ((v.d0 - v.d2) * v.totalSupply) / v.d0;\\n    require(tokenAmount != 0, \\\"!zero amount\\\");\\n    tokenAmount = tokenAmount + 1;\\n\\n    require(tokenAmount <= maxBurnAmount, \\\"tokenAmount > maxBurnAmount\\\");\\n\\n    v.lpToken.burnFrom(msg.sender, tokenAmount);\\n\\n    for (uint256 i; i < numTokens; ) {\\n      self.pooledTokens[i].safeTransfer(msg.sender, amounts[i]);\\n\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n\\n    emit RemoveLiquidityImbalance(self.key, msg.sender, amounts, fees, v.d1, v.totalSupply - tokenAmount);\\n\\n    return tokenAmount;\\n  }\\n\\n  /**\\n   * @notice withdraw all admin fees to a given address\\n   * @param self Swap struct to withdraw fees from\\n   * @param to Address to send the fees to\\n   */\\n  function withdrawAdminFees(Swap storage self, address to) internal {\\n    uint256 numTokens = self.pooledTokens.length;\\n    for (uint256 i; i < numTokens; ) {\\n      IERC20 token = self.pooledTokens[i];\\n      uint256 balance = self.adminFees[i];\\n      if (balance != 0) {\\n        self.adminFees[i] = 0;\\n        token.safeTransfer(to, balance);\\n      }\\n\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @notice Sets the admin fee\\n   * @dev adminFee cannot be higher than 100% of the swap fee\\n   * @param self Swap struct to update\\n   * @param newAdminFee new admin fee to be applied on future transactions\\n   */\\n  function setAdminFee(Swap storage self, uint256 newAdminFee) internal {\\n    require(newAdminFee <= MAX_ADMIN_FEE, \\\"too high\\\");\\n    self.adminFee = newAdminFee;\\n\\n    emit NewAdminFee(self.key, newAdminFee);\\n  }\\n\\n  /**\\n   * @notice update the swap fee\\n   * @dev fee cannot be higher than 1% of each swap\\n   * @param self Swap struct to update\\n   * @param newSwapFee new swap fee to be applied on future transactions\\n   */\\n  function setSwapFee(Swap storage self, uint256 newSwapFee) internal {\\n    require(newSwapFee <= MAX_SWAP_FEE, \\\"too high\\\");\\n    self.swapFee = newSwapFee;\\n\\n    emit NewSwapFee(self.key, newSwapFee);\\n  }\\n\\n  /**\\n   * @notice Check if this stableswap pool exists and is valid (i.e. has been\\n   * initialized and tokens have been added).\\n   * @return bool true if this stableswap pool is valid, false if not.\\n   */\\n  function exists(Swap storage self) internal view returns (bool) {\\n    return self.pooledTokens.length != 0;\\n  }\\n}\\n\",\"keccak256\":\"0x3da6aa3cd7cf97886db9958cbb174b8edaf7771aebce5da2a8d87e993a8301fa\",\"license\":\"UNLICENSED\"},\"contracts/messaging/interfaces/IConnectorManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity 0.8.15;\\n\\nimport {IOutbox} from \\\"./IOutbox.sol\\\";\\n\\n/**\\n * @notice Each router extends the `XAppConnectionClient` contract. This contract\\n * allows an admin to call `setXAppConnectionManager` to update the underlying\\n * pointers to the messaging inboxes (Replicas) and outboxes (Homes).\\n *\\n * @dev This interface only contains the functions needed for the `XAppConnectionClient`\\n * will interface with.\\n */\\ninterface IConnectorManager {\\n  /**\\n   * @notice Get the local inbox contract from the xAppConnectionManager\\n   * @return The local inbox contract\\n   * @dev The local inbox contract is a SpokeConnector with AMBs, and a\\n   * Home contract with nomad\\n   */\\n  function home() external view returns (IOutbox);\\n\\n  /**\\n   * @notice Determine whether _potentialReplica is an enrolled Replica from the xAppConnectionManager\\n   * @return True if _potentialReplica is an enrolled Replica\\n   */\\n  function isReplica(address _potentialReplica) external view returns (bool);\\n\\n  /**\\n   * @notice Get the local domain from the xAppConnectionManager\\n   * @return The local domain\\n   */\\n  function localDomain() external view returns (uint32);\\n}\\n\",\"keccak256\":\"0xa2c9a88a7b76a89615fe199d8a78878e5deb8dd13b036a86b575d31966beab1a\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/messaging/interfaces/IOutbox.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity 0.8.15;\\n\\n/**\\n * @notice Interface for all contracts sending messages originating on their\\n * current domain.\\n *\\n * @dev These are the Home.sol interface methods used by the `Router`\\n * and exposed via `home()` on the `XAppConnectionClient`\\n */\\ninterface IOutbox {\\n  /**\\n   * @notice Emitted when a new message is added to an outbound message merkle root\\n   * @param leafIndex Index of message's leaf in merkle tree\\n   * @param destinationAndNonce Destination and destination-specific\\n   * nonce combined in single field ((destination << 32) & nonce)\\n   * @param messageHash Hash of message; the leaf inserted to the Merkle tree for the message\\n   * @param committedRoot the latest notarized root submitted in the last signed Update\\n   * @param message Raw bytes of message\\n   */\\n  event Dispatch(\\n    bytes32 indexed messageHash,\\n    uint256 indexed leafIndex,\\n    uint64 indexed destinationAndNonce,\\n    bytes32 committedRoot,\\n    bytes message\\n  );\\n\\n  /**\\n   * @notice Dispatch the message it to the destination domain & recipient\\n   * @dev Format the message, insert its hash into Merkle tree,\\n   * enqueue the new Merkle root, and emit `Dispatch` event with message information.\\n   * @param _destinationDomain Domain of destination chain\\n   * @param _recipientAddress Address of recipient on destination chain as bytes32\\n   * @param _messageBody Raw bytes content of message\\n   * @return bytes32 The leaf added to the tree\\n   */\\n  function dispatch(\\n    uint32 _destinationDomain,\\n    bytes32 _recipientAddress,\\n    bytes memory _messageBody\\n  ) external returns (bytes32);\\n}\\n\",\"keccak256\":\"0xe6a213bd3c9e0c4dcf0e982cdef2a6a613a49b7bca3d6ad662c179e509de6c2b\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/shared/libraries/TypeCasts.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity 0.8.15;\\n\\nimport \\\"./TypedMemView.sol\\\";\\n\\nlibrary TypeCasts {\\n  using TypedMemView for bytes;\\n  using TypedMemView for bytes29;\\n\\n  function coerceBytes32(string memory _s) internal pure returns (bytes32 _b) {\\n    _b = bytes(_s).ref(0).index(0, uint8(bytes(_s).length));\\n  }\\n\\n  // treat it as a null-terminated string of max 32 bytes\\n  function coerceString(bytes32 _buf) internal pure returns (string memory _newStr) {\\n    uint8 _slen = 0;\\n    while (_slen < 32 && _buf[_slen] != 0) {\\n      _slen++;\\n    }\\n\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      _newStr := mload(0x40)\\n      mstore(0x40, add(_newStr, 0x40)) // may end up with extra\\n      mstore(_newStr, _slen)\\n      mstore(add(_newStr, 0x20), _buf)\\n    }\\n  }\\n\\n  // alignment preserving cast\\n  function addressToBytes32(address _addr) internal pure returns (bytes32) {\\n    return bytes32(uint256(uint160(_addr)));\\n  }\\n\\n  // alignment preserving cast\\n  function bytes32ToAddress(bytes32 _buf) internal pure returns (address) {\\n    return address(uint160(uint256(_buf)));\\n  }\\n}\\n\",\"keccak256\":\"0x818736bf6004223f78f8949c534c74f144b741f5b1ece635670f0fd9b2217344\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/shared/libraries/TypedMemView.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity 0.8.15;\\n\\nlibrary TypedMemView {\\n  // Why does this exist?\\n  // the solidity `bytes memory` type has a few weaknesses.\\n  // 1. You can't index ranges effectively\\n  // 2. You can't slice without copying\\n  // 3. The underlying data may represent any type\\n  // 4. Solidity never deallocates memory, and memory costs grow\\n  //    superlinearly\\n\\n  // By using a memory view instead of a `bytes memory` we get the following\\n  // advantages:\\n  // 1. Slices are done on the stack, by manipulating the pointer\\n  // 2. We can index arbitrary ranges and quickly convert them to stack types\\n  // 3. We can insert type info into the pointer, and typecheck at runtime\\n\\n  // This makes `TypedMemView` a useful tool for efficient zero-copy\\n  // algorithms.\\n\\n  // Why bytes29?\\n  // We want to avoid confusion between views, digests, and other common\\n  // types so we chose a large and uncommonly used odd number of bytes\\n  //\\n  // Note that while bytes are left-aligned in a word, integers and addresses\\n  // are right-aligned. This means when working in assembly we have to\\n  // account for the 3 unused bytes on the righthand side\\n  //\\n  // First 5 bytes are a type flag.\\n  // - ff_ffff_fffe is reserved for unknown type.\\n  // - ff_ffff_ffff is reserved for invalid types/errors.\\n  // next 12 are memory address\\n  // next 12 are len\\n  // bottom 3 bytes are empty\\n\\n  // Assumptions:\\n  // - non-modification of memory.\\n  // - No Solidity updates\\n  // - - wrt free mem point\\n  // - - wrt bytes representation in memory\\n  // - - wrt memory addressing in general\\n\\n  // Usage:\\n  // - create type constants\\n  // - use `assertType` for runtime type assertions\\n  // - - unfortunately we can't do this at compile time yet :(\\n  // - recommended: implement modifiers that perform type checking\\n  // - - e.g.\\n  // - - `uint40 constant MY_TYPE = 3;`\\n  // - - ` modifer onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\\n  // - instantiate a typed view from a bytearray using `ref`\\n  // - use `index` to inspect the contents of the view\\n  // - use `slice` to create smaller views into the same memory\\n  // - - `slice` can increase the offset\\n  // - - `slice can decrease the length`\\n  // - - must specify the output type of `slice`\\n  // - - `slice` will return a null view if you try to overrun\\n  // - - make sure to explicitly check for this with `notNull` or `assertType`\\n  // - use `equal` for typed comparisons.\\n\\n  // The null view\\n  bytes29 public constant NULL = hex\\\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\\";\\n  uint256 constant LOW_12_MASK = 0xffffffffffffffffffffffff;\\n  uint8 constant TWELVE_BYTES = 96;\\n\\n  /**\\n   * @notice      Returns the encoded hex character that represents the lower 4 bits of the argument.\\n   * @param _b    The byte\\n   * @return      char - The encoded hex character\\n   */\\n  function nibbleHex(uint8 _b) internal pure returns (uint8 char) {\\n    // This can probably be done more efficiently, but it's only in error\\n    // paths, so we don't really care :)\\n    uint8 _nibble = _b | 0xf0; // set top 4, keep bottom 4\\n    if (_nibble == 0xf0) {\\n      return 0x30;\\n    } // 0\\n    if (_nibble == 0xf1) {\\n      return 0x31;\\n    } // 1\\n    if (_nibble == 0xf2) {\\n      return 0x32;\\n    } // 2\\n    if (_nibble == 0xf3) {\\n      return 0x33;\\n    } // 3\\n    if (_nibble == 0xf4) {\\n      return 0x34;\\n    } // 4\\n    if (_nibble == 0xf5) {\\n      return 0x35;\\n    } // 5\\n    if (_nibble == 0xf6) {\\n      return 0x36;\\n    } // 6\\n    if (_nibble == 0xf7) {\\n      return 0x37;\\n    } // 7\\n    if (_nibble == 0xf8) {\\n      return 0x38;\\n    } // 8\\n    if (_nibble == 0xf9) {\\n      return 0x39;\\n    } // 9\\n    if (_nibble == 0xfa) {\\n      return 0x61;\\n    } // a\\n    if (_nibble == 0xfb) {\\n      return 0x62;\\n    } // b\\n    if (_nibble == 0xfc) {\\n      return 0x63;\\n    } // c\\n    if (_nibble == 0xfd) {\\n      return 0x64;\\n    } // d\\n    if (_nibble == 0xfe) {\\n      return 0x65;\\n    } // e\\n    if (_nibble == 0xff) {\\n      return 0x66;\\n    } // f\\n  }\\n\\n  /**\\n   * @notice      Returns a uint16 containing the hex-encoded byte.\\n   * @param _b    The byte\\n   * @return      encoded - The hex-encoded byte\\n   */\\n  function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\\n    encoded |= nibbleHex(_b >> 4); // top 4 bits\\n    encoded <<= 8;\\n    encoded |= nibbleHex(_b); // lower 4 bits\\n  }\\n\\n  /**\\n   * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\\n   *              `second` contains the encoded lower 16 bytes.\\n   *\\n   * @param _b    The 32 bytes as uint256\\n   * @return      first - The top 16 bytes\\n   * @return      second - The bottom 16 bytes\\n   */\\n  function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\\n    for (uint8 i = 31; i > 15; ) {\\n      uint8 _byte = uint8(_b >> (i * 8));\\n      first |= byteHex(_byte);\\n      if (i != 16) {\\n        first <<= 16;\\n      }\\n      unchecked {\\n        i -= 1;\\n      }\\n    }\\n\\n    // abusing underflow here =_=\\n    for (uint8 i = 15; i < 255; ) {\\n      uint8 _byte = uint8(_b >> (i * 8));\\n      second |= byteHex(_byte);\\n      if (i != 0) {\\n        second <<= 16;\\n      }\\n      unchecked {\\n        i -= 1;\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @notice          Changes the endianness of a uint256.\\n   * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\\n   * @param _b        The unsigned integer to reverse\\n   * @return          v - The reversed value\\n   */\\n  function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\\n    v = _b;\\n\\n    // swap bytes\\n    v =\\n      ((v >> 8) & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\\n      ((v & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) << 8);\\n    // swap 2-byte long pairs\\n    v =\\n      ((v >> 16) & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\\n      ((v & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) << 16);\\n    // swap 4-byte long pairs\\n    v =\\n      ((v >> 32) & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\\n      ((v & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) << 32);\\n    // swap 8-byte long pairs\\n    v =\\n      ((v >> 64) & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\\n      ((v & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) << 64);\\n    // swap 16-byte long pairs\\n    v = (v >> 128) | (v << 128);\\n  }\\n\\n  /**\\n   * @notice      Create a mask with the highest `_len` bits set.\\n   * @param _len  The length\\n   * @return      mask - The mask\\n   */\\n  function leftMask(uint8 _len) private pure returns (uint256 mask) {\\n    // ugly. redo without assembly?\\n    assembly {\\n      // solhint-disable-previous-line no-inline-assembly\\n      mask := sar(sub(_len, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\\n    }\\n  }\\n\\n  /**\\n   * @notice      Return the null view.\\n   * @return      bytes29 - The null view\\n   */\\n  function nullView() internal pure returns (bytes29) {\\n    return NULL;\\n  }\\n\\n  /**\\n   * @notice      Check if the view is null.\\n   * @return      bool - True if the view is null\\n   */\\n  function isNull(bytes29 memView) internal pure returns (bool) {\\n    return memView == NULL;\\n  }\\n\\n  /**\\n   * @notice      Check if the view is not null.\\n   * @return      bool - True if the view is not null\\n   */\\n  function notNull(bytes29 memView) internal pure returns (bool) {\\n    return !isNull(memView);\\n  }\\n\\n  /**\\n   * @notice          Check if the view is of a valid type and points to a valid location\\n   *                  in memory.\\n   * @dev             We perform this check by examining solidity's unallocated memory\\n   *                  pointer and ensuring that the view's upper bound is less than that.\\n   * @param memView   The view\\n   * @return          ret - True if the view is valid\\n   */\\n  function isValid(bytes29 memView) internal pure returns (bool ret) {\\n    if (typeOf(memView) == 0xffffffffff) {\\n      return false;\\n    }\\n    uint256 _end = end(memView);\\n    assembly {\\n      // solhint-disable-previous-line no-inline-assembly\\n      ret := not(gt(_end, mload(0x40)))\\n    }\\n  }\\n\\n  /**\\n   * @notice          Require that a typed memory view be valid.\\n   * @dev             Returns the view for easy chaining.\\n   * @param memView   The view\\n   * @return          bytes29 - The validated view\\n   */\\n  function assertValid(bytes29 memView) internal pure returns (bytes29) {\\n    require(isValid(memView), \\\"Validity assertion failed\\\");\\n    return memView;\\n  }\\n\\n  /**\\n   * @notice          Return true if the memview is of the expected type. Otherwise false.\\n   * @param memView   The view\\n   * @param _expected The expected type\\n   * @return          bool - True if the memview is of the expected type\\n   */\\n  function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\\n    return typeOf(memView) == _expected;\\n  }\\n\\n  /**\\n   * @notice          Require that a typed memory view has a specific type.\\n   * @dev             Returns the view for easy chaining.\\n   * @param memView   The view\\n   * @param _expected The expected type\\n   * @return          bytes29 - The view with validated type\\n   */\\n  function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\\n    if (!isType(memView, _expected)) {\\n      (, uint256 g) = encodeHex(uint256(typeOf(memView)));\\n      (, uint256 e) = encodeHex(uint256(_expected));\\n      string memory err = string(\\n        abi.encodePacked(\\\"Type assertion failed. Got 0x\\\", uint80(g), \\\". Expected 0x\\\", uint80(e))\\n      );\\n      revert(err);\\n    }\\n    return memView;\\n  }\\n\\n  /**\\n   * @notice          Return an identical view with a different type.\\n   * @param memView   The view\\n   * @param _newType  The new type\\n   * @return          newView - The new view with the specified type\\n   */\\n  function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\\n    // then | in the new type\\n    assembly {\\n      // solhint-disable-previous-line no-inline-assembly\\n      // shift off the top 5 bytes\\n      newView := or(newView, shr(40, shl(40, memView)))\\n      newView := or(newView, shl(216, _newType))\\n    }\\n  }\\n\\n  /**\\n   * @notice          Unsafe raw pointer construction. This should generally not be called\\n   *                  directly. Prefer `ref` wherever possible.\\n   * @dev             Unsafe raw pointer construction. This should generally not be called\\n   *                  directly. Prefer `ref` wherever possible.\\n   * @param _type     The type\\n   * @param _loc      The memory address\\n   * @param _len      The length\\n   * @return          newView - The new view with the specified type, location and length\\n   */\\n  function unsafeBuildUnchecked(\\n    uint256 _type,\\n    uint256 _loc,\\n    uint256 _len\\n  ) private pure returns (bytes29 newView) {\\n    assembly {\\n      // solhint-disable-previous-line no-inline-assembly\\n      newView := shl(96, or(newView, _type)) // insert type\\n      newView := shl(96, or(newView, _loc)) // insert loc\\n      newView := shl(24, or(newView, _len)) // empty bottom 3 bytes\\n    }\\n  }\\n\\n  /**\\n   * @notice          Instantiate a new memory view. This should generally not be called\\n   *                  directly. Prefer `ref` wherever possible.\\n   * @dev             Instantiate a new memory view. This should generally not be called\\n   *                  directly. Prefer `ref` wherever possible.\\n   * @param _type     The type\\n   * @param _loc      The memory address\\n   * @param _len      The length\\n   * @return          newView - The new view with the specified type, location and length\\n   */\\n  function build(\\n    uint256 _type,\\n    uint256 _loc,\\n    uint256 _len\\n  ) internal pure returns (bytes29 newView) {\\n    uint256 _end = _loc + _len;\\n    assembly {\\n      // solhint-disable-previous-line no-inline-assembly\\n      if gt(_end, mload(0x40)) {\\n        _end := 0\\n      }\\n    }\\n    if (_end == 0) {\\n      return NULL;\\n    }\\n    newView = unsafeBuildUnchecked(_type, _loc, _len);\\n  }\\n\\n  /**\\n   * @notice          Instantiate a memory view from a byte array.\\n   * @dev             Note that due to Solidity memory representation, it is not possible to\\n   *                  implement a deref, as the `bytes` type stores its len in memory.\\n   * @param arr       The byte array\\n   * @param newType   The type\\n   * @return          bytes29 - The memory view\\n   */\\n  function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\\n    uint256 _len = arr.length;\\n\\n    uint256 _loc;\\n    assembly {\\n      // solhint-disable-previous-line no-inline-assembly\\n      _loc := add(arr, 0x20) // our view is of the data, not the struct\\n    }\\n\\n    return build(newType, _loc, _len);\\n  }\\n\\n  /**\\n   * @notice          Return the associated type information.\\n   * @param memView   The memory view\\n   * @return          _type - The type associated with the view\\n   */\\n  function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\\n    assembly {\\n      // solhint-disable-previous-line no-inline-assembly\\n      // 216 == 256 - 40\\n      _type := shr(216, memView) // shift out lower 24 bytes\\n    }\\n  }\\n\\n  /**\\n   * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\\n   * @param left      The first view\\n   * @param right     The second view\\n   * @return          bool - True if the 5-byte type flag is equal\\n   */\\n  function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\\n    return (left ^ right) >> (2 * TWELVE_BYTES) == 0;\\n  }\\n\\n  /**\\n   * @notice          Return the memory address of the underlying bytes.\\n   * @param memView   The view\\n   * @return          _loc - The memory address\\n   */\\n  function loc(bytes29 memView) internal pure returns (uint96 _loc) {\\n    uint256 _mask = LOW_12_MASK; // assembly can't use globals\\n    assembly {\\n      // solhint-disable-previous-line no-inline-assembly\\n      // 120 bits = 12 bytes (the encoded loc) + 3 bytes (empty low space)\\n      _loc := and(shr(120, memView), _mask)\\n    }\\n  }\\n\\n  /**\\n   * @notice          The number of memory words this memory view occupies, rounded up.\\n   * @param memView   The view\\n   * @return          uint256 - The number of memory words\\n   */\\n  function words(bytes29 memView) internal pure returns (uint256) {\\n    return (uint256(len(memView)) + 31) / 32;\\n  }\\n\\n  /**\\n   * @notice          The in-memory footprint of a fresh copy of the view.\\n   * @param memView   The view\\n   * @return          uint256 - The in-memory footprint of a fresh copy of the view.\\n   */\\n  function footprint(bytes29 memView) internal pure returns (uint256) {\\n    return words(memView) * 32;\\n  }\\n\\n  /**\\n   * @notice          The number of bytes of the view.\\n   * @param memView   The view\\n   * @return          _len - The length of the view\\n   */\\n  function len(bytes29 memView) internal pure returns (uint96 _len) {\\n    uint256 _mask = LOW_12_MASK; // assembly can't use globals\\n    assembly {\\n      // solhint-disable-previous-line no-inline-assembly\\n      _len := and(shr(24, memView), _mask)\\n    }\\n  }\\n\\n  /**\\n   * @notice          Returns the endpoint of `memView`.\\n   * @param memView   The view\\n   * @return          uint256 - The endpoint of `memView`\\n   */\\n  function end(bytes29 memView) internal pure returns (uint256) {\\n    unchecked {\\n      return loc(memView) + len(memView);\\n    }\\n  }\\n\\n  /**\\n   * @notice          Safe slicing without memory modification.\\n   * @param memView   The view\\n   * @param _index    The start index\\n   * @param _len      The length\\n   * @param newType   The new type\\n   * @return          bytes29 - The new view\\n   */\\n  function slice(\\n    bytes29 memView,\\n    uint256 _index,\\n    uint256 _len,\\n    uint40 newType\\n  ) internal pure returns (bytes29) {\\n    uint256 _loc = loc(memView);\\n\\n    // Ensure it doesn't overrun the view\\n    if (_loc + _index + _len > end(memView)) {\\n      return NULL;\\n    }\\n\\n    _loc = _loc + _index;\\n    return build(newType, _loc, _len);\\n  }\\n\\n  /**\\n   * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\\n   * @param memView   The view\\n   * @param _len      The length\\n   * @param newType   The new type\\n   * @return          bytes29 - The new view\\n   */\\n  function prefix(\\n    bytes29 memView,\\n    uint256 _len,\\n    uint40 newType\\n  ) internal pure returns (bytes29) {\\n    return slice(memView, 0, _len, newType);\\n  }\\n\\n  /**\\n   * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\\n   * @param memView   The view\\n   * @param _len      The length\\n   * @param newType   The new type\\n   * @return          bytes29 - The new view\\n   */\\n  function postfix(\\n    bytes29 memView,\\n    uint256 _len,\\n    uint40 newType\\n  ) internal pure returns (bytes29) {\\n    return slice(memView, uint256(len(memView)) - _len, _len, newType);\\n  }\\n\\n  /**\\n   * @notice          Construct an error message for an indexing overrun.\\n   * @param _loc      The memory address\\n   * @param _len      The length\\n   * @param _index    The index\\n   * @param _slice    The slice where the overrun occurred\\n   * @return          err - The err\\n   */\\n  function indexErrOverrun(\\n    uint256 _loc,\\n    uint256 _len,\\n    uint256 _index,\\n    uint256 _slice\\n  ) internal pure returns (string memory err) {\\n    (, uint256 a) = encodeHex(_loc);\\n    (, uint256 b) = encodeHex(_len);\\n    (, uint256 c) = encodeHex(_index);\\n    (, uint256 d) = encodeHex(_slice);\\n    err = string(\\n      abi.encodePacked(\\n        \\\"TypedMemView/index - Overran the view. Slice is at 0x\\\",\\n        uint48(a),\\n        \\\" with length 0x\\\",\\n        uint48(b),\\n        \\\". Attempted to index at offset 0x\\\",\\n        uint48(c),\\n        \\\" with length 0x\\\",\\n        uint48(d),\\n        \\\".\\\"\\n      )\\n    );\\n  }\\n\\n  /**\\n   * @notice          Load up to 32 bytes from the view onto the stack.\\n   * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\\n   *                  This can be immediately cast to a smaller fixed-length byte array.\\n   *                  To automatically cast to an integer, use `indexUint`.\\n   * @param memView   The view\\n   * @param _index    The index\\n   * @param _bytes    The bytes\\n   * @return          result - The 32 byte result\\n   */\\n  function index(\\n    bytes29 memView,\\n    uint256 _index,\\n    uint8 _bytes\\n  ) internal pure returns (bytes32 result) {\\n    if (_bytes == 0) {\\n      return bytes32(0);\\n    }\\n    if (_index + _bytes > len(memView)) {\\n      revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\\n    }\\n    require(_bytes <= 32, \\\"TypedMemView/index - Attempted to index more than 32 bytes\\\");\\n\\n    uint8 bitLength;\\n    unchecked {\\n      bitLength = _bytes * 8;\\n    }\\n    uint256 _loc = loc(memView);\\n    uint256 _mask = leftMask(bitLength);\\n    assembly {\\n      // solhint-disable-previous-line no-inline-assembly\\n      result := and(mload(add(_loc, _index)), _mask)\\n    }\\n  }\\n\\n  /**\\n   * @notice          Parse an unsigned integer from the view at `_index`.\\n   * @dev             Requires that the view have >= `_bytes` bytes following that index.\\n   * @param memView   The view\\n   * @param _index    The index\\n   * @param _bytes    The bytes\\n   * @return          result - The unsigned integer\\n   */\\n  function indexUint(\\n    bytes29 memView,\\n    uint256 _index,\\n    uint8 _bytes\\n  ) internal pure returns (uint256 result) {\\n    return uint256(index(memView, _index, _bytes)) >> ((32 - _bytes) * 8);\\n  }\\n\\n  /**\\n   * @notice          Parse an unsigned integer from LE bytes.\\n   * @param memView   The view\\n   * @param _index    The index\\n   * @param _bytes    The bytes\\n   * @return          result - The unsigned integer\\n   */\\n  function indexLEUint(\\n    bytes29 memView,\\n    uint256 _index,\\n    uint8 _bytes\\n  ) internal pure returns (uint256 result) {\\n    return reverseUint256(uint256(index(memView, _index, _bytes)));\\n  }\\n\\n  /**\\n   * @notice          Parse an address from the view at `_index`. Requires that the view have >= 20 bytes\\n   *                  following that index.\\n   * @param memView   The view\\n   * @param _index    The index\\n   * @return          address - The address\\n   */\\n  function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\\n    return address(uint160(indexUint(memView, _index, 20)));\\n  }\\n\\n  /**\\n   * @notice          Return the keccak256 hash of the underlying memory\\n   * @param memView   The view\\n   * @return          digest - The keccak256 hash of the underlying memory\\n   */\\n  function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\\n    uint256 _loc = loc(memView);\\n    uint256 _len = len(memView);\\n    assembly {\\n      // solhint-disable-previous-line no-inline-assembly\\n      digest := keccak256(_loc, _len)\\n    }\\n  }\\n\\n  /**\\n   * @notice          Return the sha2 digest of the underlying memory.\\n   * @dev             We explicitly deallocate memory afterwards.\\n   * @param memView   The view\\n   * @return          digest - The sha2 hash of the underlying memory\\n   */\\n  function sha2(bytes29 memView) internal view returns (bytes32 digest) {\\n    uint256 _loc = loc(memView);\\n    uint256 _len = len(memView);\\n    assembly {\\n      // solhint-disable-previous-line no-inline-assembly\\n      let ptr := mload(0x40)\\n      pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\\n      digest := mload(ptr)\\n    }\\n  }\\n\\n  /**\\n   * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\\n   * @param memView   The pre-image\\n   * @return          digest - the Digest\\n   */\\n  function hash160(bytes29 memView) internal view returns (bytes20 digest) {\\n    uint256 _loc = loc(memView);\\n    uint256 _len = len(memView);\\n    assembly {\\n      // solhint-disable-previous-line no-inline-assembly\\n      let ptr := mload(0x40)\\n      pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2\\n      pop(staticcall(gas(), 3, ptr, 0x20, ptr, 0x20)) // rmd160\\n      digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\\n    }\\n  }\\n\\n  /**\\n   * @notice          Implements bitcoin's hash256 (double sha2)\\n   * @param memView   A view of the preimage\\n   * @return          digest - the Digest\\n   */\\n  function hash256(bytes29 memView) internal view returns (bytes32 digest) {\\n    uint256 _loc = loc(memView);\\n    uint256 _len = len(memView);\\n    assembly {\\n      // solhint-disable-previous-line no-inline-assembly\\n      let ptr := mload(0x40)\\n      pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\\n      pop(staticcall(gas(), 2, ptr, 0x20, ptr, 0x20)) // sha2 #2\\n      digest := mload(ptr)\\n    }\\n  }\\n\\n  /**\\n   * @notice          Return true if the underlying memory is equal. Else false.\\n   * @param left      The first view\\n   * @param right     The second view\\n   * @return          bool - True if the underlying memory is equal\\n   */\\n  function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\\n    return (loc(left) == loc(right) && len(left) == len(right)) || keccak(left) == keccak(right);\\n  }\\n\\n  /**\\n   * @notice          Return false if the underlying memory is equal. Else true.\\n   * @param left      The first view\\n   * @param right     The second view\\n   * @return          bool - False if the underlying memory is equal\\n   */\\n  function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\\n    return !untypedEqual(left, right);\\n  }\\n\\n  /**\\n   * @notice          Compares type equality.\\n   * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\\n   * @param left      The first view\\n   * @param right     The second view\\n   * @return          bool - True if the types are the same\\n   */\\n  function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\\n    return left == right || (typeOf(left) == typeOf(right) && keccak(left) == keccak(right));\\n  }\\n\\n  /**\\n   * @notice          Compares type inequality.\\n   * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\\n   * @param left      The first view\\n   * @param right     The second view\\n   * @return          bool - True if the types are not the same\\n   */\\n  function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\\n    return !equal(left, right);\\n  }\\n\\n  /**\\n   * @notice          Copy the view to a location, return an unsafe memory reference\\n   * @dev             Super Dangerous direct memory access.\\n   *\\n   *                  This reference can be overwritten if anything else modifies memory (!!!).\\n   *                  As such it MUST be consumed IMMEDIATELY.\\n   *                  This function is private to prevent unsafe usage by callers.\\n   * @param memView   The view\\n   * @param _newLoc   The new location\\n   * @return          written - the unsafe memory reference\\n   */\\n  function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\\n    require(notNull(memView), \\\"TypedMemView/copyTo - Null pointer deref\\\");\\n    require(isValid(memView), \\\"TypedMemView/copyTo - Invalid pointer deref\\\");\\n    uint256 _len = len(memView);\\n    uint256 _oldLoc = loc(memView);\\n\\n    uint256 ptr;\\n    assembly {\\n      // solhint-disable-previous-line no-inline-assembly\\n      ptr := mload(0x40)\\n      // revert if we're writing in occupied memory\\n      if gt(ptr, _newLoc) {\\n        revert(0x60, 0x20) // empty revert message\\n      }\\n\\n      // use the identity precompile to copy\\n      // guaranteed not to fail, so pop the success\\n      pop(staticcall(gas(), 4, _oldLoc, _len, _newLoc, _len))\\n    }\\n\\n    written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\\n  }\\n\\n  /**\\n   * @notice          Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to\\n   *                  the new memory\\n   * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\\n   * @param memView   The view\\n   * @return          ret - The view pointing to the new memory\\n   */\\n  function clone(bytes29 memView) internal view returns (bytes memory ret) {\\n    uint256 ptr;\\n    uint256 _len = len(memView);\\n    assembly {\\n      // solhint-disable-previous-line no-inline-assembly\\n      ptr := mload(0x40) // load unused memory pointer\\n      ret := ptr\\n    }\\n    unchecked {\\n      unsafeCopyTo(memView, ptr + 0x20);\\n    }\\n    assembly {\\n      // solhint-disable-previous-line no-inline-assembly\\n      mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\\n      mstore(ptr, _len) // write len of new array (in bytes)\\n    }\\n  }\\n\\n  /**\\n   * @notice          Join the views in memory, return an unsafe reference to the memory.\\n   * @dev             Super Dangerous direct memory access.\\n   *\\n   *                  This reference can be overwritten if anything else modifies memory (!!!).\\n   *                  As such it MUST be consumed IMMEDIATELY.\\n   *                  This function is private to prevent unsafe usage by callers.\\n   * @param memViews  The views\\n   * @return          unsafeView - The conjoined view pointing to the new memory\\n   */\\n  function unsafeJoin(bytes29[] memory memViews, uint256 _location) private view returns (bytes29 unsafeView) {\\n    assembly {\\n      // solhint-disable-previous-line no-inline-assembly\\n      let ptr := mload(0x40)\\n      // revert if we're writing in occupied memory\\n      if gt(ptr, _location) {\\n        revert(0x60, 0x20) // empty revert message\\n      }\\n    }\\n\\n    uint256 _offset = 0;\\n    for (uint256 i = 0; i < memViews.length; i++) {\\n      bytes29 memView = memViews[i];\\n      unchecked {\\n        unsafeCopyTo(memView, _location + _offset);\\n        _offset += len(memView);\\n      }\\n    }\\n    unsafeView = unsafeBuildUnchecked(0, _location, _offset);\\n  }\\n\\n  /**\\n   * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\\n   * @param memViews  The views\\n   * @return          bytes32 - The keccak256 digest\\n   */\\n  function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\\n    uint256 ptr;\\n    assembly {\\n      // solhint-disable-previous-line no-inline-assembly\\n      ptr := mload(0x40) // load unused memory pointer\\n    }\\n    return keccak(unsafeJoin(memViews, ptr));\\n  }\\n\\n  /**\\n   * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\\n   * @param memViews  The views\\n   * @return          bytes32 - The sha256 digest\\n   */\\n  function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\\n    uint256 ptr;\\n    assembly {\\n      // solhint-disable-previous-line no-inline-assembly\\n      ptr := mload(0x40) // load unused memory pointer\\n    }\\n    return sha2(unsafeJoin(memViews, ptr));\\n  }\\n\\n  /**\\n   * @notice          copies all views, joins them into a new bytearray.\\n   * @param memViews  The views\\n   * @return          ret - The new byte array\\n   */\\n  function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\\n    uint256 ptr;\\n    assembly {\\n      // solhint-disable-previous-line no-inline-assembly\\n      ptr := mload(0x40) // load unused memory pointer\\n    }\\n\\n    bytes29 _newView;\\n    unchecked {\\n      _newView = unsafeJoin(memViews, ptr + 0x20);\\n    }\\n    uint256 _written = len(_newView);\\n    uint256 _footprint = footprint(_newView);\\n\\n    assembly {\\n      // solhint-disable-previous-line no-inline-assembly\\n      // store the legnth\\n      mstore(ptr, _written)\\n      // new pointer is old + 0x20 + the footprint of the body\\n      mstore(0x40, add(add(ptr, _footprint), 0x20))\\n      ret := ptr\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0xe3b9e398dff8870d5a597de93a9cb0aa139f27ed27c12bbe78c8ff60d85b0aaf\",\"license\":\"MIT OR Apache-2.0\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50612098806100206000396000f3fe6080604052600436106101405760003560e01c806354064594116100b65780639bf6d8751161006f5780639bf6d875146103cf578063c6bf691d146103e4578063da3a892f1461041d578063e9160f3e1461043d578063eb492f441461045d578063ffaf3f1a1461047d57600080fd5b80635406459414610303578063582c78d2146103165780636ae0b1541461033657806382904716146103565780638770e68214610376578063899962a1146103af57600080fd5b8063197c139d11610108578063197c139d1461022a57806322a3c0071461024a5780632d3f9ef61461026a5780633b688da61461027d57806341258b5c146102ce5780634b72c5da146102ee57600080fd5b806304376ff4146101455780630951d6d81461016757806309935b8f1461018b57806312d57170146101ab5780631407093b146101e1575b600080fd5b34801561015157600080fd5b50610165610160366004611db7565b61049d565b005b34801561017357600080fd5b506001545b6040519081526020015b60405180910390f35b34801561019757600080fd5b506101656101a6366004611db7565b610595565b3480156101b757600080fd5b506101786101c6366004611db7565b6001600160a01b03166000908152601f602052604090205490565b3480156101ed57600080fd5b5061021a6101fc366004611db7565b6001600160a01b03166000908152601a602052604090205460ff1690565b6040519015158152602001610182565b34801561023657600080fd5b50610165610245366004611dd4565b610753565b34801561025657600080fd5b50610165610265366004611e27565b6107f1565b610165610278366004611e60565b610939565b34801561028957600080fd5b506102b6610298366004611db7565b6001600160a01b039081166000908152601e60205260409020541690565b6040516001600160a01b039091168152602001610182565b3480156102da57600080fd5b506101786102e9366004611e27565b61099b565b3480156102fa57600080fd5b50612710610178565b610165610311366004611ea2565b6109c8565b34801561032257600080fd5b50610165610331366004611ec7565b610a29565b34801561034257600080fd5b50610165610351366004611db7565b610b27565b34801561036257600080fd5b50610165610371366004611ec7565b610d88565b34801561038257600080fd5b5061021a610391366004611db7565b6001600160a01b03166000908152601b602052604090205460ff1690565b3480156103bb57600080fd5b506101656103ca366004611e60565b610e53565b3480156103db57600080fd5b50601054610178565b3480156103f057600080fd5b506102b66103ff366004611db7565b6001600160a01b039081166000908152601c60205260409020541690565b34801561042957600080fd5b50610165610438366004611db7565b610eac565b34801561044957600080fd5b506102b6610458366004611db7565b610fed565b34801561046957600080fd5b50610165610478366004611ee0565b61101f565b34801561048957600080fd5b50610165610498366004611e27565b61120c565b336104a661130e565b6001600160a01b0316141580156104e1575060033360009081526019602052604090205460ff1660038111156104de576104de611f10565b14155b156104ff57604051637b32c26b60e01b815260040160405180910390fd5b6001600160a01b0381166000908152601b602052604090205460ff1661053857604051635d3abc4360e11b815260040160405180910390fd5b6001600160a01b0381166000818152601b6020908152604091829020805460ff19169055815192835233908301527f903522f09b29fa2102f5d8d8b181ac8edb4cfaf5d705076e4ab95117f6bb02ad91015b60405180910390a150565b6001600160a01b038082166000908152601e60205260409020548291168061061e576001600160a01b038083166000908152601d602052604090205416801580156105e85750336001600160a01b038416145b806105fb57506001600160a01b03811633145b6106185760405163f72e7a4760e01b815260040160405180910390fd5b50610647565b336001600160a01b0382161461064757604051630c2baa6160e41b815260040160405180910390fd5b600061065284610fed565b6001600160a01b0385166000908152601f602052604090205490915062093a809061067d9042611f3c565b1161069b576040516376b2ad0760e01b815260040160405180910390fd5b6001600160a01b038085166000908152601e6020908152604080832054601d90925290912080546001600160a01b031916919092169081179091558015610703576001600160a01b0385166000908152601e6020526040902080546001600160a01b03191690555b6001600160a01b038086166000818152601f60205260408082208290555184841693861692917fd73892e8827a6025d74a01fca72a8e0d9e2c04080272e728f8861410c7d3c2d191a45050505050565b6020546001190161077757604051637ce54e2d60e11b815260040160405180910390fd5b600260205560235460ff16156107a057604051633ee5b89360e01b815260040160405180910390fd5b6107a981610fed565b6001600160a01b0316336001600160a01b0316146107da5760405163f3dc2d1960e01b815260040160405180910390fd5b6107e68484848461133c565b505060016020555050565b6001600160a01b038083166000908152601d6020526040902054839116801580156108245750336001600160a01b038316145b8061083757506001600160a01b03811633145b6108545760405163407c584960e01b815260040160405180910390fd5b826001600160a01b031661086785610fed565b6001600160a01b03160361088e57604051630e49614b60e31b815260040160405180910390fd5b6001600160a01b038085166000908152601e6020526040902054811690841681036108cc57604051631b2163f160e31b815260040160405180910390fd5b6001600160a01b038581166000818152601e6020908152604080832080546001600160a01b0319168a8716908117909155601f909252808320429055519093851692917fee0158b57adc03901d8b16c48cd10c33ca1283ee96c6e0d30f817ceba74dc4a191a45050505050565b6020546001190161095d57604051637ce54e2d60e11b815260040160405180910390fd5b600260205560235460ff161561098657604051633ee5b89360e01b815260040160405180910390fd5b6109918383836114b6565b5050600160205550565b6001600160a01b038083166000908152600e60209081526040808320938516835292905220545b92915050565b602054600119016109ec57604051637ce54e2d60e11b815260040160405180910390fd5b600260205560235460ff1615610a1557604051633ee5b89360e01b815260040160405180910390fd5b610a208282336114b6565b50506001602055565b33610a3261130e565b6001600160a01b031614158015610a6d575060033360009081526019602052604090205460ff166003811115610a6a57610a6a611f10565b14155b15610a8b57604051637b32c26b60e01b815260040160405180910390fd5b6127106064610a9b82605f611f53565b610aa59190611f72565b821015610ac55760405163b74bfc8360e01b815260040160405180910390fd5b80821115610ae657604051637347083360e11b815260040160405180910390fd5b6001829055604080518381523360208201527feb6222a0b32216f861511e9aba88faa9549b749c2e0ad47df4e288565de5ceae910160405180910390a15050565b33610b3061130e565b6001600160a01b031614158015610b6b575060013360009081526019602052604090205460ff166003811115610b6857610b68611f10565b14155b15610b89576040516360237f6b60e11b815260040160405180910390fd5b6001600160a01b038116610bb05760405163128df0bf60e21b815260040160405180910390fd5b6001600160a01b0381166000908152601a602052604090205460ff16610be957604051633fb36f5d60e01b815260040160405180910390fd5b6001600160a01b0381166000818152601a6020908152604091829020805460ff1916905590513381527fbee3e974bb6a6f44f20096ede047c191eef60322e65e4ee4bd3392230a8716d5910160405180910390a26001600160a01b038082166000908152601d6020526040902054168015610cc0576040516000906001600160a01b0383811691908516907fd73892e8827a6025d74a01fca72a8e0d9e2c04080272e728f8861410c7d3c2d1908490a46001600160a01b0382166000908152601d6020526040902080546001600160a01b03191690555b6001600160a01b038083166000908152601c6020526040902054168015610d43576040516000906001600160a01b0383811691908616907f31f32ebf07b0ac7fe173f7b7f3f943020d9bdc6dbfbdcdae01bd45ea78d953d7908490a46001600160a01b0383166000908152601c6020526040902080546001600160a01b03191690555b50506001600160a01b03166000908152601e6020908152604080832080546001600160a01b0319169055601f8252808320839055601b9091529020805460ff19169055565b33610d9161130e565b6001600160a01b031614158015610dcc575060033360009081526019602052604090205460ff166003811115610dc957610dc9611f10565b14155b15610dea57604051637b32c26b60e01b815260040160405180910390fd5b801580610df8575060105481145b15610e1657604051630d9f9fad60e01b815260040160405180910390fd5b604080518281523360208201527fa7fe33308fb33ae6f3259e3c7c954ae3d6cd7f428cd17f653413c2cdc691666d910160405180910390a1601055565b60205460011901610e7757604051637ce54e2d60e11b815260040160405180910390fd5b600260205560235460ff1615610ea057604051633ee5b89360e01b815260040160405180910390fd5b6109918383833361133c565b33610eb561130e565b6001600160a01b031614158015610ef0575060033360009081526019602052604090205460ff166003811115610eed57610eed611f10565b14155b15610f0e57604051637b32c26b60e01b815260040160405180910390fd5b6001600160a01b0381166000908152601a602052604090205460ff16158015610f3c5750610f3a6116c8565b155b15610f5a576040516375befccb60e01b815260040160405180910390fd5b6001600160a01b0381166000908152601b602052604090205460ff1615610f945760405163c896c2d960e01b815260040160405180910390fd5b6001600160a01b0381166000818152601b6020908152604091829020805460ff19166001179055815192835233908301527fc428fad4df337e27be8199c35a79ca103e8d00538a69b0f9701fb2bdf7d6c84c910161058a565b6001600160a01b038082166000908152601d602052604081205490911680156110165780611018565b825b9392505050565b3361102861130e565b6001600160a01b031614158015611063575060013360009081526019602052604090205460ff16600381111561106057611060611f10565b14155b15611081576040516360237f6b60e11b815260040160405180910390fd5b6001600160a01b0383166110a85760405163e0239aa960e01b815260040160405180910390fd5b6001600160a01b0383166000908152601a602052604090205460ff16156110e25760405163201b2fd160e11b815260040160405180910390fd5b6001600160a01b0383166000818152601a6020908152604091829020805460ff1916600117905590513381527fbc68405e644da2aaf25623ce2199da82c6dfd2e1de102b400eba6a091704d4f4910160405180910390a26001600160a01b038216156111a0576001600160a01b038381166000818152601d602052604080822080546001600160a01b0319169487169485179055519091907fd73892e8827a6025d74a01fca72a8e0d9e2c04080272e728f8861410c7d3c2d1908390a45b6001600160a01b03811615611207576001600160a01b038381166000818152601c602052604080822080546001600160a01b0319169486169485179055519091907f31f32ebf07b0ac7fe173f7b7f3f943020d9bdc6dbfbdcdae01bd45ea78d953d7908390a45b505050565b6001600160a01b038083166000908152601d60205260409020548391168015801561123f5750336001600160a01b038316145b8061125257506001600160a01b03811633145b61126f5760405163407c584960e01b815260040160405180910390fd5b6001600160a01b038085166000908152601c6020526040902054811690841681036112ad57604051631b0043f560e31b815260040160405180910390fd5b6001600160a01b038581166000818152601c602052604080822080546001600160a01b03191689861690811790915590519093851692917f31f32ebf07b0ac7fe173f7b7f3f943020d9bdc6dbfbdcdae01bd45ea78d953d791a45050505050565b7fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c1320546001600160a01b031690565b6001600160a01b038181166000908152601c60205260409020541680156113635780611365565b825b90506001600160a01b03811661138e5760405163516101e760e11b815260040160405180910390fd5b846000036113af5760405163606ab7a160e11b815260040160405180910390fd5b60006113ba856116ef565b905060006113d08260200151836000015161170e565b6001600160a01b038086166000908152600e60209081526040808320938b16835292905220549091508781101561141a57604051630a1e6d4d60e01b815260040160405180910390fd5b6001600160a01b038086166000908152600e60209081526040808320938b16835292905220888203905561144f87858a611750565b604080516001600160a01b0386811682528981166020830152918101849052606081018a9052336080820152908616907ffacf3161e9675ca1ca84a16d238bc838c7e2084c302cf411d9da7ac0391f64869060a00160405180910390a25050505050505050565b6001600160a01b0381166114dd576040516339773cbf60e21b815260040160405180910390fd5b826000036114fe57604051632a24141960e01b815260040160405180910390fd5b60008061150a8461178f565b915091506115166116c8565b15801561153c57506001600160a01b0383166000908152601a602052604090205460ff16155b1561155a57604051631464c65f60e31b815260040160405180910390fd5b815160045463ffffffff918216911603611626576040516370a0823160e01b815230600482015260009086906001600160a01b038716906370a0823190602401602060405180830381865afa1580156115b7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115db9190611f94565b6115e59190611fad565b600083815260076020526040902054909150801580159061160557508082115b1561162357604051638ada373160e01b815260040160405180910390fd5b50505b6116308486611813565b6001600160a01b038084166000908152600e6020908152604080832093881683529290529081208054879290611667908490611fad565b9091555050604080516001600160a01b03868116825260208201849052918101879052336060820152908416907fcc3100122c1752fe0f6bfa5503175bc53eb00b5f2d774e81efedcd2b10a6d24b9060800160405180910390a25050505050565b6000806116d361130e565b6001600160a01b031614806116ea575060155460ff165b905090565b60408051808201909152600080825260208201526109c2826000611953565b6000828260405160200161173292919091825263ffffffff16602082015260400190565b60405160208183030381529060405280519060200120905092915050565b8060000361175d57505050565b6001600160a01b03831661178457604051633a48ca7b60e11b815260040160405180910390fd5b611207838383611a4b565b60408051808201909152600080825260208201526000806117af846116ef565b905060006117c58260200151836000015161170e565b90506117cf611aae565b1580156117eb575060008181526006602052604090205460ff16155b156118095760405163d7ad34f160e01b815260040160405180910390fd5b9094909350915050565b8060000361181f575050565b6001600160a01b03821661184657604051632a38b13360e01b815260040160405180910390fd5b6040516370a0823160e01b81523060048201526000906001600160a01b038416906370a0823190602401602060405180830381865afa15801561188d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118b19190611f94565b90506118bf83333085611ad3565b6040516370a0823160e01b8152306004820152829082906001600160a01b038616906370a0823190602401602060405180830381865afa158015611907573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061192b9190611f94565b6119359190611f3c565b1461120757604051630e40773560e21b815260040160405180910390fd5b604080518082019091526000808252602082015260408051808201909152600080825260208201526001600160a01b0384166119905790506109c2565b506001600160a01b03831660009081526008830160209081526040918290208251808401909352805463ffffffff1680845260019091015491830191909152156119db5790506109c2565b6119e58484611b11565b15611a0b57600483015463ffffffff1681526001600160a01b0384166020820152611018565b506001600160a01b03831660009081526009830160209081526040918290208251808401909352805463ffffffff16835260010154908201529392505050565b6040516001600160a01b03831660248201526044810182905261120790849063a9059cbb60e01b906064015b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b031990931692909217909152611b47565b600080611ab961130e565b6001600160a01b031614806116ea57505060175460ff1690565b6040516001600160a01b0380851660248301528316604482015260648101829052611b0b9085906323b872dd60e01b90608401611a77565b50505050565b6001600160a01b038216600090815260098201602052604081205463ffffffff1615611b3f575060006109c2565b50503b151590565b6000611b9c826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b0316611c1e9092919063ffffffff16565b8051909150156112075780806020019051810190611bba9190611fc5565b6112075760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b60648201526084015b60405180910390fd5b6060611c2d8484600085611c35565b949350505050565b606082471015611c965760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b6064820152608401611c15565b6001600160a01b0385163b611ced5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606401611c15565b600080866001600160a01b03168587604051611d099190612013565b60006040518083038185875af1925050503d8060008114611d46576040519150601f19603f3d011682016040523d82523d6000602084013e611d4b565b606091505b5091509150611d5b828286611d66565b979650505050505050565b60608315611d75575081611018565b825115611d855782518084602001fd5b8160405162461bcd60e51b8152600401611c15919061202f565b6001600160a01b0381168114611db457600080fd5b50565b600060208284031215611dc957600080fd5b813561101881611d9f565b60008060008060808587031215611dea57600080fd5b843593506020850135611dfc81611d9f565b92506040850135611e0c81611d9f565b91506060850135611e1c81611d9f565b939692955090935050565b60008060408385031215611e3a57600080fd5b8235611e4581611d9f565b91506020830135611e5581611d9f565b809150509250929050565b600080600060608486031215611e7557600080fd5b833592506020840135611e8781611d9f565b91506040840135611e9781611d9f565b809150509250925092565b60008060408385031215611eb557600080fd5b823591506020830135611e5581611d9f565b600060208284031215611ed957600080fd5b5035919050565b600080600060608486031215611ef557600080fd5b8335611f0081611d9f565b92506020840135611e8781611d9f565b634e487b7160e01b600052602160045260246000fd5b634e487b7160e01b600052601160045260246000fd5b600082821015611f4e57611f4e611f26565b500390565b6000816000190483118215151615611f6d57611f6d611f26565b500290565b600082611f8f57634e487b7160e01b600052601260045260246000fd5b500490565b600060208284031215611fa657600080fd5b5051919050565b60008219821115611fc057611fc0611f26565b500190565b600060208284031215611fd757600080fd5b8151801515811461101857600080fd5b60005b83811015612002578181015183820152602001611fea565b83811115611b0b5750506000910152565b60008251612025818460208701611fe7565b9190910192915050565b602081526000825180602084015261204e816040850160208701611fe7565b601f01601f1916919091016040019291505056fea2646970667358221220a54756761a4c3b8e429bf9007f2e24fe44e2614f3825069c54f40fb17a90b5f564736f6c634300080f0033",
  "deployedBytecode": "0x6080604052600436106101405760003560e01c806354064594116100b65780639bf6d8751161006f5780639bf6d875146103cf578063c6bf691d146103e4578063da3a892f1461041d578063e9160f3e1461043d578063eb492f441461045d578063ffaf3f1a1461047d57600080fd5b80635406459414610303578063582c78d2146103165780636ae0b1541461033657806382904716146103565780638770e68214610376578063899962a1146103af57600080fd5b8063197c139d11610108578063197c139d1461022a57806322a3c0071461024a5780632d3f9ef61461026a5780633b688da61461027d57806341258b5c146102ce5780634b72c5da146102ee57600080fd5b806304376ff4146101455780630951d6d81461016757806309935b8f1461018b57806312d57170146101ab5780631407093b146101e1575b600080fd5b34801561015157600080fd5b50610165610160366004611db7565b61049d565b005b34801561017357600080fd5b506001545b6040519081526020015b60405180910390f35b34801561019757600080fd5b506101656101a6366004611db7565b610595565b3480156101b757600080fd5b506101786101c6366004611db7565b6001600160a01b03166000908152601f602052604090205490565b3480156101ed57600080fd5b5061021a6101fc366004611db7565b6001600160a01b03166000908152601a602052604090205460ff1690565b6040519015158152602001610182565b34801561023657600080fd5b50610165610245366004611dd4565b610753565b34801561025657600080fd5b50610165610265366004611e27565b6107f1565b610165610278366004611e60565b610939565b34801561028957600080fd5b506102b6610298366004611db7565b6001600160a01b039081166000908152601e60205260409020541690565b6040516001600160a01b039091168152602001610182565b3480156102da57600080fd5b506101786102e9366004611e27565b61099b565b3480156102fa57600080fd5b50612710610178565b610165610311366004611ea2565b6109c8565b34801561032257600080fd5b50610165610331366004611ec7565b610a29565b34801561034257600080fd5b50610165610351366004611db7565b610b27565b34801561036257600080fd5b50610165610371366004611ec7565b610d88565b34801561038257600080fd5b5061021a610391366004611db7565b6001600160a01b03166000908152601b602052604090205460ff1690565b3480156103bb57600080fd5b506101656103ca366004611e60565b610e53565b3480156103db57600080fd5b50601054610178565b3480156103f057600080fd5b506102b66103ff366004611db7565b6001600160a01b039081166000908152601c60205260409020541690565b34801561042957600080fd5b50610165610438366004611db7565b610eac565b34801561044957600080fd5b506102b6610458366004611db7565b610fed565b34801561046957600080fd5b50610165610478366004611ee0565b61101f565b34801561048957600080fd5b50610165610498366004611e27565b61120c565b336104a661130e565b6001600160a01b0316141580156104e1575060033360009081526019602052604090205460ff1660038111156104de576104de611f10565b14155b156104ff57604051637b32c26b60e01b815260040160405180910390fd5b6001600160a01b0381166000908152601b602052604090205460ff1661053857604051635d3abc4360e11b815260040160405180910390fd5b6001600160a01b0381166000818152601b6020908152604091829020805460ff19169055815192835233908301527f903522f09b29fa2102f5d8d8b181ac8edb4cfaf5d705076e4ab95117f6bb02ad91015b60405180910390a150565b6001600160a01b038082166000908152601e60205260409020548291168061061e576001600160a01b038083166000908152601d602052604090205416801580156105e85750336001600160a01b038416145b806105fb57506001600160a01b03811633145b6106185760405163f72e7a4760e01b815260040160405180910390fd5b50610647565b336001600160a01b0382161461064757604051630c2baa6160e41b815260040160405180910390fd5b600061065284610fed565b6001600160a01b0385166000908152601f602052604090205490915062093a809061067d9042611f3c565b1161069b576040516376b2ad0760e01b815260040160405180910390fd5b6001600160a01b038085166000908152601e6020908152604080832054601d90925290912080546001600160a01b031916919092169081179091558015610703576001600160a01b0385166000908152601e6020526040902080546001600160a01b03191690555b6001600160a01b038086166000818152601f60205260408082208290555184841693861692917fd73892e8827a6025d74a01fca72a8e0d9e2c04080272e728f8861410c7d3c2d191a45050505050565b6020546001190161077757604051637ce54e2d60e11b815260040160405180910390fd5b600260205560235460ff16156107a057604051633ee5b89360e01b815260040160405180910390fd5b6107a981610fed565b6001600160a01b0316336001600160a01b0316146107da5760405163f3dc2d1960e01b815260040160405180910390fd5b6107e68484848461133c565b505060016020555050565b6001600160a01b038083166000908152601d6020526040902054839116801580156108245750336001600160a01b038316145b8061083757506001600160a01b03811633145b6108545760405163407c584960e01b815260040160405180910390fd5b826001600160a01b031661086785610fed565b6001600160a01b03160361088e57604051630e49614b60e31b815260040160405180910390fd5b6001600160a01b038085166000908152601e6020526040902054811690841681036108cc57604051631b2163f160e31b815260040160405180910390fd5b6001600160a01b038581166000818152601e6020908152604080832080546001600160a01b0319168a8716908117909155601f909252808320429055519093851692917fee0158b57adc03901d8b16c48cd10c33ca1283ee96c6e0d30f817ceba74dc4a191a45050505050565b6020546001190161095d57604051637ce54e2d60e11b815260040160405180910390fd5b600260205560235460ff161561098657604051633ee5b89360e01b815260040160405180910390fd5b6109918383836114b6565b5050600160205550565b6001600160a01b038083166000908152600e60209081526040808320938516835292905220545b92915050565b602054600119016109ec57604051637ce54e2d60e11b815260040160405180910390fd5b600260205560235460ff1615610a1557604051633ee5b89360e01b815260040160405180910390fd5b610a208282336114b6565b50506001602055565b33610a3261130e565b6001600160a01b031614158015610a6d575060033360009081526019602052604090205460ff166003811115610a6a57610a6a611f10565b14155b15610a8b57604051637b32c26b60e01b815260040160405180910390fd5b6127106064610a9b82605f611f53565b610aa59190611f72565b821015610ac55760405163b74bfc8360e01b815260040160405180910390fd5b80821115610ae657604051637347083360e11b815260040160405180910390fd5b6001829055604080518381523360208201527feb6222a0b32216f861511e9aba88faa9549b749c2e0ad47df4e288565de5ceae910160405180910390a15050565b33610b3061130e565b6001600160a01b031614158015610b6b575060013360009081526019602052604090205460ff166003811115610b6857610b68611f10565b14155b15610b89576040516360237f6b60e11b815260040160405180910390fd5b6001600160a01b038116610bb05760405163128df0bf60e21b815260040160405180910390fd5b6001600160a01b0381166000908152601a602052604090205460ff16610be957604051633fb36f5d60e01b815260040160405180910390fd5b6001600160a01b0381166000818152601a6020908152604091829020805460ff1916905590513381527fbee3e974bb6a6f44f20096ede047c191eef60322e65e4ee4bd3392230a8716d5910160405180910390a26001600160a01b038082166000908152601d6020526040902054168015610cc0576040516000906001600160a01b0383811691908516907fd73892e8827a6025d74a01fca72a8e0d9e2c04080272e728f8861410c7d3c2d1908490a46001600160a01b0382166000908152601d6020526040902080546001600160a01b03191690555b6001600160a01b038083166000908152601c6020526040902054168015610d43576040516000906001600160a01b0383811691908616907f31f32ebf07b0ac7fe173f7b7f3f943020d9bdc6dbfbdcdae01bd45ea78d953d7908490a46001600160a01b0383166000908152601c6020526040902080546001600160a01b03191690555b50506001600160a01b03166000908152601e6020908152604080832080546001600160a01b0319169055601f8252808320839055601b9091529020805460ff19169055565b33610d9161130e565b6001600160a01b031614158015610dcc575060033360009081526019602052604090205460ff166003811115610dc957610dc9611f10565b14155b15610dea57604051637b32c26b60e01b815260040160405180910390fd5b801580610df8575060105481145b15610e1657604051630d9f9fad60e01b815260040160405180910390fd5b604080518281523360208201527fa7fe33308fb33ae6f3259e3c7c954ae3d6cd7f428cd17f653413c2cdc691666d910160405180910390a1601055565b60205460011901610e7757604051637ce54e2d60e11b815260040160405180910390fd5b600260205560235460ff1615610ea057604051633ee5b89360e01b815260040160405180910390fd5b6109918383833361133c565b33610eb561130e565b6001600160a01b031614158015610ef0575060033360009081526019602052604090205460ff166003811115610eed57610eed611f10565b14155b15610f0e57604051637b32c26b60e01b815260040160405180910390fd5b6001600160a01b0381166000908152601a602052604090205460ff16158015610f3c5750610f3a6116c8565b155b15610f5a576040516375befccb60e01b815260040160405180910390fd5b6001600160a01b0381166000908152601b602052604090205460ff1615610f945760405163c896c2d960e01b815260040160405180910390fd5b6001600160a01b0381166000818152601b6020908152604091829020805460ff19166001179055815192835233908301527fc428fad4df337e27be8199c35a79ca103e8d00538a69b0f9701fb2bdf7d6c84c910161058a565b6001600160a01b038082166000908152601d602052604081205490911680156110165780611018565b825b9392505050565b3361102861130e565b6001600160a01b031614158015611063575060013360009081526019602052604090205460ff16600381111561106057611060611f10565b14155b15611081576040516360237f6b60e11b815260040160405180910390fd5b6001600160a01b0383166110a85760405163e0239aa960e01b815260040160405180910390fd5b6001600160a01b0383166000908152601a602052604090205460ff16156110e25760405163201b2fd160e11b815260040160405180910390fd5b6001600160a01b0383166000818152601a6020908152604091829020805460ff1916600117905590513381527fbc68405e644da2aaf25623ce2199da82c6dfd2e1de102b400eba6a091704d4f4910160405180910390a26001600160a01b038216156111a0576001600160a01b038381166000818152601d602052604080822080546001600160a01b0319169487169485179055519091907fd73892e8827a6025d74a01fca72a8e0d9e2c04080272e728f8861410c7d3c2d1908390a45b6001600160a01b03811615611207576001600160a01b038381166000818152601c602052604080822080546001600160a01b0319169486169485179055519091907f31f32ebf07b0ac7fe173f7b7f3f943020d9bdc6dbfbdcdae01bd45ea78d953d7908390a45b505050565b6001600160a01b038083166000908152601d60205260409020548391168015801561123f5750336001600160a01b038316145b8061125257506001600160a01b03811633145b61126f5760405163407c584960e01b815260040160405180910390fd5b6001600160a01b038085166000908152601c6020526040902054811690841681036112ad57604051631b0043f560e31b815260040160405180910390fd5b6001600160a01b038581166000818152601c602052604080822080546001600160a01b03191689861690811790915590519093851692917f31f32ebf07b0ac7fe173f7b7f3f943020d9bdc6dbfbdcdae01bd45ea78d953d791a45050505050565b7fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c1320546001600160a01b031690565b6001600160a01b038181166000908152601c60205260409020541680156113635780611365565b825b90506001600160a01b03811661138e5760405163516101e760e11b815260040160405180910390fd5b846000036113af5760405163606ab7a160e11b815260040160405180910390fd5b60006113ba856116ef565b905060006113d08260200151836000015161170e565b6001600160a01b038086166000908152600e60209081526040808320938b16835292905220549091508781101561141a57604051630a1e6d4d60e01b815260040160405180910390fd5b6001600160a01b038086166000908152600e60209081526040808320938b16835292905220888203905561144f87858a611750565b604080516001600160a01b0386811682528981166020830152918101849052606081018a9052336080820152908616907ffacf3161e9675ca1ca84a16d238bc838c7e2084c302cf411d9da7ac0391f64869060a00160405180910390a25050505050505050565b6001600160a01b0381166114dd576040516339773cbf60e21b815260040160405180910390fd5b826000036114fe57604051632a24141960e01b815260040160405180910390fd5b60008061150a8461178f565b915091506115166116c8565b15801561153c57506001600160a01b0383166000908152601a602052604090205460ff16155b1561155a57604051631464c65f60e31b815260040160405180910390fd5b815160045463ffffffff918216911603611626576040516370a0823160e01b815230600482015260009086906001600160a01b038716906370a0823190602401602060405180830381865afa1580156115b7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115db9190611f94565b6115e59190611fad565b600083815260076020526040902054909150801580159061160557508082115b1561162357604051638ada373160e01b815260040160405180910390fd5b50505b6116308486611813565b6001600160a01b038084166000908152600e6020908152604080832093881683529290529081208054879290611667908490611fad565b9091555050604080516001600160a01b03868116825260208201849052918101879052336060820152908416907fcc3100122c1752fe0f6bfa5503175bc53eb00b5f2d774e81efedcd2b10a6d24b9060800160405180910390a25050505050565b6000806116d361130e565b6001600160a01b031614806116ea575060155460ff165b905090565b60408051808201909152600080825260208201526109c2826000611953565b6000828260405160200161173292919091825263ffffffff16602082015260400190565b60405160208183030381529060405280519060200120905092915050565b8060000361175d57505050565b6001600160a01b03831661178457604051633a48ca7b60e11b815260040160405180910390fd5b611207838383611a4b565b60408051808201909152600080825260208201526000806117af846116ef565b905060006117c58260200151836000015161170e565b90506117cf611aae565b1580156117eb575060008181526006602052604090205460ff16155b156118095760405163d7ad34f160e01b815260040160405180910390fd5b9094909350915050565b8060000361181f575050565b6001600160a01b03821661184657604051632a38b13360e01b815260040160405180910390fd5b6040516370a0823160e01b81523060048201526000906001600160a01b038416906370a0823190602401602060405180830381865afa15801561188d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118b19190611f94565b90506118bf83333085611ad3565b6040516370a0823160e01b8152306004820152829082906001600160a01b038616906370a0823190602401602060405180830381865afa158015611907573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061192b9190611f94565b6119359190611f3c565b1461120757604051630e40773560e21b815260040160405180910390fd5b604080518082019091526000808252602082015260408051808201909152600080825260208201526001600160a01b0384166119905790506109c2565b506001600160a01b03831660009081526008830160209081526040918290208251808401909352805463ffffffff1680845260019091015491830191909152156119db5790506109c2565b6119e58484611b11565b15611a0b57600483015463ffffffff1681526001600160a01b0384166020820152611018565b506001600160a01b03831660009081526009830160209081526040918290208251808401909352805463ffffffff16835260010154908201529392505050565b6040516001600160a01b03831660248201526044810182905261120790849063a9059cbb60e01b906064015b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b031990931692909217909152611b47565b600080611ab961130e565b6001600160a01b031614806116ea57505060175460ff1690565b6040516001600160a01b0380851660248301528316604482015260648101829052611b0b9085906323b872dd60e01b90608401611a77565b50505050565b6001600160a01b038216600090815260098201602052604081205463ffffffff1615611b3f575060006109c2565b50503b151590565b6000611b9c826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b0316611c1e9092919063ffffffff16565b8051909150156112075780806020019051810190611bba9190611fc5565b6112075760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b60648201526084015b60405180910390fd5b6060611c2d8484600085611c35565b949350505050565b606082471015611c965760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b6064820152608401611c15565b6001600160a01b0385163b611ced5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606401611c15565b600080866001600160a01b03168587604051611d099190612013565b60006040518083038185875af1925050503d8060008114611d46576040519150601f19603f3d011682016040523d82523d6000602084013e611d4b565b606091505b5091509150611d5b828286611d66565b979650505050505050565b60608315611d75575081611018565b825115611d855782518084602001fd5b8160405162461bcd60e51b8152600401611c15919061202f565b6001600160a01b0381168114611db457600080fd5b50565b600060208284031215611dc957600080fd5b813561101881611d9f565b60008060008060808587031215611dea57600080fd5b843593506020850135611dfc81611d9f565b92506040850135611e0c81611d9f565b91506060850135611e1c81611d9f565b939692955090935050565b60008060408385031215611e3a57600080fd5b8235611e4581611d9f565b91506020830135611e5581611d9f565b809150509250929050565b600080600060608486031215611e7557600080fd5b833592506020840135611e8781611d9f565b91506040840135611e9781611d9f565b809150509250925092565b60008060408385031215611eb557600080fd5b823591506020830135611e5581611d9f565b600060208284031215611ed957600080fd5b5035919050565b600080600060608486031215611ef557600080fd5b8335611f0081611d9f565b92506020840135611e8781611d9f565b634e487b7160e01b600052602160045260246000fd5b634e487b7160e01b600052601160045260246000fd5b600082821015611f4e57611f4e611f26565b500390565b6000816000190483118215151615611f6d57611f6d611f26565b500290565b600082611f8f57634e487b7160e01b600052601260045260246000fd5b500490565b600060208284031215611fa657600080fd5b5051919050565b60008219821115611fc057611fc0611f26565b500190565b600060208284031215611fd757600080fd5b8151801515811461101857600080fd5b60005b83811015612002578181015183820152602001611fea565b83811115611b0b5750506000910152565b60008251612025818460208701611fe7565b9190910192915050565b602081526000825180602084015261204e816040850160208701611fe7565b601f01601f1916919091016040019291505056fea2646970667358221220a54756761a4c3b8e429bf9007f2e24fe44e2614f3825069c54f40fb17a90b5f564736f6c634300080f0033",
  "devdoc": {
    "events": {
      "LiquidityFeeNumeratorUpdated(uint256,address)": {
        "params": {
          "caller": "- The account that called the function",
          "liquidityFeeNumerator": "- The LIQUIDITY_FEE_NUMERATOR new value"
        }
      },
      "MaxRoutersPerTransferUpdated(uint256,address)": {
        "params": {
          "caller": "- The account that called the function",
          "maxRoutersPerTransfer": "- The maxRoutersPerTransfer new value"
        }
      },
      "RouterAdded(address,address)": {
        "params": {
          "caller": "- The account that called the function",
          "router": "- The address of the added router"
        }
      },
      "RouterApprovedForPortal(address,address)": {
        "params": {
          "caller": "- The account that called the function",
          "router": "- The address of the approved router"
        }
      },
      "RouterLiquidityAdded(address,address,bytes32,uint256,address)": {
        "params": {
          "amount": "- The amount of liquidity added",
          "caller": "- The account that called the function",
          "key": "- The hash of the canonical id and domain",
          "local": "- The address of the token added (all liquidity held in local asset)",
          "router": "- The address of the router the funds were credited to"
        }
      },
      "RouterLiquidityRemoved(address,address,address,bytes32,uint256,address)": {
        "params": {
          "amount": "- The amount of liquidity withdrawn",
          "caller": "- The account that called the function",
          "local": "- The address of the token withdrawn",
          "router": "- The router you are removing liquidity from",
          "to": "- The address the funds were withdrawn to"
        }
      },
      "RouterOwnerAccepted(address,address,address)": {
        "params": {
          "newOwner": "- The address of the new owner of the router",
          "prevOwner": "- The address of the previous owner of the router",
          "router": "- The address of the added router"
        }
      },
      "RouterOwnerProposed(address,address,address)": {
        "params": {
          "newProposed": "- The address of the new proposed",
          "prevProposed": "- The address of the previous proposed",
          "router": "- The address of the added router"
        }
      },
      "RouterRecipientSet(address,address,address)": {
        "params": {
          "newRecipient": "- The address of the new recipient of the router",
          "prevRecipient": "- The address of the previous recipient of the router",
          "router": "- The address of the added router"
        }
      },
      "RouterRemoved(address,address)": {
        "params": {
          "caller": "- The account that called the function",
          "router": "- The address of the removed router"
        }
      },
      "RouterUnapprovedForPortal(address,address)": {
        "params": {
          "caller": "- The account that called the function",
          "router": "- The address of the disapproved router"
        }
      }
    },
    "kind": "dev",
    "methods": {
      "acceptProposedRouterOwner(address)": {
        "params": {
          "router": "Router address to set recipient"
        }
      },
      "addRouterLiquidity(uint256,address)": {
        "details": "The liquidity will be held in the local asset, which is the representation if you are *not* on the canonical domain, and the canonical asset otherwise.",
        "params": {
          "_amount": "- The amount of liquidity to add for the router",
          "_local": "- The address of the asset you're adding liquidity for. If adding liquidity of the native asset, routers may use `address(0)` or the wrapped asset"
        }
      },
      "addRouterLiquidityFor(uint256,address,address)": {
        "details": "The liquidity will be held in the local asset, which is the representation if you are *not* on the canonical domain, and the canonical asset otherwise.",
        "params": {
          "_amount": "- The amount of liquidity to add for the router",
          "_local": "- The address of the asset you're adding liquidity for. If adding liquidity of the native asset, routers may use `address(0)` or the wrapped asset",
          "_router": "The router you are adding liquidity on behalf of"
        }
      },
      "approveRouterForPortal(address)": {
        "params": {
          "_router": "- The router address to approve"
        }
      },
      "getProposedRouterOwner(address)": {
        "details": "All routers must wait for the delay timeout before accepting a new owner",
        "params": {
          "_router": "The relevant router address"
        }
      },
      "getProposedRouterOwnerTimestamp(address)": {
        "details": "All routers must wait for the delay timeout before accepting a new owner",
        "params": {
          "_router": "The relevant router address"
        }
      },
      "getRouterApproval(address)": {
        "params": {
          "_router": "The relevant router address"
        }
      },
      "getRouterApprovalForPortal(address)": {
        "params": {
          "_router": "The relevant router address"
        }
      },
      "getRouterOwner(address)": {
        "details": "Uses logic function here to handle the case where router owner is not set. Other getters within this interface use explicitly the stored value",
        "params": {
          "_router": "The relevant router address"
        }
      },
      "getRouterRecipient(address)": {
        "details": "The recipient (if set) receives all funds when router liquidity is removed",
        "params": {
          "_router": "The relevant router address"
        }
      },
      "proposeRouterOwner(address,address)": {
        "params": {
          "proposed": "Proposed owner Address to set to router",
          "router": "Router address to set recipient"
        }
      },
      "removeRouter(address)": {
        "params": {
          "router": "Router address to remove"
        }
      },
      "removeRouterLiquidity(uint256,address,address)": {
        "params": {
          "_amount": "- The amount of liquidity to remove for the router",
          "_local": "- The address of the asset you're removing liquidity from. If removing liquidity of the native asset, routers may use `address(0)` or the wrapped asset",
          "_to": "The address that will receive the liquidity being removed if no router recipient exists."
        }
      },
      "removeRouterLiquidityFor(uint256,address,address,address)": {
        "params": {
          "_amount": "- The amount of liquidity to remove for the router",
          "_local": "- The address of the asset you're removing liquidity from. If removing liquidity of the native asset, routers may use `address(0)` or the wrapped asset",
          "_router": "The address of the router",
          "_to": "The address that will receive the liquidity being removed"
        }
      },
      "setLiquidityFeeNumerator(uint256)": {
        "details": "Admin can set LIQUIDITY_FEE_NUMERATOR variable, Liquidity fee should be less than 5%",
        "params": {
          "_numerator": "new LIQUIDITY_FEE_NUMERATOR"
        }
      },
      "setMaxRoutersPerTransfer(uint256)": {
        "params": {
          "_newMaxRouters": "The new max amount of routers"
        }
      },
      "setRouterRecipient(address,address)": {
        "details": "Router should only be able to set this once otherwise if router key compromised, no problem is solved since attacker could just update recipient",
        "params": {
          "recipient": "Recipient Address to set to router",
          "router": "Router address to set recipient"
        }
      },
      "setupRouter(address,address,address)": {
        "params": {
          "owner": "Initial Owner of router",
          "recipient": "Initial Recipient of router",
          "router": "Router address to setup"
        }
      },
      "unapproveRouterForPortal(address)": {
        "params": {
          "_router": "- The router address to remove approval"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "events": {
      "LiquidityFeeNumeratorUpdated(uint256,address)": {
        "notice": "Emitted when the LIQUIDITY_FEE_NUMERATOR variable is updated"
      },
      "MaxRoutersPerTransferUpdated(uint256,address)": {
        "notice": "Emitted when the maxRoutersPerTransfer variable is updated"
      },
      "RouterAdded(address,address)": {
        "notice": "Emitted when a new router is added"
      },
      "RouterApprovedForPortal(address,address)": {
        "notice": "Emitted when a router is approved for Portal"
      },
      "RouterLiquidityAdded(address,address,bytes32,uint256,address)": {
        "notice": "Emitted when a router adds liquidity to the contract"
      },
      "RouterLiquidityRemoved(address,address,address,bytes32,uint256,address)": {
        "notice": "Emitted when a router withdraws liquidity from the contract"
      },
      "RouterOwnerAccepted(address,address,address)": {
        "notice": "Emitted when the owner of router is accepted"
      },
      "RouterOwnerProposed(address,address,address)": {
        "notice": "Emitted when the owner of router is proposed"
      },
      "RouterRecipientSet(address,address,address)": {
        "notice": "Emitted when the recipient of router is updated"
      },
      "RouterRemoved(address,address)": {
        "notice": "Emitted when an existing router is removed"
      },
      "RouterUnapprovedForPortal(address,address)": {
        "notice": "Emitted when a router is disapproved for Portal"
      }
    },
    "kind": "user",
    "methods": {
      "acceptProposedRouterOwner(address)": {
        "notice": "New router owner must accept role, or previous if proposed is 0x0"
      },
      "addRouterLiquidity(uint256,address)": {
        "notice": "This is used by any router to increase their available liquidity for a given asset."
      },
      "addRouterLiquidityFor(uint256,address,address)": {
        "notice": "This is used by anyone to increase a router's available liquidity for a given asset."
      },
      "approveRouterForPortal(address)": {
        "notice": "Allow router to use Portals"
      },
      "getProposedRouterOwner(address)": {
        "notice": "Returns the currently proposed router owner"
      },
      "getProposedRouterOwnerTimestamp(address)": {
        "notice": "Returns the currently proposed router owner timestamp"
      },
      "getRouterApproval(address)": {
        "notice": "Returns the approved router for the given router address"
      },
      "getRouterApprovalForPortal(address)": {
        "notice": "Returns whether the router is approved for portals or not"
      },
      "getRouterOwner(address)": {
        "notice": "Returns the router owner if it is set, or the router itself if not"
      },
      "getRouterRecipient(address)": {
        "notice": "Returns the recipient for the specified router"
      },
      "proposeRouterOwner(address,address)": {
        "notice": "Current owner or router may propose a new router owner"
      },
      "removeRouter(address)": {
        "notice": "Used to remove routers that can transact crosschain"
      },
      "removeRouterLiquidity(uint256,address,address)": {
        "notice": "This is used by any router to decrease their available liquidity for a given asset."
      },
      "removeRouterLiquidityFor(uint256,address,address,address)": {
        "notice": "This is used by any router owner to decrease their available liquidity for a given asset."
      },
      "setLiquidityFeeNumerator(uint256)": {
        "notice": "Sets the LIQUIDITY_FEE_NUMERATOR"
      },
      "setMaxRoutersPerTransfer(uint256)": {
        "notice": "Used to set the max amount of routers a payment can be routed through"
      },
      "setRouterRecipient(address,address)": {
        "notice": "Sets the designated recipient for a router"
      },
      "setupRouter(address,address,address)": {
        "notice": "Used to set router initial properties"
      },
      "unapproveRouterForPortal(address)": {
        "notice": "Remove router access to use Portals"
      }
    },
    "notice": "This contract is designed to manage router access, meaning it maintains the router recipients, owners, and the router whitelist itself. As a router, there are three important permissions: `router` - this is the address that will sign bids sent to the sequencer `routerRecipient` - this is the address that receives funds when liquidity is withdrawn `routerOwner` - this is the address permitted to update recipients and propose new owners In cases where the owner is not set, the caller should be the `router` itself. In cases where the `routerRecipient` is not set, the funds can be removed to anywhere. When setting a new `routerOwner`, the current owner (or router) must create a proposal, which can be accepted by the proposed owner after the delay period. If the proposed owner is the empty address, then it must be accepted by the current owner.",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 13868,
        "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
        "label": "s",
        "offset": 0,
        "slot": "0",
        "type": "t_struct(AppStorage)28097_storage"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_address)dyn_storage": {
        "base": "t_address",
        "encoding": "dynamic_array",
        "label": "address[]",
        "numberOfBytes": "32"
      },
      "t_array(t_contract(IERC20)11540)dyn_storage": {
        "base": "t_contract(IERC20)11540",
        "encoding": "dynamic_array",
        "label": "contract IERC20[]",
        "numberOfBytes": "32"
      },
      "t_array(t_uint256)dyn_storage": {
        "base": "t_uint256",
        "encoding": "dynamic_array",
        "label": "uint256[]",
        "numberOfBytes": "32"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_contract(IConnectorManager)45249": {
        "encoding": "inplace",
        "label": "contract IConnectorManager",
        "numberOfBytes": "20"
      },
      "t_contract(IERC20)11540": {
        "encoding": "inplace",
        "label": "contract IERC20",
        "numberOfBytes": "20"
      },
      "t_contract(IStableSwap)25766": {
        "encoding": "inplace",
        "label": "contract IStableSwap",
        "numberOfBytes": "20"
      },
      "t_contract(LPToken)22553": {
        "encoding": "inplace",
        "label": "contract LPToken",
        "numberOfBytes": "20"
      },
      "t_enum(DestinationTransferStatus)27873": {
        "encoding": "inplace",
        "label": "enum DestinationTransferStatus",
        "numberOfBytes": "1"
      },
      "t_enum(Role)27868": {
        "encoding": "inplace",
        "label": "enum Role",
        "numberOfBytes": "1"
      },
      "t_mapping(t_address,t_address)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_address,t_enum(Role)27868)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => enum Role)",
        "numberOfBytes": "32",
        "value": "t_enum(Role)27868"
      },
      "t_mapping(t_address,t_mapping(t_address,t_uint256))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => uint256))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_uint256)"
      },
      "t_mapping(t_address,t_struct(TokenId)27878_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct TokenId)",
        "numberOfBytes": "32",
        "value": "t_struct(TokenId)27878_storage"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_address,t_uint8)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint8)",
        "numberOfBytes": "32",
        "value": "t_uint8"
      },
      "t_mapping(t_bytes32,t_address)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_mapping(t_bytes32,t_array(t_address)dyn_storage)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => address[])",
        "numberOfBytes": "32",
        "value": "t_array(t_address)dyn_storage"
      },
      "t_mapping(t_bytes32,t_bool)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_bytes32,t_contract(IStableSwap)25766)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => contract IStableSwap)",
        "numberOfBytes": "32",
        "value": "t_contract(IStableSwap)25766"
      },
      "t_mapping(t_bytes32,t_enum(DestinationTransferStatus)27873)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => enum DestinationTransferStatus)",
        "numberOfBytes": "32",
        "value": "t_enum(DestinationTransferStatus)27873"
      },
      "t_mapping(t_bytes32,t_mapping(t_address,t_uint8))": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => mapping(address => uint8))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_uint8)"
      },
      "t_mapping(t_bytes32,t_struct(Swap)29292_storage)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => struct SwapUtils.Swap)",
        "numberOfBytes": "32",
        "value": "t_struct(Swap)29292_storage"
      },
      "t_mapping(t_bytes32,t_uint256)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_uint32,t_bytes32)": {
        "encoding": "mapping",
        "key": "t_uint32",
        "label": "mapping(uint32 => bytes32)",
        "numberOfBytes": "32",
        "value": "t_bytes32"
      },
      "t_struct(AppStorage)28097_storage": {
        "encoding": "inplace",
        "label": "struct AppStorage",
        "members": [
          {
            "astId": 27946,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "initialized",
            "offset": 0,
            "slot": "0",
            "type": "t_bool"
          },
          {
            "astId": 27948,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "LIQUIDITY_FEE_NUMERATOR",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 27951,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "relayerFeeVault",
            "offset": 0,
            "slot": "2",
            "type": "t_address"
          },
          {
            "astId": 27954,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "nonce",
            "offset": 0,
            "slot": "3",
            "type": "t_uint256"
          },
          {
            "astId": 27957,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "domain",
            "offset": 0,
            "slot": "4",
            "type": "t_uint32"
          },
          {
            "astId": 27963,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "adoptedToLocalPools",
            "offset": 0,
            "slot": "5",
            "type": "t_mapping(t_bytes32,t_contract(IStableSwap)25766)"
          },
          {
            "astId": 27968,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "approvedAssets",
            "offset": 0,
            "slot": "6",
            "type": "t_mapping(t_bytes32,t_bool)"
          },
          {
            "astId": 27973,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "caps",
            "offset": 0,
            "slot": "7",
            "type": "t_mapping(t_bytes32,t_uint256)"
          },
          {
            "astId": 27979,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "adoptedToCanonical",
            "offset": 0,
            "slot": "8",
            "type": "t_mapping(t_address,t_struct(TokenId)27878_storage)"
          },
          {
            "astId": 27985,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "representationToCanonical",
            "offset": 0,
            "slot": "9",
            "type": "t_mapping(t_address,t_struct(TokenId)27878_storage)"
          },
          {
            "astId": 27990,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "canonicalToAdopted",
            "offset": 0,
            "slot": "10",
            "type": "t_mapping(t_bytes32,t_address)"
          },
          {
            "astId": 27995,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "canonicalToRepresentation",
            "offset": 0,
            "slot": "11",
            "type": "t_mapping(t_bytes32,t_address)"
          },
          {
            "astId": 28001,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "transferStatus",
            "offset": 0,
            "slot": "12",
            "type": "t_mapping(t_bytes32,t_enum(DestinationTransferStatus)27873)"
          },
          {
            "astId": 28007,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "routedTransfers",
            "offset": 0,
            "slot": "13",
            "type": "t_mapping(t_bytes32,t_array(t_address)dyn_storage)"
          },
          {
            "astId": 28014,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "routerBalances",
            "offset": 0,
            "slot": "14",
            "type": "t_mapping(t_address,t_mapping(t_address,t_uint256))"
          },
          {
            "astId": 28019,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "approvedRelayers",
            "offset": 0,
            "slot": "15",
            "type": "t_mapping(t_address,t_bool)"
          },
          {
            "astId": 28022,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "maxRoutersPerTransfer",
            "offset": 0,
            "slot": "16",
            "type": "t_uint256"
          },
          {
            "astId": 28027,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "slippage",
            "offset": 0,
            "slot": "17",
            "type": "t_mapping(t_bytes32,t_uint256)"
          },
          {
            "astId": 28032,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "remotes",
            "offset": 0,
            "slot": "18",
            "type": "t_mapping(t_uint32,t_bytes32)"
          },
          {
            "astId": 28034,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "_proposed",
            "offset": 0,
            "slot": "19",
            "type": "t_address"
          },
          {
            "astId": 28036,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "_proposedOwnershipTimestamp",
            "offset": 0,
            "slot": "20",
            "type": "t_uint256"
          },
          {
            "astId": 28038,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "_routerWhitelistRemoved",
            "offset": 0,
            "slot": "21",
            "type": "t_bool"
          },
          {
            "astId": 28040,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "_routerWhitelistTimestamp",
            "offset": 0,
            "slot": "22",
            "type": "t_uint256"
          },
          {
            "astId": 28042,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "_assetWhitelistRemoved",
            "offset": 0,
            "slot": "23",
            "type": "t_bool"
          },
          {
            "astId": 28044,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "_assetWhitelistTimestamp",
            "offset": 0,
            "slot": "24",
            "type": "t_uint256"
          },
          {
            "astId": 28050,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "roles",
            "offset": 0,
            "slot": "25",
            "type": "t_mapping(t_address,t_enum(Role)27868)"
          },
          {
            "astId": 28053,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "routerPermissionInfo",
            "offset": 0,
            "slot": "26",
            "type": "t_struct(RouterPermissionsManagerInfo)27944_storage"
          },
          {
            "astId": 28055,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "_status",
            "offset": 0,
            "slot": "32",
            "type": "t_uint256"
          },
          {
            "astId": 28061,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "swapStorages",
            "offset": 0,
            "slot": "33",
            "type": "t_mapping(t_bytes32,t_struct(Swap)29292_storage)"
          },
          {
            "astId": 28068,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "tokenIndexes",
            "offset": 0,
            "slot": "34",
            "type": "t_mapping(t_bytes32,t_mapping(t_address,t_uint8))"
          },
          {
            "astId": 28071,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "_paused",
            "offset": 0,
            "slot": "35",
            "type": "t_bool"
          },
          {
            "astId": 28074,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "aavePool",
            "offset": 1,
            "slot": "35",
            "type": "t_address"
          },
          {
            "astId": 28077,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "aavePortalFeeNumerator",
            "offset": 0,
            "slot": "36",
            "type": "t_uint256"
          },
          {
            "astId": 28082,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "portalDebt",
            "offset": 0,
            "slot": "37",
            "type": "t_mapping(t_bytes32,t_uint256)"
          },
          {
            "astId": 28087,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "portalFeeDebt",
            "offset": 0,
            "slot": "38",
            "type": "t_mapping(t_bytes32,t_uint256)"
          },
          {
            "astId": 28092,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "approvedSequencers",
            "offset": 0,
            "slot": "39",
            "type": "t_mapping(t_address,t_bool)"
          },
          {
            "astId": 28096,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "xAppConnectionManager",
            "offset": 0,
            "slot": "40",
            "type": "t_contract(IConnectorManager)45249"
          }
        ],
        "numberOfBytes": "1312"
      },
      "t_struct(RouterPermissionsManagerInfo)27944_storage": {
        "encoding": "inplace",
        "label": "struct RouterPermissionsManagerInfo",
        "members": [
          {
            "astId": 27923,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "approvedRouters",
            "offset": 0,
            "slot": "0",
            "type": "t_mapping(t_address,t_bool)"
          },
          {
            "astId": 27927,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "approvedForPortalRouters",
            "offset": 0,
            "slot": "1",
            "type": "t_mapping(t_address,t_bool)"
          },
          {
            "astId": 27931,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "routerRecipients",
            "offset": 0,
            "slot": "2",
            "type": "t_mapping(t_address,t_address)"
          },
          {
            "astId": 27935,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "routerOwners",
            "offset": 0,
            "slot": "3",
            "type": "t_mapping(t_address,t_address)"
          },
          {
            "astId": 27939,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "proposedRouterOwners",
            "offset": 0,
            "slot": "4",
            "type": "t_mapping(t_address,t_address)"
          },
          {
            "astId": 27943,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "proposedRouterTimestamp",
            "offset": 0,
            "slot": "5",
            "type": "t_mapping(t_address,t_uint256)"
          }
        ],
        "numberOfBytes": "192"
      },
      "t_struct(Swap)29292_storage": {
        "encoding": "inplace",
        "label": "struct SwapUtils.Swap",
        "members": [
          {
            "astId": 29263,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "key",
            "offset": 0,
            "slot": "0",
            "type": "t_bytes32"
          },
          {
            "astId": 29265,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "initialA",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 29267,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "futureA",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          },
          {
            "astId": 29269,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "initialATime",
            "offset": 0,
            "slot": "3",
            "type": "t_uint256"
          },
          {
            "astId": 29271,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "futureATime",
            "offset": 0,
            "slot": "4",
            "type": "t_uint256"
          },
          {
            "astId": 29273,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "swapFee",
            "offset": 0,
            "slot": "5",
            "type": "t_uint256"
          },
          {
            "astId": 29275,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "adminFee",
            "offset": 0,
            "slot": "6",
            "type": "t_uint256"
          },
          {
            "astId": 29278,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "lpToken",
            "offset": 0,
            "slot": "7",
            "type": "t_contract(LPToken)22553"
          },
          {
            "astId": 29282,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "pooledTokens",
            "offset": 0,
            "slot": "8",
            "type": "t_array(t_contract(IERC20)11540)dyn_storage"
          },
          {
            "astId": 29285,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "tokenPrecisionMultipliers",
            "offset": 0,
            "slot": "9",
            "type": "t_array(t_uint256)dyn_storage"
          },
          {
            "astId": 29288,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "balances",
            "offset": 0,
            "slot": "10",
            "type": "t_array(t_uint256)dyn_storage"
          },
          {
            "astId": 29291,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "adminFees",
            "offset": 0,
            "slot": "11",
            "type": "t_array(t_uint256)dyn_storage"
          }
        ],
        "numberOfBytes": "384"
      },
      "t_struct(TokenId)27878_storage": {
        "encoding": "inplace",
        "label": "struct TokenId",
        "members": [
          {
            "astId": 27875,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "domain",
            "offset": 0,
            "slot": "0",
            "type": "t_uint32"
          },
          {
            "astId": 27877,
            "contract": "contracts/core/connext/facets/RoutersFacet.sol:RoutersFacet",
            "label": "id",
            "offset": 0,
            "slot": "1",
            "type": "t_bytes32"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint32": {
        "encoding": "inplace",
        "label": "uint32",
        "numberOfBytes": "4"
      },
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      }
    }
  }
}