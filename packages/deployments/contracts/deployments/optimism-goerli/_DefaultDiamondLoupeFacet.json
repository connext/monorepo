{
  "address": "0x9711b523083fAa26F09781d7FbB513ad93EF5801",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "_functionSelector",
          "type": "bytes4"
        }
      ],
      "name": "facetAddress",
      "outputs": [
        {
          "internalType": "address",
          "name": "facetAddress_",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "facetAddresses",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "facetAddresses_",
          "type": "address[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_facet",
          "type": "address"
        }
      ],
      "name": "facetFunctionSelectors",
      "outputs": [
        {
          "internalType": "bytes4[]",
          "name": "facetFunctionSelectors_",
          "type": "bytes4[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "facets",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "facetAddress",
              "type": "address"
            },
            {
              "internalType": "bytes4[]",
              "name": "functionSelectors",
              "type": "bytes4[]"
            }
          ],
          "internalType": "struct IDiamondLoupe.Facet[]",
          "name": "facets_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "_interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xe4b353c3aee17f2943067ca12fb2e513231445fc8481f22eaf51daf4dbe0dd57",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0x54BAA998771639628ffC0206c3b916c466b79c89",
    "contractAddress": null,
    "transactionIndex": 0,
    "gasUsed": "400696",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x2114128da289fff1a3dc7da771fb8a2707194d96e80b449a518232b0559b6c40",
    "transactionHash": "0xe4b353c3aee17f2943067ca12fb2e513231445fc8481f22eaf51daf4dbe0dd57",
    "logs": [],
    "blockNumber": 2822221,
    "cumulativeGasUsed": "400696",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 4,
  "solcInputHash": "546a289799c909df9824285352e6a82a",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_functionSelector\",\"type\":\"bytes4\"}],\"name\":\"facetAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"facetAddress_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"facetAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"facetAddresses_\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_facet\",\"type\":\"address\"}],\"name\":\"facetFunctionSelectors\",\"outputs\":[{\"internalType\":\"bytes4[]\",\"name\":\"facetFunctionSelectors_\",\"type\":\"bytes4[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"facets\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"facetAddress\",\"type\":\"address\"},{\"internalType\":\"bytes4[]\",\"name\":\"functionSelectors\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct IDiamondLoupe.Facet[]\",\"name\":\"facets_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"facetAddress(bytes4)\":{\"details\":\"If facet is not found return address(0).\",\"params\":{\"_functionSelector\":\"The function selector.\"},\"returns\":{\"facetAddress_\":\"The facet address.\"}},\"facetAddresses()\":{\"returns\":{\"facetAddresses_\":\"facetAddresses_\"}},\"facetFunctionSelectors(address)\":{\"params\":{\"_facet\":\"The facet address.\"},\"returns\":{\"facetFunctionSelectors_\":\"facetFunctionSelectors_\"}},\"facets()\":{\"returns\":{\"facets_\":\"Facet\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"facetAddress(bytes4)\":{\"notice\":\"Gets the facet that supports the given selector.\"},\"facetAddresses()\":{\"notice\":\"Get all the facet addresses used by a diamond.\"},\"facetFunctionSelectors(address)\":{\"notice\":\"Gets all the function selectors provided by a facet.\"},\"facets()\":{\"notice\":\"Gets all facets and their selectors.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/core/connext/facets/DiamondLoupeFacet.sol\":\"DiamondLoupeFacet\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/core/connext/facets/DiamondLoupeFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\nimport {LibDiamond} from \\\"../libraries/LibDiamond.sol\\\";\\nimport {IDiamondLoupe} from \\\"../interfaces/IDiamondLoupe.sol\\\";\\nimport {IERC165} from \\\"../interfaces/IERC165.sol\\\";\\n\\n// The functions in DiamondLoupeFacet MUST be added to a diamond.\\n// The EIP-2535 Diamond standard requires these functions.\\n\\ncontract DiamondLoupeFacet is IDiamondLoupe, IERC165 {\\n  // Diamond Loupe Functions\\n  ////////////////////////////////////////////////////////////////////\\n  /// These functions are expected to be called frequently by tools.\\n  //\\n  // struct Facet {\\n  //     address facetAddress;\\n  //     bytes4[] functionSelectors;\\n  // }\\n\\n  /// @notice Gets all facets and their selectors.\\n  /// @return facets_ Facet\\n  function facets() external view override returns (Facet[] memory facets_) {\\n    LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n    uint256 numFacets = ds.facetAddresses.length;\\n    facets_ = new Facet[](numFacets);\\n    for (uint256 i; i < numFacets; ) {\\n      address facetAddress_ = ds.facetAddresses[i];\\n      facets_[i].facetAddress = facetAddress_;\\n      facets_[i].functionSelectors = ds.facetFunctionSelectors[facetAddress_].functionSelectors;\\n\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n  }\\n\\n  /// @notice Gets all the function selectors provided by a facet.\\n  /// @param _facet The facet address.\\n  /// @return facetFunctionSelectors_\\n  function facetFunctionSelectors(address _facet)\\n    external\\n    view\\n    override\\n    returns (bytes4[] memory facetFunctionSelectors_)\\n  {\\n    LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n    facetFunctionSelectors_ = ds.facetFunctionSelectors[_facet].functionSelectors;\\n  }\\n\\n  /// @notice Get all the facet addresses used by a diamond.\\n  /// @return facetAddresses_\\n  function facetAddresses() external view override returns (address[] memory facetAddresses_) {\\n    LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n    facetAddresses_ = ds.facetAddresses;\\n  }\\n\\n  /// @notice Gets the facet that supports the given selector.\\n  /// @dev If facet is not found return address(0).\\n  /// @param _functionSelector The function selector.\\n  /// @return facetAddress_ The facet address.\\n  function facetAddress(bytes4 _functionSelector) external view override returns (address facetAddress_) {\\n    LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n    facetAddress_ = ds.selectorToFacetAndPosition[_functionSelector].facetAddress;\\n  }\\n\\n  // This implements ERC-165.\\n  function supportsInterface(bytes4 _interfaceId) external view override returns (bool) {\\n    LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n    return ds.supportedInterfaces[_interfaceId];\\n  }\\n}\\n\",\"keccak256\":\"0xd94974a685e96dfffcd6c1cb5775e3f95c821024ecd7028eb1b2171b021facb9\",\"license\":\"MIT\"},\"contracts/core/connext/interfaces/IDiamondCut.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\ninterface IDiamondCut {\\n  enum FacetCutAction {\\n    Add,\\n    Replace,\\n    Remove\\n  }\\n  // Add=0, Replace=1, Remove=2\\n\\n  struct FacetCut {\\n    address facetAddress;\\n    FacetCutAction action;\\n    bytes4[] functionSelectors;\\n  }\\n\\n  /// @notice Propose to add/replace/remove any number of functions and optionally execute\\n  ///         a function with delegatecall\\n  /// @param _diamondCut Contains the facet addresses and function selectors\\n  /// @param _init The address of the contract or facet to execute _calldata\\n  /// @param _calldata A function call, including function selector and arguments\\n  ///                  _calldata is executed with delegatecall on _init\\n  function proposeDiamondCut(\\n    FacetCut[] calldata _diamondCut,\\n    address _init,\\n    bytes calldata _calldata\\n  ) external;\\n\\n  event DiamondCutProposed(FacetCut[] _diamondCut, address _init, bytes _calldata, uint256 deadline);\\n\\n  /// @notice Add/replace/remove any number of functions and optionally execute\\n  ///         a function with delegatecall\\n  /// @param _diamondCut Contains the facet addresses and function selectors\\n  /// @param _init The address of the contract or facet to execute _calldata\\n  /// @param _calldata A function call, including function selector and arguments\\n  ///                  _calldata is executed with delegatecall on _init\\n  function diamondCut(\\n    FacetCut[] calldata _diamondCut,\\n    address _init,\\n    bytes calldata _calldata\\n  ) external;\\n\\n  event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n  /// @notice Propose to add/replace/remove any number of functions and optionally execute\\n  ///         a function with delegatecall\\n  /// @param _diamondCut Contains the facet addresses and function selectors\\n  /// @param _init The address of the contract or facet to execute _calldata\\n  /// @param _calldata A function call, including function selector and arguments\\n  ///                  _calldata is executed with delegatecall on _init\\n  function rescindDiamondCut(\\n    FacetCut[] calldata _diamondCut,\\n    address _init,\\n    bytes calldata _calldata\\n  ) external;\\n\\n  /**\\n   * @notice Returns the acceptance time for a given proposal\\n   * @param _diamondCut Contains the facet addresses and function selectors\\n   * @param _init The address of the contract or facet to execute _calldata\\n   * @param _calldata A function call, including function selector and arguments _calldata is\\n   * executed with delegatecall on _init\\n   */\\n  function getAcceptanceTime(\\n    FacetCut[] calldata _diamondCut,\\n    address _init,\\n    bytes calldata _calldata\\n  ) external returns (uint256);\\n\\n  event DiamondCutRescinded(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\",\"keccak256\":\"0x4f0bf252cb5541d7ffd04fc49abdc7d2f2c838ba65f108201f787851c7b238fb\",\"license\":\"MIT\"},\"contracts/core/connext/interfaces/IDiamondLoupe.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\n// A loupe is a small magnifying glass used to look at diamonds.\\n// These functions look at diamonds\\ninterface IDiamondLoupe {\\n  /// These functions are expected to be called frequently\\n  /// by tools.\\n\\n  struct Facet {\\n    address facetAddress;\\n    bytes4[] functionSelectors;\\n  }\\n\\n  /// @notice Gets all facet addresses and their four byte function selectors.\\n  /// @return facets_ Facet\\n  function facets() external view returns (Facet[] memory facets_);\\n\\n  /// @notice Gets all the function selectors supported by a specific facet.\\n  /// @param _facet The facet address.\\n  /// @return facetFunctionSelectors_\\n  function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\\n\\n  /// @notice Get all the facet addresses used by a diamond.\\n  /// @return facetAddresses_\\n  function facetAddresses() external view returns (address[] memory facetAddresses_);\\n\\n  /// @notice Gets the facet that supports the given selector.\\n  /// @dev If facet is not found return address(0).\\n  /// @param _functionSelector The function selector.\\n  /// @return facetAddress_ The facet address.\\n  function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\\n}\\n\",\"keccak256\":\"0xc408c13dc42d9526b1f292bad3f3915efa15c2133f509d90a45422b5f6cf829c\",\"license\":\"MIT\"},\"contracts/core/connext/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ninterface IERC165 {\\n  /// @notice Query if a contract implements an interface\\n  /// @param interfaceId The interface identifier, as specified in ERC-165\\n  /// @dev Interface identification is specified in ERC-165. This function\\n  ///  uses less than 30,000 gas.\\n  /// @return `true` if the contract implements `interfaceID` and\\n  ///  `interfaceID` is not 0xffffffff, `false` otherwise\\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xc92e38025a8eff9eafa17be136dd134e8b95060b7a258f840713d2a7d4b7fa85\",\"license\":\"MIT\"},\"contracts/core/connext/libraries/LibDiamond.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\nimport {IDiamondCut} from \\\"../interfaces/IDiamondCut.sol\\\";\\n\\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\\n// The loupe functions are required by the EIP2535 Diamonds standard\\n\\nlibrary LibDiamond {\\n  bytes32 constant DIAMOND_STORAGE_POSITION = bytes32(uint256(keccak256(\\\"diamond.standard.diamond.storage\\\")) - 1);\\n\\n  struct FacetAddressAndPosition {\\n    address facetAddress;\\n    uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\\n  }\\n\\n  struct FacetFunctionSelectors {\\n    bytes4[] functionSelectors;\\n    uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\\n  }\\n\\n  struct DiamondStorage {\\n    // maps function selector to the facet address and\\n    // the position of the selector in the facetFunctionSelectors.selectors array\\n    mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\\n    // maps facet addresses to function selectors\\n    mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\\n    // facet addresses\\n    address[] facetAddresses;\\n    // Used to query if a contract implements an interface.\\n    // Used to implement ERC-165.\\n    mapping(bytes4 => bool) supportedInterfaces;\\n    // owner of the contract\\n    address contractOwner;\\n    // hash of proposed facets => acceptance time\\n    mapping(bytes32 => uint256) acceptanceTimes;\\n    // acceptance delay for upgrading facets\\n    uint256 acceptanceDelay;\\n  }\\n\\n  function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n    bytes32 position = DIAMOND_STORAGE_POSITION;\\n    assembly {\\n      ds.slot := position\\n    }\\n  }\\n\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n  function setContractOwner(address _newOwner) internal {\\n    DiamondStorage storage ds = diamondStorage();\\n    emit OwnershipTransferred(ds.contractOwner, _newOwner);\\n    ds.contractOwner = _newOwner;\\n  }\\n\\n  function contractOwner() internal view returns (address contractOwner_) {\\n    contractOwner_ = diamondStorage().contractOwner;\\n  }\\n\\n  function acceptanceDelay() internal view returns (uint256) {\\n    return diamondStorage().acceptanceDelay;\\n  }\\n\\n  function acceptanceTime(bytes32 _key) internal view returns (uint256) {\\n    return diamondStorage().acceptanceTimes[_key];\\n  }\\n\\n  function enforceIsContractOwner() internal view {\\n    require(msg.sender == diamondStorage().contractOwner, \\\"LibDiamond: !contract owner\\\");\\n  }\\n\\n  event DiamondCutProposed(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata, uint256 deadline);\\n\\n  function proposeDiamondCut(\\n    IDiamondCut.FacetCut[] memory _diamondCut,\\n    address _init,\\n    bytes memory _calldata\\n  ) internal {\\n    // NOTE: to save gas, verification that `proposeDiamondCut` and `diamondCut` are not\\n    // included is performed in `diamondCut`, where there is already a loop over facets.\\n    // In the case where these cuts are performed, admins must call `rescindDiamondCut`\\n\\n    DiamondStorage storage ds = diamondStorage();\\n    uint256 acceptance = block.timestamp + ds.acceptanceDelay;\\n    ds.acceptanceTimes[keccak256(abi.encode(_diamondCut, _init, _calldata))] = acceptance;\\n    emit DiamondCutProposed(_diamondCut, _init, _calldata, acceptance);\\n  }\\n\\n  event DiamondCutRescinded(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n  function rescindDiamondCut(\\n    IDiamondCut.FacetCut[] memory _diamondCut,\\n    address _init,\\n    bytes memory _calldata\\n  ) internal {\\n    // NOTE: you can always rescind a proposed facet cut as the owner, even if outside of the validity\\n    // period or befor the delay elpases\\n    delete diamondStorage().acceptanceTimes[keccak256(abi.encode(_diamondCut, _init, _calldata))];\\n    emit DiamondCutRescinded(_diamondCut, _init, _calldata);\\n  }\\n\\n  event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n  // Internal function version of diamondCut\\n  function diamondCut(\\n    IDiamondCut.FacetCut[] memory _diamondCut,\\n    address _init,\\n    bytes memory _calldata\\n  ) internal {\\n    DiamondStorage storage ds = diamondStorage();\\n    bytes32 key = keccak256(abi.encode(_diamondCut, _init, _calldata));\\n    if (ds.facetAddresses.length != 0) {\\n      uint256 time = ds.acceptanceTimes[key];\\n      require(time != 0 && time <= block.timestamp, \\\"LibDiamond: delay not elapsed\\\");\\n      // Reset the acceptance time to ensure the same set of updates cannot be replayed\\n      // without going through a proposal window\\n\\n      // NOTE: the only time this will not be set to 0 is when there are no\\n      // existing facet addresses (on initialization, or when starting after a bad upgrade,\\n      // for example).\\n      // The only relevant case is the initial case, which has no acceptance time. otherwise,\\n      // there is no way to update the facet selector mapping to call `diamondCut`.\\n      // Avoiding setting the empty value will save gas on the initial deployment.\\n      delete ds.acceptanceTimes[key];\\n    } // Otherwise, this is the first instance of deployment and it can be set automatically\\n    uint256 len = _diamondCut.length;\\n    for (uint256 facetIndex; facetIndex < len; ) {\\n      IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\\n      if (action == IDiamondCut.FacetCutAction.Add) {\\n        addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n      } else if (action == IDiamondCut.FacetCutAction.Replace) {\\n        replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n      } else if (action == IDiamondCut.FacetCutAction.Remove) {\\n        removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n      } else {\\n        revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\n      }\\n\\n      unchecked {\\n        ++facetIndex;\\n      }\\n    }\\n    emit DiamondCut(_diamondCut, _init, _calldata);\\n    initializeDiamondCut(_init, _calldata);\\n  }\\n\\n  function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n    require(_functionSelectors.length != 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n    DiamondStorage storage ds = diamondStorage();\\n    require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n    uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n    // add new facet address if it does not exist\\n    if (selectorPosition == 0) {\\n      addFacet(ds, _facetAddress);\\n    }\\n    uint256 len = _functionSelectors.length;\\n    for (uint256 selectorIndex; selectorIndex < len; ) {\\n      bytes4 selector = _functionSelectors[selectorIndex];\\n      address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n      require(oldFacetAddress == address(0), \\\"LibDiamondCut: Can't add function that already exists\\\");\\n      addFunction(ds, selector, selectorPosition, _facetAddress);\\n      selectorPosition++;\\n\\n      unchecked {\\n        ++selectorIndex;\\n      }\\n    }\\n  }\\n\\n  function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n    uint256 len = _functionSelectors.length;\\n    require(len != 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n    DiamondStorage storage ds = diamondStorage();\\n    require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n    uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n    // add new facet address if it does not exist\\n    if (selectorPosition == 0) {\\n      addFacet(ds, _facetAddress);\\n    }\\n    for (uint256 selectorIndex; selectorIndex < len; ) {\\n      bytes4 selector = _functionSelectors[selectorIndex];\\n      address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n      require(oldFacetAddress != _facetAddress, \\\"LibDiamondCut: Can't replace function with same function\\\");\\n      removeFunction(ds, oldFacetAddress, selector);\\n      addFunction(ds, selector, selectorPosition, _facetAddress);\\n      selectorPosition++;\\n\\n      unchecked {\\n        ++selectorIndex;\\n      }\\n    }\\n  }\\n\\n  function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n    require(_functionSelectors.length != 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n    DiamondStorage storage ds = diamondStorage();\\n    // get the propose and cut selectors -- can never remove these\\n    bytes4 proposeSelector = IDiamondCut.proposeDiamondCut.selector;\\n    bytes4 cutSelector = IDiamondCut.diamondCut.selector;\\n    // if function does not exist then do nothing and return\\n    require(_facetAddress == address(0), \\\"LibDiamondCut: Remove facet address must be address(0)\\\");\\n    uint256 len = _functionSelectors.length;\\n    for (uint256 selectorIndex; selectorIndex < len; ) {\\n      bytes4 selector = _functionSelectors[selectorIndex];\\n      require(selector != proposeSelector && selector != cutSelector, \\\"LibDiamondCut: Cannot remove cut selectors\\\");\\n      address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n      removeFunction(ds, oldFacetAddress, selector);\\n\\n      unchecked {\\n        ++selectorIndex;\\n      }\\n    }\\n  }\\n\\n  function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\\n    enforceHasContractCode(_facetAddress, \\\"LibDiamondCut: New facet has no code\\\");\\n    ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\\n    ds.facetAddresses.push(_facetAddress);\\n  }\\n\\n  function addFunction(\\n    DiamondStorage storage ds,\\n    bytes4 _selector,\\n    uint96 _selectorPosition,\\n    address _facetAddress\\n  ) internal {\\n    ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\\n    ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\\n    ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\\n  }\\n\\n  function removeFunction(\\n    DiamondStorage storage ds,\\n    address _facetAddress,\\n    bytes4 _selector\\n  ) internal {\\n    require(_facetAddress != address(0), \\\"LibDiamondCut: Can't remove function that doesn't exist\\\");\\n    // an immutable function is a function defined directly in a diamond\\n    require(_facetAddress != address(this), \\\"LibDiamondCut: Can't remove immutable function\\\");\\n    // replace selector with last selector, then delete last selector\\n    uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\\n    uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\\n    // if not the same then replace _selector with lastSelector\\n    if (selectorPosition != lastSelectorPosition) {\\n      bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\\n      ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\\n      ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\\n    }\\n    // delete the last selector\\n    ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\\n    delete ds.selectorToFacetAndPosition[_selector];\\n\\n    // if no more selectors for facet address then delete the facet address\\n    if (lastSelectorPosition == 0) {\\n      // replace facet address with last facet address and delete last facet address\\n      uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\\n      uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n      if (facetAddressPosition != lastFacetAddressPosition) {\\n        address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\\n        ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\\n        ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\\n      }\\n      ds.facetAddresses.pop();\\n      delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n    }\\n  }\\n\\n  function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n    if (_init == address(0)) {\\n      require(_calldata.length == 0, \\\"LibDiamondCut: _init is address(0) but_calldata is not empty\\\");\\n    } else {\\n      require(_calldata.length != 0, \\\"LibDiamondCut: _calldata is empty but _init is not address(0)\\\");\\n      if (_init != address(this)) {\\n        enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");\\n      }\\n      (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n      if (!success) {\\n        if (error.length != 0) {\\n          // bubble up the error\\n          revert(string(error));\\n        } else {\\n          revert(\\\"LibDiamondCut: _init function reverted\\\");\\n        }\\n      }\\n    }\\n  }\\n\\n  function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n    require(_contract.code.length != 0, _errorMessage);\\n  }\\n}\\n\",\"keccak256\":\"0xe66a9ade82f05ecfb38a144084b2dfe357db4de2b3b205ed87b6f55536d52ad1\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50610646806100206000396000f3fe608060405234801561001057600080fd5b50600436106100575760003560e01c806301ffc9a71461005c57806352ef6b2c146100845780637a0ed62714610099578063adfca15e146100ae578063cdffacc6146100ce575b600080fd5b61006f61006a366004610447565b6100f9565b60405190151581526020015b60405180910390f35b61008c61012a565b60405161007b9190610478565b6100a1610196565b60405161007b919061050a565b6100c16100bc366004610587565b610334565b60405161007b91906105b0565b6100e16100dc366004610447565b6103de565b6040516001600160a01b03909116815260200161007b565b600080610104610413565b6001600160e01b0319909316600090815260039093016020525050604090205460ff1690565b60606000610136610413565b6002810180546040805160208084028201810190925282815293945083018282801561018b57602002820191906000526020600020905b81546001600160a01b0316815260019091019060200180831161016d575b505050505091505090565b606060006101a2610413565b60028101549091508067ffffffffffffffff8111156101c3576101c36105c3565b60405190808252806020026020018201604052801561020957816020015b6040805180820190915260008152606060208201528152602001906001900390816101e15790505b50925060005b8181101561032e57600083600201828154811061022e5761022e6105d9565b9060005260206000200160009054906101000a90046001600160a01b0316905080858381518110610261576102616105d9565b6020908102919091018101516001600160a01b03928316905290821660009081526001860182526040908190208054825181850281018501909352808352919290919083018282801561030057602002820191906000526020600020906000905b82829054906101000a900460e01b6001600160e01b031916815260200190600401906020826003010492830192600103820291508084116102c25790505b5050505050858381518110610317576103176105d9565b60209081029190910181015101525060010161020f565b50505090565b60606000610340610413565b6001600160a01b038416600090815260018201602090815260409182902080548351818402810184019094528084529394509192908301828280156103d157602002820191906000526020600020906000905b82829054906101000a900460e01b6001600160e01b031916815260200190600401906020826003010492830192600103820291508084116103935790505b5050505050915050919050565b6000806103e9610413565b6001600160e01b03199093166000908152602093909352505060409020546001600160a01b031690565b60008061044160017fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c6105ef565b92915050565b60006020828403121561045957600080fd5b81356001600160e01b03198116811461047157600080fd5b9392505050565b6020808252825182820181905260009190848201906040850190845b818110156104b95783516001600160a01b031683529284019291840191600101610494565b50909695505050505050565b600081518084526020808501945080840160005b838110156104ff5781516001600160e01b031916875295820195908201906001016104d9565b509495945050505050565b60006020808301818452808551808352604092508286019150828160051b87010184880160005b8381101561057957888303603f19018552815180516001600160a01b03168452870151878401879052610566878501826104c5565b9588019593505090860190600101610531565b509098975050505050505050565b60006020828403121561059957600080fd5b81356001600160a01b038116811461047157600080fd5b60208152600061047160208301846104c5565b634e487b7160e01b600052604160045260246000fd5b634e487b7160e01b600052603260045260246000fd5b8181038181111561044157634e487b7160e01b600052601160045260246000fdfea264697066735822122007272337a247e254dcce8c16a9b9335d5430f6a0082c4e6b2c81a6fdc386495464736f6c63430008110033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100575760003560e01c806301ffc9a71461005c57806352ef6b2c146100845780637a0ed62714610099578063adfca15e146100ae578063cdffacc6146100ce575b600080fd5b61006f61006a366004610447565b6100f9565b60405190151581526020015b60405180910390f35b61008c61012a565b60405161007b9190610478565b6100a1610196565b60405161007b919061050a565b6100c16100bc366004610587565b610334565b60405161007b91906105b0565b6100e16100dc366004610447565b6103de565b6040516001600160a01b03909116815260200161007b565b600080610104610413565b6001600160e01b0319909316600090815260039093016020525050604090205460ff1690565b60606000610136610413565b6002810180546040805160208084028201810190925282815293945083018282801561018b57602002820191906000526020600020905b81546001600160a01b0316815260019091019060200180831161016d575b505050505091505090565b606060006101a2610413565b60028101549091508067ffffffffffffffff8111156101c3576101c36105c3565b60405190808252806020026020018201604052801561020957816020015b6040805180820190915260008152606060208201528152602001906001900390816101e15790505b50925060005b8181101561032e57600083600201828154811061022e5761022e6105d9565b9060005260206000200160009054906101000a90046001600160a01b0316905080858381518110610261576102616105d9565b6020908102919091018101516001600160a01b03928316905290821660009081526001860182526040908190208054825181850281018501909352808352919290919083018282801561030057602002820191906000526020600020906000905b82829054906101000a900460e01b6001600160e01b031916815260200190600401906020826003010492830192600103820291508084116102c25790505b5050505050858381518110610317576103176105d9565b60209081029190910181015101525060010161020f565b50505090565b60606000610340610413565b6001600160a01b038416600090815260018201602090815260409182902080548351818402810184019094528084529394509192908301828280156103d157602002820191906000526020600020906000905b82829054906101000a900460e01b6001600160e01b031916815260200190600401906020826003010492830192600103820291508084116103935790505b5050505050915050919050565b6000806103e9610413565b6001600160e01b03199093166000908152602093909352505060409020546001600160a01b031690565b60008061044160017fc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c6105ef565b92915050565b60006020828403121561045957600080fd5b81356001600160e01b03198116811461047157600080fd5b9392505050565b6020808252825182820181905260009190848201906040850190845b818110156104b95783516001600160a01b031683529284019291840191600101610494565b50909695505050505050565b600081518084526020808501945080840160005b838110156104ff5781516001600160e01b031916875295820195908201906001016104d9565b509495945050505050565b60006020808301818452808551808352604092508286019150828160051b87010184880160005b8381101561057957888303603f19018552815180516001600160a01b03168452870151878401879052610566878501826104c5565b9588019593505090860190600101610531565b509098975050505050505050565b60006020828403121561059957600080fd5b81356001600160a01b038116811461047157600080fd5b60208152600061047160208301846104c5565b634e487b7160e01b600052604160045260246000fd5b634e487b7160e01b600052603260045260246000fd5b8181038181111561044157634e487b7160e01b600052601160045260246000fdfea264697066735822122007272337a247e254dcce8c16a9b9335d5430f6a0082c4e6b2c81a6fdc386495464736f6c63430008110033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "facetAddress(bytes4)": {
        "details": "If facet is not found return address(0).",
        "params": {
          "_functionSelector": "The function selector."
        },
        "returns": {
          "facetAddress_": "The facet address."
        }
      },
      "facetAddresses()": {
        "returns": {
          "facetAddresses_": "facetAddresses_"
        }
      },
      "facetFunctionSelectors(address)": {
        "params": {
          "_facet": "The facet address."
        },
        "returns": {
          "facetFunctionSelectors_": "facetFunctionSelectors_"
        }
      },
      "facets()": {
        "returns": {
          "facets_": "Facet"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "facetAddress(bytes4)": {
        "notice": "Gets the facet that supports the given selector."
      },
      "facetAddresses()": {
        "notice": "Get all the facet addresses used by a diamond."
      },
      "facetFunctionSelectors(address)": {
        "notice": "Gets all the function selectors provided by a facet."
      },
      "facets()": {
        "notice": "Gets all facets and their selectors."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}